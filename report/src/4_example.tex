%! Author = emaia
%! Date = 16/03/20

In order to provide a preliminary investigation that could assess the effectiveness and efficiency of the
novel approach, we selected a small set of vulnerabilities from the considered dataset~\cite{ponta2019msr_dataset}.
The selection was supported by a \textsc{PyDriller}~\cite{spadini2018esecfse_pydriller} script,
that quickly let us filter out the vulnerabilities whose fix commit involved more than one Java class (this was done
by looking at history data gathered by \textsc{PyDriller}).
Moreover, the vulnerabilities were manually inspected to establish whether they are not affected by a serious
code instrumentation issue of \textsc{EvoSuite} --- it does not deal with the dynamic dispatch,
\textit{i.e.,} the resolution of method overriding when polymorphism is used, so some methods are not caught
in the global call graph, making impossible to get their bytecode.
Finally, among the remaining vulnerabilities, only the ones whose fix commit involved a single line were considered
(\textit{i.e.,} that line is its only vulnerable construct).
Among the 28 vulnerabilities, 8 of them were considered for this preliminary investigation, belonging to 8 different
OSS projects available on GitHub (shown in Table~\ref{tab:1}) and whose vulnerable version was available
as a Maven dependency.

\begin{table*}[t]
    \centering
    \begin{tabular}{llrp{8cm}}
        \hline
        \textbf{CVE} & \textbf{Library} & \textbf{Version} & \textbf{Description} \\
        \hline
        CVE-2018-1324 & Apache Commons Compress & 1.15 & DoS when a certain input (\textsc{zip} file) is provided \\
        CVE-2018-17194 & Apache Nifi & 1.7.1 & Time waste with a certain DELETE HTTP requests with non-empty body \\
        CVE-2011-1582 & Apache Tomcat & 7.0.12 & Using a wrong classloader to bypass access restrictions \\
        CVE-2014-9970 & Jasypt & 1.9.1 & Exposition to Timing Attacks by using a linear time hashes comparison function \\
        CVE-2018-1000067 & Jenkins & 2.89.3 & Improper access restriction for a restricted functionality \\
        CVE-2017-1000390 & Tikal Multijob Plugin & 1.26 & Improper access restriction for a restricted functionality \\
        CVE-2018-8718 & Mailer Plugin & 1.20 & Exposition to CSRF for a certain functionality \\
        PRIMEFACES-1194 & Primefaces & 6.1 & Exposition to XSS due to a lack of escaping of a user input \\
        \hline
    \end{tabular}
    \caption{The vulnerabilities considered for the preliminary investigation.}
    \label{tab:1}
\end{table*}

\begin{lstlisting}[float=*,
caption={Vulnerable method of CVE-2018-1324},
label={lst:1},
firstnumber=302
]
public void parseCentralDirectoryFormat(final byte[] data, final int offset, final int length) {
    this.format = ZipShort.getValue(data, offset);
    this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));
    this.bitlen = ZipShort.getValue(data, offset + 4);
    this.flags = ZipShort.getValue(data, offset + 6);
    this.rcount = ZipLong.getValue(data, offset + 8);

    if (rcount > 0) {
        this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12));
        this.hashSize = ZipShort.getValue(data, offset + 14);
        // srlist... hashed public keys
        for (int i = 0; i < this.rcount; i++) {
            for (int j = 0; j < this.hashSize; j++) {
                //  ZipUtil.signedByteToUnsignedInt(data[offset + 16 + (i * this.hashSize) + j]));
            }
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[float=*,
caption={One of the artifical caller classes of CVE-2018-1324},
label={lst:2},
firstnumber=5
]
public class CompressCallerFlexible {

    private X0017_StrongEncryptionHeader seh;
    private byte[] data;
    private int offset;
    private int length;

    public CompressCallerFlexible(byte[] data, int offset, int length) {
        this.seh = new X0017_StrongEncryptionHeader();
        this.data = data;
        this.offset = offset;
        this.length = length;
    }

    public void call() {
        this.seh.parseCentralDirectoryFormat(this.data, this.offset, this.length);
    }
}
\end{lstlisting}

We also provided some \textit{artificial classes}, whose role was to call some classes of the
selected libraries,
so that the GA could be run on these artificial CUTs instead on real projects, whose selection would be not
useful at this point.
Some of these artificial classes merely calls the vulnerable method with some fixed inputs and leaving other
inputs to the GA's generation;
some others classes totally avoid calling the vulnerable method.
This was done to see how the technique reacts to the various cases.

Let's see an example by considering the CVE-2018-1324 vulnerability, related to \textit{Apache Commons Compress},
a library that offers an API for working with many compression algorithms.
The vulnerability involves the line 313 of \textsc{parseCentralDirectoryFormat()} method in class
\textsc{X0017\_StrongEncryptionHeader} (shown in Listing~\ref{lst:1}), and it may bring the program into an
infinite loop state if a certain \textsc{zip} file is provided, leading to a Denial of Service.
This is caused by the usage of an \textsc{int} loop index, that continuously overflows
in cases when the \textsc{long} variable \textit{rcount} has very high values.
This is fixed by the 2a2f1dc commit, that simply changes its type to \textsc{long}.
For this vulnerability, three artificial classes were provided: (i) \textsc{CompressCallerNo}, that does not
call the vulnerable class at all; (ii) \textsc{CompressCallerYes}, that calls the vulnerable method
with specially crafted inputs so that the vulnerable line will surely be covered; (iii)
\textsc{CompressCallerFlexible}, that calls the vulnerable method but leaves to \textsc{EvoSuite} the generation of
the actual arguments (shown in Listing~\ref{lst:2}).

As expected, the algorithm does not start the evolution for \textsc{CompressCallerNo} because the vulnerable method
cannot be reached from this class, meaning that the target call context, required to form the coverage goal, cannot be created;
for \textsc{CompressCallerYes}, the algorithm easily completes the evolution in seconds, as expected.
Things starts to get complicated in \textsc{CompressCallerFlexible} because covering the target control dependencies
requires to pass at least 12 bytes to the \textsc{byte[] data} argument,
so sometimes the evolutions fails if it does not have enough search budget;
however, this is highly influenced by the random initial population, thus, sometimes, the search may be successful.
