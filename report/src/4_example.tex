%! Author = emaia
%! Date = 16/03/20

\textbf{Forse dovrei mostra 2/3 esempi diversi, magari uno artificiale (con JAR dummy) e uno concreto ma semplice}

Suppose we want to generate exploits for the CVE-2017-4971, that is described by the triple
(\textit{\url{org.springframework.webflow.mvc.view.AbstractMvcView}},
\textit{\url{addEmptyValueMapping(Lorg/springframework/binding/mapping/impl/DefaultMapper;Ljava/lang/String;Ljava/lang/Object;)V}},
\textit{485}) and suppose we have a CUT like this:

\begin{lstlisting}[language=java, frame=single]
public class MyCUTSpring {
    private ServletMvcView servletMvcView;

    public MyCUTSpring() {
        servletMvcView = new ServletMvcView(null, null);
    }

    public void callsSpring(String s) {
        servletMvcView.processUserEvent();
    }
}
\end{lstlisting}

The method \texttt{processUserEvent()} calls the target method \texttt{addEmptyValueMapping()}, making the latter to be in the call graph of the CUT\@.
\textbf{To Be Continued}
\textbf{Attention: currently this approach works only for target classes that are not involved in hierarchies.
In this case, AbstractMvcView is an abstract class and we need to call the methods from ServletMvcView.
For unknown reasons, EvoSuite correctly instruments the target class and its child, but it doesn't provide the control
dependencies for each of his bytecode instruction, blocking the goal preparations, thus the entire algorithm.
One thing that I found out is that ServletMvcView is not in the InheritanceTree class of EvoSuite, so
it seems not linked to AbstractMvcView.
I tried with another hierarchy and found the very same problem.
I tried with a class not involved in an hierarchy (i.e. child of Object only) and it works fine.
Another thing that I found out is that the target class is in the call graph from the CUT, but the target method is not.
I don't know where to modify thinks in EvoSuite, so I will contact the authors for help.}
