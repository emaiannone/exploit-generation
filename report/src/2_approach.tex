%! Author = emaia
%! Date = 10/03/20

\textbf{WORK IN PROGRESS SECTION}

In this section we explain the novel search algorithm used for the generation of exploit test cases.

\subsection{Background and Assumptions}\label{subsec:assumptions}
% Evosuite: general
We chose to implement this algorithm as an extension of \textsc{EvoSuite}~\cite{fraser2013_evosuite}, an automatic \textit{JUnit} tests generator
for \textit{Java} classes by using an evolutionary approach based on a genetic algorithms to derive test suites.
\textsc{EvoSuite}'s default behaviour is a \textit{whole suite} approach, where it treats the entire test suite as an individual
of the evolving population and it tries to find the smallest possible test suite (\textit{i.e.,} with minimal
number of total statements among all individuals) that covers all feasible coverage goals.
Currently, \textsc{EvoSuite} supports multiple coverage criteria, such as branch, method, line, def-use, mutation, exceptions, etc.
Moreover, \textsc{EvoSuite} is able to generate assertions for each test case of the individuals;
however, in the context of our work we are not generating tests (\textit{i.e.,} program executions that verifies a certain
expected behaviour) but exploits, so we disabled the assert generation \textbf{Are we sure they can be disabled?}.

% Evosuite: why extend
\textsc{EvoSuite} is a fully-fledged genetic algorithm framework, so it allows to (i) add new coverage criteria,
(ii) add new search operators (\textit{i.e.,} crossover and mutation), (iii) reuse well-validated meta-heuristic search techniques and (iv) reuse the
instrumentation and program analysis tools (\textit{e.g.,} Control Flow Graphs, Call Graphs, Execution Traces, etc.).
It is possible to extend \textsc{EvoSuite} by adding some classes (related to the new coverage criteria and search operators),
and make small changes in others.
Sections~\ref{subsec:goals},~\ref{subsec:fitness} and~\ref{subsec:operators} provides additional details on the search algorithm.

% Dataset
\textbf{Dataset explained here or in another section (3?) about the validation?}

We chose to analyze the vulnerabilities of well-known OSS Java libraries and frameworks (\textit{e.g.,} Tomcat, Jenkins, Spark, Kafka).
Their vulnerabilities are publicly disclosed as CVE and collected in the NVD. In particular \citeauthor{ponta2019msr_dataset},
defined and made available a manually-curated dataset of fixes of these known
vulnerabilities~\cite{ponta2019msr_dataset}.
This dataset maps for each CVE entry the related repository URL and the signature of the fix commit
(\textit{i.e.,} the commit that officially patches the vulnerability).
So, the dataset has the form of a set of triples \textit{(CVE\_entry, repository\_url, fix\_commit\_hash)}, for example
(CVE-2017-4971, \url{https://github.com/spring-projects/spring-webflow}, 57f2ccb66946943fbf3b3f2165eac1c8eb6b1523).
Each fix commit is very different: some of them only apply changes on few lines in a single class, while others
consists of addition and refactoring of methods in various classes. (\textbf{I don't like this sentence})
We are interested in understanding the set of vulnerable constructs (\textit{i.e.,} the set of fixed constructs),
because we want to analyze the various forms of vulnerabilities to find a common representation that is suitable for the search algorithm.

% Assumptions
We chose to focus on what we consider the most simple type of vulnerable construct, that is the vulnerable line (\textit{i.e., } a line
that an attacker can exploit by giving it a certain malicious input), so the proposed coverage criterion is a
variation of the line coverage one.
When this approach will be mature enough, we will extend it to other types of vulnerabilities.

\subsection{Coverage Goals}\label{subsec:goals}
\textbf{I have to be sure about the descriptors.
Resolve the line breaks}

Our approach is able to work on multiple coverage goals in a single run.
A coverage goal is defined from a triple of strings \textit{(vulnerable\_class}, \textit{vulnerable\_method},
\textit{vulnerable\_line}) where \textit{vulnerable\_class} is the fully-qualified name of the vulnerable class (\textit{e.g.,}
\texttt{org.springframework.webflow.mvc.view.AbstractMvcView}), \textit{vulnerable\_method} is the name of the vulnerable
method concatenated with its descriptor (\textit{e.g.,}
\texttt{addEmptyValueMapping(Lorg/springframework/binding/mapping/implDefaultMapper;Ljava/lang/String;Ljava/lang/Object;)V})
and \textit{vulnerable\_line} is the number of the vulnerable line in the source code.
The strings \textit{vulnerable\_class} and \textit{vulnerable\_method} are used to determine the right \textit{call context},
\textit{i.e.,} the list of method calls from Class Under Test (CUT) needed to reach the vulnerable method in the vulnerable class;
the string \textit{vulnerable\_line} is used to retrieve the list of control dependencies on the vulnerable line, that acts
as its path condition (\textit{i.e.,} the list of predicates to be satisfied in order to execute a certain path).

Basically, each coverage goal is composed of (i) a call context to reach a certain vulnerable method and
(ii) the list of control dependencies needed to execute vulnerable line.
An individual (test suite) covers a goal whenever it has a test case whose execution trace covers the call context and all control dependencies.

\textbf{Currently, I tried with only a single hard-coded goal per run.
The next steps will be (i) find a way to create the goal without hard-coding and (ii) try the approach with multiple goals}

\subsection{Fitness Function}\label{subsec:fitness}
- Explain the (primitive) formula

\subsection{Search Operators}\label{subsec:operators}
- To Be Implemented to improve performance

\subsection{Measuring the Effort}\label{subsec:effort}
- To Be Implemented to measure how hard was/were a/some goals
