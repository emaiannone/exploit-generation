%! Author = emaia
%! Date = 10/03/20

\textbf{WORK IN PROGRESS SECTION}

In this section we explain the novel search algorithm used for the generation of exploit test cases.

\subsection{Preliminary Assumptions}\label{subsec:assumptions}
% Dataset
\textbf{Should I explain the dataset here or in another section (maybe 4?) when presenting the validation?}
We chose to analyze the vulnerabilities of well-known OSS Java libraries and frameworks (\textit{e.g.,} Spring, Jenkins, Spark, Kafka).
Their vulnerabilities are publicly disclosed as CVE and collected in the NVD. In particular \citeauthor{ponta2019msr_dataset},
defined and made available a manually-curated dataset of fixes of these known
vulnerabilities~\cite{ponta2019msr_dataset}.
This dataset maps for each CVE entry the related repository URL and the signature of the fix commit
(\textit{i.e.,} the commit that officially patches the vulnerability).
So, the dataset has the form of a set of triples \textit{(CVE\_entry, repository\_url, fix\_commit\_hash)}, for example
(CVE-2017-4971, \url{https://github.com/spring-projects/spring-webflow}, 57f2ccb66946943fbf3b3f2165eac1c8eb6b1523).
Each fix commit is very different: some of them only apply changes on few lines in a single class, while others
consists of addition and refactoring of methods in various classes. (\textbf{I don't like this sentence})
We are interested in understanding the set of vulnerable constructs (\textit{i.e.,} the set of fixed constructs),
because we want to analyze the various forms of vulnerabilities to find a common representation that is suitable for the search algorithm.

% Assumptions
We chose to focus on what we consider the most simple type of vulnerable construct, that is the vulnerable line (\textit{i.e., }
a source code line that an attacker can exploit by giving it a certain malicious input), so the proposed coverage criterion is a
variation of the line coverage one.
When this approach will be mature enough, we will extend it to other types of vulnerabilities.

% Evosuite: why extend
We chose to implement this novel algorithm as an extension of \textsc{EvoSuite}~\cite{fraser2013_evosuite},
an automatic \textit{JUnit} tests generator for \textit{Java} classes by using a whole suite evolutionary approach
to derive the best possible test suites (\textit{i.e.,} covering all feasible goals and having the minimal number of total statements).
\textsc{EvoSuite} is a fully fledged GA framework, so it allows to (i) add new coverage criteria,
(ii) add new genetic operators (\textit{i.e.,} selection, crossover and mutation), (iii) reuse well-validated meta-heuristics and
(iv) reuse the instrumentation and program analysis tools, such as Control Flow Graphs, Call Graphs and Execution Traces.
It is possible to extend \textsc{EvoSuite} by adding some classes (related to the new coverage criteria and genetic operators),
and make small changes in others.
Sections~\ref{subsec:goals},~\ref{subsec:fitness} and~\ref{subsec:operators} provides additional details on the search algorithm.
In the context of our work we are not generating tests in the narrow sense (\textit{i.e.,} program execution that verifies a certain
expected behaviour) but `exploits cases', so we disabled the assert generation engine \textbf{Are we sure it can be disabled?}.

\subsection{Coverage Goals}\label{subsec:goals}
\textbf{I have to be sure about the descriptors}

Our approach is able to work on multiple coverage goals in a single run.
A coverage goal is defined from a triple of strings \textsc{(vulnerable\_class}, \textsc{vulnerable\_method},
\textsc{vulnerable\_line}) where \textsc{vulnerable\_class} is the fully-qualified name of the vulnerable class (\textit{e.g.,}
\sloppy\textit{\url{org.springframework.webflow.mvc.view.AbstractMvcView}}), \textsc{vulnerable\_method} is the name of the vulnerable
method concatenated with its descriptor (\textit{e.g.,}
\sloppy\textit{\url{addEmptyValueMapping(Lorg/springframework/binding/mapping/impl/DefaultMapper;Ljava/lang/String;Ljava/lang/Object;)V}})
and \textsc{vulnerable\_line} is the number of the vulnerable line in the source code.
The strings \textsc{vulnerable\_class} and \textsc{vulnerable\_method} are used to determine the right \textit{call context},
\textit{i.e.,} the list of method calls from the class under test (CUT) needed to reach the vulnerable method in the vulnerable class;
the string \textsc{vulnerable\_line} is used to retrieve the list of control dependencies on the vulnerable line
(\textit{i.e.,} predicates to be satisfied in order to certainly execute that line).

In other words, each coverage goal is composed of (i) a call context to reach a certain vulnerable method and
(ii) the list of control dependencies needed to execute vulnerable line.
An individual (test suite) covers a goal whenever it has a test case whose execution trace covers the call context and all
control dependencies in the list.

\textbf{Currently, I tried with only a single hard-coded goal per run.
The next steps will be (i) find a way to create the goal without hard-coding and (ii) try the approach with multiple goals}

\subsection{Fitness Function}\label{subsec:fitness}
- Explain the (primitive) formula

\subsection{Genetic Operators}\label{subsec:operators}
- To Be Implemented to improve performance

\subsection{Measuring the Effort}\label{subsec:effort}
- To Be Implemented to measure how hard was/were a/some goals
