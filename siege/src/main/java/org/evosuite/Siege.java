package org.evosuite;

import com.opencsv.CSVReader;
import com.opencsv.CSVReaderBuilder;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.evosuite.coverage.vulnerability.VulnerabilityDescription;
import org.evosuite.ga.metaheuristics.GeneticAlgorithm;
import org.evosuite.result.TestGenerationResult;
import org.evosuite.testcase.TestChromosome;
import org.evosuite.utils.LoggingUtils;
import org.slf4j.Logger;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Siege {
    private static final Logger logger = LoggingUtils.getEvoLogger();

    public static final String CLASS = "class";
    public static final String TARGET = "target";
    public static final String LIBRARIES = "librariesPath";
    public static final String VULNERABILITIES = "vulnerabilities";
    public static final String VULN_CLASS = "vulnClass";
    public static final String VULN_METHOD = "vulnMethod";
    public static final String VULN_LINE = "vulnLine";
    public static final String BUDGET = "budget";
    public static final String EXPORT = "export";

    public static final String DEFAULT_TARGET = "target/classes";
    public static final String DEFAULT_LIBRARIES = "target/lib";
    public static final String EXPORTS_DIR = "siege_exports/";

    public static void main(String[] args) throws IOException {
        Options options = new Options();
        options.addOption(new Option(CLASS, true, "Client class where an exploit will start from. A fully qualifying needs to be provided, e.g. org.foo.SomeClass"));
        options.addOption(new Option(TARGET, true, "Client project classpath. A directory containing all compiled Java classes needs to be provided, e.g. target/classes"));
        options.addOption(new Option(LIBRARIES, true, "Libraries root directory. A directory all the JARs required by client project needs to be provided, e.g. target/lib"));
        options.addOption(new Option(VULNERABILITIES, true, "CSV File containing descriptions of a set of known vulnerabilities. A CSV file needs to be provided."));
        options.addOption(new Option(VULN_CLASS, true, "Vulnerable class to be targeted by an exploit. A fully qualifying needs to be provided, e.g. org.foo.SomeClass"));
        options.addOption(new Option(VULN_METHOD, true, "Vulnerable method to be targeted by an exploit. A name and descriptor needs to be provided, e.g. someMethod([B[B)Z"));
        options.addOption(new Option(VULN_LINE, true, "Vulnerable line to be targeted by an exploit. A non negative number needs to be provided, e.g. 12."));
        options.addOption(new Option(BUDGET, true, "Allotted search budget. A non negative number needs to be provided, e.g. 50."));
        options.addOption(new Option(EXPORT, false, "Generate a .csv export of the results in the CWD."));

        String clientClass = null;
        String target = null;
        String libraries = null;
        String vulnerabilities = null;
        String vulnClass = null;
        String vulnMethod = null;
        String vulnLine = null;
        String budget = null;
        boolean export = false;
        CommandLineParser parser = new DefaultParser();
        try {
            CommandLine line = parser.parse(options, args);
            clientClass = line.getOptionValue(CLASS);
            target = line.hasOption(TARGET) ? line.getOptionValue(TARGET) : DEFAULT_TARGET;
            libraries = line.hasOption(LIBRARIES) ? line.getOptionValue(LIBRARIES) : DEFAULT_LIBRARIES;
            vulnerabilities = line.getOptionValue(VULNERABILITIES);
            vulnClass = line.getOptionValue(VULN_CLASS);
            vulnMethod = line.getOptionValue(VULN_METHOD);
            vulnLine = line.getOptionValue(VULN_LINE);
            budget = line.getOptionValue(BUDGET);
            export = line.hasOption(EXPORT);
        } catch (ParseException e) {
            logger.error("Invalid options. Exiting.");
            System.exit(1);
        }

        // Get target vulnerability(ies)
        List<VulnerabilityDescription> vulnerabilityList = new ArrayList<>();
        if (vulnerabilities != null) {
            try {
                vulnerabilityList.addAll(readAndParseCsv(vulnerabilities));
            } catch (IOException e) {
                logger.error("Vulnerabilities file not found. Exiting.");
                System.exit(1);
            }
        } else {
            if (vulnClass == null && vulnMethod == null && vulnLine == null) {
                logger.error("Either vulnerabilities or vulnClass, vulnMethod and vulnLine needs to be specified.");
                System.exit(1);
            }
            if (vulnClass == null || vulnMethod == null || vulnLine == null) {
                logger.error("All vulnClass, vulnMethod and vulnLine needs to be specified togeher.");
                System.exit(1);
            }
            vulnerabilityList.add(new VulnerabilityDescription(vulnClass, vulnMethod, Integer.parseInt(vulnLine)));
        }

        // TODO Bound population?
        // TODO Is there a way not to stop the generation when all the TC have the same fitness? Which MH is the best?
        List<String> baseCommands = new ArrayList<>(Arrays.asList(
                "-generateTests",
                "-criterion", Properties.Criterion.VULNERABILITY.name(),
                "-Dstrategy=" + Properties.Strategy.ONEBRANCH.name(),
                "-Dinstrument_context=true",
                "-Dinstrument_method_calls=true",
                "-Dinstrument_libraries=true",
                "-Dassertions=false",
                "-Dminimize=true",
                "-Dstopping_condition=" + Properties.StoppingCondition.MAXTIME,
                "-Dpopulation=" + 100,
                "-Djunit_suffix=SiegeTest"
        ));
        if (clientClass != null) {
            baseCommands.add("-class");
            baseCommands.add(clientClass);
        } else {
            baseCommands.add("-target");
            baseCommands.add(target);
        }
        baseCommands.add("-projectCP");
        baseCommands.add(buildProjectClasspath(target, libraries));
        // Default budget is 60 (set by EvoSuite if -Dsearch_budget is not specified)
        if (budget != null) {
            baseCommands.add("-Dsearch_budget=" + budget);
        }
        String project = System.getProperty("user.dir");
        String canonicalProjectPath = (new File(project)).getCanonicalPath();
        generateExploits(canonicalProjectPath, vulnerabilityList, baseCommands, export);
        System.exit(0);
    }

    private static void generateExploits(String project, List<VulnerabilityDescription> vulnerabilityList, List<String> baseCommands, boolean export) {
        EvoSuite evoSuite = new EvoSuite();
        List<List<String>> exportResults = new ArrayList<>();
        if (export) {
            exportResults.add(Arrays.asList("budget", "cve", "elapsed"));
        }
        logger.info("* Generating Exploits through {}\n", project);
        for (VulnerabilityDescription vulnerabilityDescription : vulnerabilityList) {
            logger.info("* Target Vulnerability: {}", vulnerabilityDescription);
            List<String> evoSuiteCommands = new ArrayList<>(baseCommands);
            evoSuiteCommands.add("-DvulnClass=" + vulnerabilityDescription.getVulnerableClass());
            evoSuiteCommands.add("-DvulnMethod=" + vulnerabilityDescription.getVulnerableMethod());
            evoSuiteCommands.add("-DvulnLine=" + vulnerabilityDescription.getVulnerableLine());
            try {
                List<List<TestGenerationResult>> fullResults = (List<List<TestGenerationResult>>) evoSuite.parseCommandLine(evoSuiteCommands.toArray(new String[0]));
                if (fullResults.size() == 0) {
                    logger.info("\n* No results for {}", vulnerabilityDescription);
                } else {
                    logger.info("\n* Results for {}", vulnerabilityDescription);
                    for (List<TestGenerationResult> testResults : fullResults) {
                        for (TestGenerationResult testResult : testResults) {
                            GeneticAlgorithm<?> ga = testResult.getGeneticAlgorithm();
                            TestChromosome best = (TestChromosome) ga.getBestIndividual();
                            logger.info("* Terminated (with {} seconds budget)! Age: {}, Population Size: {}", Properties.SEARCH_BUDGET, ga.getAge(), ga.getPopulationSize());
                            logger.info("* Best Individual {} (Gen {}, Eval {}):", best.getTestCase().getID(), best.getAge(), best.getNumberOfEvaluations());
                            logger.info(best.getTestCase().toCode());
                            logger.info("* Best Individual after Minimization:");
                            logger.info(testResult.getTestCase("test0").toCode());
                            if (export) {
                                //TODO Remove placeholders as soon as VulnerabilityDescription is moved
                                exportResults.add(Arrays.asList(String.valueOf(Properties.SEARCH_BUDGET), "CVE", "ELAPSED"));
                            }
                        }
                    }
                }
            } catch (Exception e) {
                // Print and skip
                logger.error("Could not generate exploit: " + e.getMessage());
            }
            logger.info("");
        }
        if (export) {
            String projectName = project.substring(project.lastIndexOf('/') + 1);
            writeToCsv(projectName, exportResults);
        }
    }

    private static String buildProjectClasspath(String target, String librariesPath) {
        StringBuilder jarsPaths = new StringBuilder();
        File jarsDir = new File(librariesPath);
        if (jarsDir.isDirectory()) {
            for (File file : jarsDir.listFiles()) {
                if (file.isFile() && file.getName().contains(".jar")) {
                    jarsPaths.append(":");
                    jarsPaths.append(file.getAbsolutePath());
                }
            }
        }
        return target + jarsPaths;
    }

    private static List<VulnerabilityDescription> readAndParseCsv(String file) throws IOException {
        List<VulnerabilityDescription> vulnerabilityList = new ArrayList<>();
        try (CSVReader reader = new CSVReaderBuilder(new FileReader(file)).withSkipLines(1).build()) {
            String[] values;
            while ((values = reader.readNext()) != null) {
                vulnerabilityList.add(new VulnerabilityDescription(values[2], values[3], Integer.parseInt(values[4])));
            }
        }
        return vulnerabilityList;
    }

    private static void writeToCsv(String filename, List<List<String>> content) {
        File exportDir = new File(EXPORTS_DIR);
        if (!exportDir.exists()) {
            exportDir.mkdir();
        }
        String fullFilename = EXPORTS_DIR + filename + ".csv";
        try (PrintWriter csvWriter = new PrintWriter(new FileOutputStream(fullFilename, true))) {
            for (List<String> line : content) {
                String csvLine = String.join(",", line);
                csvWriter.println(csvLine);
            }
        } catch (FileNotFoundException e) {
            logger.error("Cannot write to " + fullFilename + ": quit exporting.");
        }
    }
}
