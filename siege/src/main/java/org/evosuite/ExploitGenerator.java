package org.evosuite;

import org.apache.commons.lang3.tuple.Pair;
import org.evosuite.coverage.vulnerability.VulnerabilityDescription;
import org.evosuite.ga.metaheuristics.GeneticAlgorithm;
import org.evosuite.result.TestGenerationResult;
import org.evosuite.testcase.TestCase;
import org.evosuite.testcase.TestChromosome;
import org.evosuite.utils.LoggingUtils;
import org.slf4j.Logger;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class ExploitGenerator {
    private static final Logger logger = LoggingUtils.getEvoLogger();

    public static final String STATUS_UNREACHABLE = "UNREACHABLE";
    public static final String STATUS_REACHABLE = "REACHABLE";

    public List<List<String>> generateExploits(String fullProjectPath, List<Pair<String, VulnerabilityDescription>> vulnerabilityList, List<String> baseCommands) {
        EvoSuite evoSuite = new EvoSuite();
        List<List<String>> exportResults = new ArrayList<>();
        logger.info("* Generating Exploits using client {}\n", fullProjectPath);
        for (Pair<String, VulnerabilityDescription> vulnerability : vulnerabilityList) {
            logger.info("* Target Vulnerability: {}", vulnerability.getLeft());
            List<String> evoSuiteCommands = new ArrayList<>(baseCommands);
            evoSuiteCommands.add("-DvulnClass=" + vulnerability.getRight().getVulnerableClass());
            evoSuiteCommands.add("-DvulnMethod=" + vulnerability.getRight().getVulnerableMethod());
            evoSuiteCommands.add("-DvulnLine=" + vulnerability.getRight().getVulnerableLine());
            try {
                List<List<TestGenerationResult>> fullResults = (List<List<TestGenerationResult>>) evoSuite.parseCommandLine(evoSuiteCommands.toArray(new String[0]));
                String status;
                logger.info("\n* Results for {}", vulnerability.getLeft());
                if (fullResults.size() == 0) {
                    status = STATUS_UNREACHABLE;
                    logger.info("* Status: {}", status);
                    exportResults.add(Arrays.asList(
                            vulnerability.getLeft(), status, null, String.valueOf(Properties.SEARCH_BUDGET), null, null
                    ));
                } else {
                    for (List<TestGenerationResult> testResults : fullResults) {
                        for (TestGenerationResult clientClassResult : testResults) {
                            status = String.valueOf(clientClassResult.getTestGenerationStatus());
                            String clientClass = clientClassResult.getClassUnderTest();
                            GeneticAlgorithm<?> ga = clientClassResult.getGeneticAlgorithm();
                            TestChromosome best = (TestChromosome) ga.getBestIndividual();
                            int gaIterations = ga.getAge() + 1;

                            // Oddly, spent budget cannot be taken easily since EvoSuite does not keep track of the stopping conditions in ga object
                            exportResults.add(Arrays.asList(
                                    vulnerability.getLeft(), status, clientClass, String.valueOf(Properties.SEARCH_BUDGET), String.valueOf(best.getFitness()), String.valueOf(gaIterations)
                            ));
                            logger.info("* Results of client class {}", clientClassResult.getClassUnderTest());
                            logger.info("* Status: {}", status);
                            logger.info("* GA terminated within {} seconds. Iteration {}, Population Size {}", Properties.SEARCH_BUDGET, gaIterations, ga.getPopulationSize());
                            logger.info("* Best Individual ID {} (Iteration {}, Evals {}), scored {}:", best.getTestCase().getID(), best.getAge(), best.getNumberOfEvaluations(), best.getFitness());
                            logger.info(best.getTestCase().toCode());
                            TestCase minimizedTC = clientClassResult.getTestCase("test0");
                            if (minimizedTC != null) {
                                logger.info("* Best Individual post Minimization:");
                                logger.info(minimizedTC.toCode());
                            } else {
                                logger.info("* Best Individual could not be minimized: not all goals were covered.");
                            }
                        }
                    }
                }
            } catch (Exception e) {
                // Print and go to next iteration
                logger.error("Error while generating exploits for {}", vulnerability.getLeft());
                e.printStackTrace();
            }
            logger.info("");
        }
        return exportResults;
    }

}
