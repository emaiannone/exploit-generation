package org.evosuite;

import org.apache.commons.lang3.tuple.Pair;
import org.evosuite.coverage.vulnerability.VulnerabilityDescription;
import org.evosuite.ga.stoppingconditions.MaxTimeStoppingCondition;
import org.evosuite.ga.stoppingconditions.StoppingCondition;
import org.evosuite.result.TestGenerationResult;
import org.evosuite.testcase.TestChromosome;
import org.evosuite.utils.LoggingUtils;
import org.slf4j.Logger;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class ExploitGenerator {
    private final EvoSuite evoSuite;
    private static final Logger logger = LoggingUtils.getEvoLogger();

    public static final String STATUS_UNREACHABLE = "UNREACHABLE";
    public static final String STATUS_SUCCESS = "SUCCESS";
    public static final String STATUS_FAILED = "FAILED";

    public ExploitGenerator(EvoSuite evoSuite) {
        this.evoSuite = evoSuite;
    }

    public List<Map<String, String>> generateExploits(List<Pair<String, VulnerabilityDescription>> vulnerabilityList, List<String> baseCommands) {
        List<Map<String, String>> results = new ArrayList<>();
        for (int i = 0; i < vulnerabilityList.size(); i++) {
            Pair<String, VulnerabilityDescription> vulnerability = vulnerabilityList.get(i);
            logger.info("\n({}/{}) Going to generate exploits for: {}", i + 1, vulnerabilityList.size(), vulnerability.getLeft());
            List<String> evoSuiteCommands = new ArrayList<>(baseCommands);
            evoSuiteCommands.add("-DvulnClass=" + vulnerability.getRight().getVulnerableClass());
            evoSuiteCommands.add("-DvulnMethod=" + vulnerability.getRight().getVulnerableMethod());
            try {
                @SuppressWarnings("unchecked")
                List<List<TestGenerationResult>> evoSuiteResults = (List<List<TestGenerationResult>>)
                        evoSuite.parseCommandLine(evoSuiteCommands.toArray(new String[0]));
                logger.info("-> Results for {}", vulnerability.getLeft());
                // This means that the vulnerability was reached by no classes
                // TODO We have no results even when the exploitation starts but fail
                if (evoSuiteResults.size() == 0) {
                    Map<String, String> result = new LinkedHashMap<>();
                    result.put("cve", vulnerability.getLeft());
                    result.put("clientClass", "");
                    result.put("status", STATUS_UNREACHABLE);
                    result.put("totalBudget", String.valueOf(Properties.SEARCH_BUDGET));
                    result.put("spentBudget", "");
                    result.put("populationSize", String.valueOf(Properties.POPULATION));
                    result.put("bestFitness", "");
                    result.put("iterations", "");
                    results.add(result);
                    logger.info("--> Status: {}", result.get("status"));
                } else {
                    for (List<TestGenerationResult> testResults : evoSuiteResults) {
                        for (TestGenerationResult clientClassResult : testResults) {
                            Map<String, String> result = new LinkedHashMap<>();
                            result.put("cve", vulnerability.getLeft());
                            result.put("clientClass", clientClassResult.getClassUnderTest());
                            if (clientClassResult.getTestGenerationStatus() == TestGenerationResult.Status.SUCCESS) {
                                Set<StoppingCondition<TestChromosome>> stoppingConditions = clientClassResult.getGeneticAlgorithm().getStoppingConditions();
                                long spentBudget = 0;
                                for (StoppingCondition<TestChromosome> stoppingCondition : stoppingConditions) {
                                    if (stoppingCondition instanceof MaxTimeStoppingCondition) {
                                        spentBudget = stoppingCondition.isFinished() ? stoppingCondition.getLimit() : stoppingCondition.getCurrentValue();
                                    }
                                }
                                //FitnessFunction<TestChromosome> fitnessFunction = (FitnessFunction<TestChromosome>) clientClassResult.getGeneticAlgorithm().getFitnessFunctions().get(0);
                                TestChromosome bestIndividual = (TestChromosome) clientClassResult.getGeneticAlgorithm().getBestIndividual();
                                double bestFitness = bestIndividual.getFitness();
                                if (bestFitness == 0.0) {
                                    result.put("status", STATUS_SUCCESS);
                                } else {
                                    result.put("status", STATUS_FAILED);
                                }
                                long iterations = clientClassResult.getGeneticAlgorithm().getAge() + 1;
                                result.put("totalBudget", String.valueOf(Properties.SEARCH_BUDGET));
                                result.put("spentBudget", String.valueOf(spentBudget));
                                result.put("populationSize", String.valueOf(Properties.POPULATION));
                                result.put("bestFitness", String.valueOf(bestFitness));
                                result.put("iterations", String.valueOf(iterations));
                                results.add(result);
                                logger.info("--> Status: {}", result.get("status"));
                                logger.info("--> Through Client: {}", result.get("clientClass"));
                                logger.info("--> Using {}/{} seconds, within {} iterations.", result.get("spentBudget"), result.get("totalBudget"), result.get("iterations"));
                                logger.info("--> Best Individual has ID {}.", bestIndividual.getTestCase().getID());
                            }
                        }
                    }
                }
            } catch (Exception e) {
                // Print and go to next iteration
                logger.error("Error while generating exploits for " + vulnerability.getLeft() + ". Skipping.", e);
            }
        }
        return results;
    }

}
