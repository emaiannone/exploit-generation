package org.evosuite;

import org.apache.commons.lang3.tuple.Pair;
import org.evosuite.coverage.vulnerability.VulnerabilityDescription;
import org.evosuite.result.TestGenerationResult;
import org.evosuite.testcase.TestChromosome;
import org.evosuite.utils.LoggingUtils;
import org.slf4j.Logger;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class ExploitGenerator {
    private final EvoSuite evoSuite;
    private static final Logger logger = LoggingUtils.getEvoLogger();

    public static final String STATUS_UNREACHABLE = "UNREACHABLE";
    public static final String STATUS_UNREACHED = "UNREACHED";
    public static final String STATUS_REACHED = "REACHED";

    public ExploitGenerator(EvoSuite evoSuite) {
        this.evoSuite = evoSuite;
    }

    public List<Map<String, String>> generateExploits(List<Pair<String, VulnerabilityDescription>> vulnerabilityList, List<String> baseCommands) {
        List<Map<String, String>> results = new ArrayList<>();
        for (int i = 0; i < vulnerabilityList.size(); i++) {
            Pair<String, VulnerabilityDescription> vulnerability = vulnerabilityList.get(i);
            logger.info("\n({}/{}) Going to generate exploits for: {}", i + 1, vulnerabilityList.size(), vulnerability.getLeft());
            List<String> evoSuiteCommands = new ArrayList<>(baseCommands);
            evoSuiteCommands.add("-DvulnClass=" + vulnerability.getRight().getVulnerableClass());
            evoSuiteCommands.add("-DvulnMethod=" + vulnerability.getRight().getVulnerableMethod());
            evoSuiteCommands.add("-DvulnLine=" + vulnerability.getRight().getVulnerableLine());
            try {
                @SuppressWarnings("unchecked")
                List<List<TestGenerationResult>> evoSuiteResults = (List<List<TestGenerationResult>>)
                        evoSuite.parseCommandLine(evoSuiteCommands.toArray(new String[0]));
                logger.info("-> Results for {}", vulnerability.getLeft());
                // This means that the vulnerability was reached by no classes
                if (evoSuiteResults.size() == 0) {
                    Map<String, String> result = new LinkedHashMap<>();
                    result.put("cve", vulnerability.getLeft());
                    result.put("status", STATUS_UNREACHABLE);
                    result.put("clientClass", null);
                    result.put("totalBudget", String.valueOf(Properties.SEARCH_BUDGET));
                    result.put("spentBudget", "0");
                    result.put("populationSize", String.valueOf(Properties.POPULATION));
                    result.put("bestFitness", null);
                    result.put("iterations", null);
                    results.add(result);
                    logger.info("-> Status: {}", result.get("status"));
                } else {
                    // TODO Likely, evosuite does not set the GA correctly
                    // TODO What about the other classes? Could they be taken into account for the export?
                    for (List<TestGenerationResult> testResults : evoSuiteResults) {
                        for (TestGenerationResult clientClassResult : testResults) {
                            Map<String, String> result = new LinkedHashMap<>();
                            result.put("cve", vulnerability.getLeft());
                            logger.info(clientClassResult.getTestGenerationStatus().toString());
                            // TODO Even if the budget exceeds, the outcome is still success...
                            if (clientClassResult.getTestGenerationStatus() == TestGenerationResult.Status.SUCCESS) {
                                result.put("status", STATUS_REACHED);
                                result.put("clientClass", clientClassResult.getClassUnderTest());
                                result.put("totalBudget", String.valueOf(Properties.SEARCH_BUDGET));
                                // Should be the spent budget, but oddly EvoSuite does not keep track of this. For now, let's keep it to 0
                                result.put("spentBudget", "0");
                                result.put("populationSize", String.valueOf(Properties.POPULATION));
                                result.put("bestFitness", String.valueOf(clientClassResult.getGeneticAlgorithm().getBestIndividual().getFitness()));
                                result.put("iterations", String.valueOf(clientClassResult.getGeneticAlgorithm().getAge() + 1));
                                results.add(result);
                                logger.info("-> Status: {}", result.get("status"));
                                logger.info("-> Through Client: {}", result.get("clientClass"));
                                logger.info("-> Using {}/{} seconds, within {} iterations.", result.get("spentBudget"), result.get("totalBudget"), result.get("iterations"));
                                logger.info("-> Best Individual has ID {}.", ((TestChromosome) clientClassResult.getGeneticAlgorithm().getBestIndividual()).getTestCase().getID());
                            }
                        }
                    }
                }
            } catch (Exception e) {
                // Print and go to next iteration
                logger.error("Error while generating exploits for " + vulnerability.getLeft() + ". Skipping.", e);
            }
        }
        return results;
    }

}
