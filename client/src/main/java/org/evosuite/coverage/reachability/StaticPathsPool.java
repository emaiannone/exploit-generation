package org.evosuite.coverage.reachability;

import org.evosuite.Properties;
import org.evosuite.setup.DependencyAnalysis;
import org.evosuite.setup.callgraph.CallGraph;
import org.evosuite.setup.callgraph.CallGraphEntry;
import org.evosuite.utils.GenerationLogger;

import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

public class StaticPathsPool {
    private static final GenerationLogger GENERATION_LOGGER = new GenerationLogger(Properties.GENERATION_LOG_FILE);
    private static final Map<String, Map<String, Set<StaticPath>>> cachedPathsToTarget = new LinkedHashMap<>();

    public static Set<StaticPath> getPathsToTarget(String targetClass, String targetMethod) {
        Map<String, Set<StaticPath>> staticPathsToClass = cachedPathsToTarget.get(targetClass);
        if (staticPathsToClass != null && staticPathsToClass.containsKey(targetMethod)) {
            return staticPathsToClass.get(targetMethod);
        }
        CallGraph clientCallGraph = DependencyAnalysis.getCallGraph();
        CallGraphEntry targetNode = clientCallGraph.getViewOfCurrentMethods()
                .stream()
                .filter(node -> node.getClassName().equals(targetClass) && node.getMethodName().equals(targetMethod))
                .findFirst().orElse(null);
        if (targetNode == null) {
            GENERATION_LOGGER.write(String.format("Method %s.%s is not called by any class in the classpath.", targetClass, targetMethod));
            return new LinkedHashSet<>();
        }
        Set<StaticPath> staticPathsToTarget = findStaticPathsToNode(clientCallGraph, targetNode, null);
        addIfNotExists(targetClass, targetMethod, staticPathsToTarget);
        return staticPathsToTarget;
    }

    private static void addIfNotExists(String targetClass, String targetMethod, Set<StaticPath> newPathsToTarget) {
        Map<String, Set<StaticPath>> staticPathsToClass = cachedPathsToTarget.get(targetClass);
        if (staticPathsToClass == null) {
            Map<String, Set<StaticPath>> staticPathsToMethod = new LinkedHashMap<>();
            staticPathsToMethod.put(targetMethod, newPathsToTarget);
            cachedPathsToTarget.put(targetClass, staticPathsToMethod);
        }
        if (staticPathsToClass != null && !staticPathsToClass.containsKey(targetMethod)) {
            staticPathsToClass.put(targetMethod, newPathsToTarget);
        }
    }

    private static Set<StaticPath> findStaticPathsToNode(CallGraph callGraph, CallGraphEntry newNode, StaticPath activePath) {
        //String tabs = activePath != null ? new String(new char[activePath.length()]).replace("\0", "\t") + "\u21B3" : "";
        //GenerationLogger generationLogger = new GenerationLogger(Properties.GENERATION_LOG_FILE);
        //generationLogger.write(String.format("%s%s, %s", tabs, newNode, activePath));

        if (activePath != null && activePath.contains(newNode)) {
            //generationLogger.write(String.format("%s\tAlready present in active path", tabs));
            return new LinkedHashSet<>();
        }
        Set<StaticPath> pathsFound = new LinkedHashSet<>();
        Set<CallGraphEntry> incomingNodes = callGraph.getCallsFromMethod(newNode);
        if (incomingNodes.isEmpty()) {
            StaticPath newActivePath = activePath != null ? activePath.clone() : new StaticPath();
            newActivePath.add(0, newNode);
            pathsFound.add(newActivePath);
        } else {
            for (CallGraphEntry incomingNode : incomingNodes) {
                StaticPath newActivePath = activePath != null ? activePath.clone() : new StaticPath();
                newActivePath.add(0, newNode);
                pathsFound.addAll(findStaticPathsToNode(callGraph, incomingNode, newActivePath));
            }
        }
        return pathsFound;
    }

    public void clear() {
        cachedPathsToTarget.clear();
    }
}
