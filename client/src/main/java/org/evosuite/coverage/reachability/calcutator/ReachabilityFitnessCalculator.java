package org.evosuite.coverage.reachability.calcutator;

import org.evosuite.Properties;
import org.evosuite.TestGenerationContext;
import org.evosuite.coverage.branch.Branch;
import org.evosuite.coverage.branch.BranchPool;
import org.evosuite.coverage.reachability.ReachabilityCoverageGoal;
import org.evosuite.ga.FitnessFunction;
import org.evosuite.graphs.cfg.ControlDependency;
import org.evosuite.setup.CallContext;
import org.evosuite.setup.callgraph.CallGraphEntry;
import org.evosuite.testcase.TestChromosome;
import org.evosuite.testcase.execution.ExecutionResult;
import org.evosuite.utils.GenerationLogger;
import org.evosuite.utils.GenerationLoggerHelper;

import java.io.Serializable;
import java.text.DecimalFormat;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

public class ReachabilityFitnessCalculator implements Serializable {
    private static final GenerationLogger GENERATION_LOGGER = new GenerationLogger(Properties.GENERATION_LOG_FILE);

    public static double calculate(ReachabilityCoverageGoal coverageGoal, TestChromosome individual, ExecutionResult result) {
        GENERATION_LOGGER.write(String.format("\n* Evaluating TestCase n.%s (From n.%s, Age=%s, Eval=%s)",
                individual.getTestCase().getID(), individual.getTestCase().getOriginatingID(), individual.getAge(), individual.getNumberOfEvaluations()));
        GENERATION_LOGGER.write(String.format("Code (%s statements):", individual.size()));
        GENERATION_LOGGER.write(GenerationLoggerHelper.testCaseToString(individual.getTestCase(), Properties.CHROMOSOME_LENGTH));
        //individual.getTestCase().iterator().forEachRemaining(st -> generationLogger.write("\t{};", st.getCode()));
        //generationLogger.write("Executed {} methods:\n-> {}\n", result.getTrace().getCoveredMethods().size(), String.join("\n-> ", result.getTrace().getCoveredMethods()));
        // Compute all similarities, get the best and compute the fitness
        List<CallContext> executedContexts = result.getTrace().getMethodContextCount().entrySet()
                .stream()
                .flatMap(entry -> entry.getValue().keySet().stream())
                .collect(Collectors.toList());
        // TODO Should I drop the contexts fully "included" into others?
        if (executedContexts.size() == 0) {
            GENERATION_LOGGER.write("The test did not execute anything :(");
            return Double.MAX_VALUE;
        }
        List<ContextSimilarity> similarities = executedContexts.stream()
                .map(ctx -> new ContextSimilarity(ctx.getContext(), coverageGoal.getCalls()))
                .sorted(Comparator.comparing(c -> -c.getScore()))
                .collect(Collectors.toList());
        ContextSimilarity bestSimilarity = similarities.get(0);
        double bestContextSim = bestSimilarity.getScore();

        Integer exceptionPoint = result.getFirstPositionOfThrownException();
        if (exceptionPoint != null) {
            if (exceptionPoint < individual.size()) {
                GENERATION_LOGGER.write(String.format("The test raised an exception at statement #%s (%s)", exceptionPoint, individual.getTestCase().getStatement(exceptionPoint).getCode()));
            } else if (result.hasTimeout()) {
                GENERATION_LOGGER.write("The test took long to execute!");
            }
        } else {
            GENERATION_LOGGER.write("The test did not raise any exception");
        }
        GENERATION_LOGGER.write(String.format("The test executed %s distinct methods for %s contexts. Similarities for [Goal #%s]:", result.getTrace().getCoveredMethods().size(), executedContexts.size(), coverageGoal.getId()));
        GENERATION_LOGGER.write(GenerationLoggerHelper.contextSimilaritiesToString(similarities, new DecimalFormat("0.000"), 8));
        GENERATION_LOGGER.write(String.format("Best Context Similarity: %s", new DecimalFormat("0.000").format(bestContextSim)));

        if (bestContextSim == 0.0) {
            return Double.MAX_VALUE;
        }
        if (bestContextSim == 1.0) {
            return 0.0;
        }
        if (!Properties.REACHABILITY_BRANCH_AWARENESS) {
            return 1.0 - bestContextSim;
        }
        BranchPool branchPool = BranchPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT());
        Map<String, Set<Branch>> coveredFalseBranches = transformBranchMap(result.getTrace().getCoveredFalseBranches().stream().collect(Collectors.toMap(Function.identity(), branchPool::getBranch)));
        Map<String, Set<Branch>> coveredTrueBranches = transformBranchMap(result.getTrace().getCoveredTrueBranches().stream().collect(Collectors.toMap(Function.identity(), branchPool::getBranch)));
        GENERATION_LOGGER.write("Branches evaluated False:");
        if (coveredFalseBranches.entrySet().isEmpty()) {
            GENERATION_LOGGER.write("\tNone");
        } else {
            for (Map.Entry<String, Set<Branch>> e : coveredFalseBranches.entrySet()) {
                GENERATION_LOGGER.write(String.format("\t%s %s", e.getKey(), e.getValue()));
            }
        }
        GENERATION_LOGGER.write("Branches evaluated True:");
        if (coveredTrueBranches.entrySet().isEmpty()) {
            GENERATION_LOGGER.write("\tNone");
        } else {
            for (Map.Entry<String, Set<Branch>> e : coveredTrueBranches.entrySet()) {
                GENERATION_LOGGER.write(String.format("\t%s %s", e.getKey(), e.getValue()));
            }
        }

        CallGraphEntry lastExecutedNode = bestSimilarity.getLastMappedNode();
        if (lastExecutedNode == null) {
            return 1.0 - bestContextSim;
        }
        GENERATION_LOGGER.write(String.format("Last executed node: %s", lastExecutedNode));
        List<ControlDependency> targetControlDependencies = coverageGoal.getControlDependencies(lastExecutedNode);
        GENERATION_LOGGER.write(String.format("\tControl dependencies: %s", targetControlDependencies));
        int approachLevel = DistanceCalculator.calculateApproachLevel(result, targetControlDependencies, lastExecutedNode.getClassName(), lastExecutedNode.getMethodName());
        GENERATION_LOGGER.write(String.format("\tApproach Level: %s", approachLevel));
        if (approachLevel > 0) {
            return 1.0 - bestContextSim + FitnessFunction.normalize(approachLevel);
        }
        double branchDistance = DistanceCalculator.calculateBranchDistanceOnDivergencePoint(result, targetControlDependencies, lastExecutedNode.getClassName(), lastExecutedNode.getMethodName());
        GENERATION_LOGGER.write(String.format("\tBranch distance: %s", branchDistance));
        return 1.0 - bestContextSim + FitnessFunction.normalize(approachLevel + FitnessFunction.normalize(branchDistance));
    }

    private static Map<String, Set<Branch>> transformBranchMap(Map<Integer, Branch> inputMap) {
        Map<String, Set<Branch>> outputMap = new HashMap<>();
        for (Map.Entry<Integer, Branch> e : inputMap.entrySet()) {
            String newKey = String.format("%s:%s", e.getValue().getClassName(), e.getValue().getMethodName());
            Set<Branch> val = outputMap.get(newKey);
            if (val == null) {
                outputMap.put(newKey, new LinkedHashSet<>());
                val = outputMap.get(newKey);
            }
            val.add(e.getValue());
        }
        return outputMap;
    }
}
