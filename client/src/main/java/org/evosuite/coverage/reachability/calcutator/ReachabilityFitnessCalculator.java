package org.evosuite.coverage.reachability.calcutator;

import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.evosuite.Properties;
import org.evosuite.TestGenerationContext;
import org.evosuite.coverage.branch.Branch;
import org.evosuite.coverage.branch.BranchPool;
import org.evosuite.coverage.reachability.GenerationLogger;
import org.evosuite.coverage.reachability.ReachabilityCoverageGoal;
import org.evosuite.ga.FitnessFunction;
import org.evosuite.graphs.cfg.ControlDependency;
import org.evosuite.setup.CallContext;
import org.evosuite.setup.callgraph.CallGraphEntry;
import org.evosuite.testcase.TestChromosome;
import org.evosuite.testcase.execution.ExecutionResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.Serializable;
import java.text.DecimalFormat;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

public class ReachabilityFitnessCalculator implements Serializable {
    protected static final Logger logger = LoggerFactory.getLogger(ReachabilityFitnessCalculator.class);

    public static double calculate(ReachabilityCoverageGoal coverageGoal, TestChromosome individual, ExecutionResult result) {
        GenerationLogger generationLogger = new GenerationLogger(Properties.SIEGE_LOG_FILE);
        generationLogger.write(String.format("\n* TestCase n.%s (From gen. #%s, Eval. #%s)",
                individual.getTestCase().getID(), individual.getAge(), individual.getNumberOfEvaluations()));
        List<String> individualStatements = Arrays.asList(individual.getTestCase().toCode().split("\n"));
        generationLogger.write(String.format("Code (%s statements):\n\t> %s", individualStatements.size(), String.join("\n\t> ", getCompressedFormat(individualStatements, 4))));

        //individual.getTestCase().iterator().forEachRemaining(st -> generationLogger.write("\t{};", st.getCode()));
        //generationLogger.write("Executed {} methods:\n-> {}\n", result.getTrace().getCoveredMethods().size(), String.join("\n-> ", result.getTrace().getCoveredMethods()));
        // Compute all similarities, get the best and compute the fitness
        List<CallContext> executedContexts = result.getTrace().getMethodContextCount().entrySet()
                .stream()
                .flatMap(entry -> entry.getValue().keySet().stream())
                .collect(Collectors.toList());
        if (executedContexts.size() == 0) {
            generationLogger.write("The test did not execute anything :(");
            return Double.MAX_VALUE;
        }
        List<Pair<Double, CallContext>> similarities = executedContexts.stream()
                .map(ctx -> new ImmutablePair<>(ContextSimilarityCalculator.calculate(ctx.getContext(), coverageGoal.getCalls()), ctx))
                .sorted(Comparator.comparing(p -> -p.getLeft()))
                .collect(Collectors.toList());
        Pair<Double, CallContext> bestContext = similarities.get(0);
        double bestContextSim = bestContext.getLeft();
        DecimalFormat decimalFormat = new DecimalFormat("0.000");
        List<String> similarityLines = new ArrayList<>();
        for (Pair<Double, CallContext> sim : similarities) {
            similarityLines.add(String.format("[%s] %s", decimalFormat.format(sim.getLeft()),
                    sim.getRight().getContext().stream().map(Object::toString).collect(Collectors.joining(" -> "))));
        }
        generationLogger.write(String.format("The test executed %s distinct methods for %s contexts. Similarities for [Goal #%s]:", result.getTrace().getCoveredMethods().size(), executedContexts.size(), coverageGoal.getId()));
        getCompressedFormat(similarityLines, 6).stream().map(s -> String.format("\t%s", s)).forEach(generationLogger::write);
        generationLogger.write(String.format("Best Context Similarity: %s", decimalFormat.format(bestContextSim)));

        if (bestContextSim == 0.0) {
            return Double.MAX_VALUE;
        }
        if (bestContextSim == 1.0) {
            return 0.0;
        }
        if (!Properties.BRANCH_AWARENESS) {
            return 1.0 - bestContextSim;
        }
        BranchPool branchPool = BranchPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT());
        Map<String, Set<Branch>> coveredFalseBranches = transformBranchMap(result.getTrace().getCoveredFalseBranches().stream().collect(Collectors.toMap(Function.identity(), branchPool::getBranch)));
        Map<String, Set<Branch>> coveredTrueBranches = transformBranchMap(result.getTrace().getCoveredTrueBranches().stream().collect(Collectors.toMap(Function.identity(), branchPool::getBranch)));
        generationLogger.write("Branches evaluated False:");
        for (Map.Entry<String, Set<Branch>> e : coveredFalseBranches.entrySet()) {
            generationLogger.write(String.format("\t%s %s", e.getKey(), e.getValue()));
        }
        generationLogger.write("Branches evaluated True:");
        for (Map.Entry<String, Set<Branch>> e : coveredTrueBranches.entrySet()) {
            generationLogger.write(String.format("\t%s %s", e.getKey(), e.getValue()));
        }

        CallGraphEntry lastExecutedCall = ContextSimilarityCalculator.getLastExecutedCall(bestContext.getRight().getContext(), coverageGoal.getCalls());
        generationLogger.write(String.format("Last executed call: %s", lastExecutedCall));
        if (lastExecutedCall == null) {
            return Double.MAX_VALUE;
        }
        List<ControlDependency> targetControlDependencies = coverageGoal.getControlDependencies(lastExecutedCall);
        generationLogger.write(String.format("\tControl dependencies: %s", targetControlDependencies));
        int approachLevel = DistanceCalculator.calculateApproachLevel(result, targetControlDependencies, lastExecutedCall.getClassName(), lastExecutedCall.getMethodName());
        generationLogger.write(String.format("\tApproach Level: %s", approachLevel));
        if (approachLevel > 0) {
            return 1.0 - bestContextSim + FitnessFunction.normalize(approachLevel);
        }
        double branchDistance = DistanceCalculator.calculateBranchDistanceOnDivergencePoint(result, targetControlDependencies, lastExecutedCall.getClassName(), lastExecutedCall.getMethodName());
        generationLogger.write(String.format("\tBranch distance: %s", branchDistance));
        return 1.0 - bestContextSim + FitnessFunction.normalize(approachLevel + FitnessFunction.normalize(branchDistance));
    }

    private static Map<String, Set<Branch>> transformBranchMap(Map<Integer, Branch> inputMap) {
        Map<String, Set<Branch>> outputMap = new HashMap<>();
        for (Map.Entry<Integer, Branch> e : inputMap.entrySet()) {
            String newKey = String.format("%s:%s", e.getValue().getClassName(), e.getValue().getMethodName());
            Set<Branch> val = outputMap.get(newKey);
            if (val == null) {
                outputMap.put(newKey, new LinkedHashSet<>());
                val = outputMap.get(newKey);
            }
            val.add(e.getValue());
        }
        return outputMap;
    }

    private static List<String> getCompressedFormat(List<String> allLines, int threshold) {
        List<String> linesToPrint = new ArrayList<>();
        if (allLines.size() > threshold) {
            List<String> firstStatements = allLines.subList(0, threshold - 2);
            List<String> lastStatements = allLines.subList(allLines.size() - 1, allLines.size());
            linesToPrint.addAll(firstStatements);
            linesToPrint.add("...");
            linesToPrint.addAll(lastStatements);
        } else {
            linesToPrint.addAll(allLines);
        }
        return linesToPrint;
    }
}
