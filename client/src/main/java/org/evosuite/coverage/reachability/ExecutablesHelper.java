package org.evosuite.coverage.reachability;

import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.evosuite.Properties;
import org.evosuite.ga.ConstructionFailedException;
import org.evosuite.setup.TestCluster;
import org.evosuite.testcase.TestCase;
import org.evosuite.testcase.TestFactory;
import org.evosuite.testcase.statements.ConstructorStatement;
import org.evosuite.testcase.statements.MethodStatement;
import org.evosuite.testcase.statements.Statement;
import org.evosuite.utils.GenerationLogger;
import org.evosuite.utils.Randomness;
import org.evosuite.utils.generic.GenericConstructor;
import org.evosuite.utils.generic.GenericExecutable;
import org.evosuite.utils.generic.GenericMethod;

import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class ExecutablesHelper {
    private static final GenerationLogger GENERATION_LOGGER = new GenerationLogger(Properties.GENERATION_LOG_FILE);

    /**
     * Returns the list of methods (as GenericExecutable) that can be called from test cases, i.e., protected and public ones
     *
     * @return A list of GenericExecutable callable from test cases
     */
    public static List<? extends GenericExecutable<?, ?>> getPossibleExecutables() {
        return TestCluster.getInstance()
                .getTestCalls()
                .stream()
                .filter(c -> c.isMethod() || c.isConstructor())
                .map(c -> (GenericExecutable<?, ?>) c)
                .collect(Collectors.toList());
    }

    public static Collection<? extends GenericExecutable<?, ?>> getExecutablesInTest(TestCase test) {
        List<? extends GenericExecutable<?, ?>> executablesToSearch = getPossibleExecutables();
        Set<GenericExecutable<?, ?>> executablesFound = new LinkedHashSet<>();
        for (Statement statement : test.getStatements()) {
            String stNameWithDescriptor = getStatementNameWithDescriptor(statement);
            if (stNameWithDescriptor == null) {
                continue;
            }
            executablesToSearch.stream()
                    .filter(ex -> stNameWithDescriptor.equals(ex.getNameWithDescriptor()))
                    .findFirst()
                    .ifPresent(executablesFound::add);
        }
        return executablesFound;
    }

    /**
     * Select the list of methods (as GenericExecutable) whose names (with descriptors) match with those in wantedMethods.
     *
     * @param executables   List of GenericExecutable to filter
     * @param wantedMethods Method names with descriptors to select
     * @return The filtered list of GenericExecutable
     */
    public static Collection<? extends GenericExecutable<?, ?>> selectExecutables(Collection<? extends GenericExecutable<?, ?>> executables, Set<String> wantedMethods) {
        return executables.stream()
                .filter(c -> wantedMethods.contains(c.getNameWithDescriptor()))
                .collect(Collectors.toList());
    }

    public static boolean tryToAddAnExecutableIntoTest(Collection<? extends GenericExecutable<?, ?>> executablesToSample, TestCase test, int maxAttempts, boolean tryToReplace) {
        for (int attempts = 0; attempts < maxAttempts; attempts++) {
            List<Statement> statements = test.getStatements();
            List<Pair<Integer, ? extends GenericExecutable<?, ?>>> statementsWithExecutable = executablesToSample.stream()
                    .map(m -> new ImmutablePair<>(findStatementIndexWithExecutable(statements, m), m))
                    .filter(m -> m.getLeft() > -1)
                    .collect(Collectors.toList());
            if (!statementsWithExecutable.isEmpty()) {
                GENERATION_LOGGER.write("\tThe test contains one desired executable!");
                return true;
            }
            GenericExecutable<?, ?> executableToSeed = Randomness.choice(executablesToSample);
            if (executableToSeed == null) {
                continue;
            }
            // Randomly select one desired executable and add it at the end
            TestFactory testFactory = TestFactory.getInstance();
            if (tryToReplace) {
                GENERATION_LOGGER.write(String.format("\tSetting %s at the end", executableToSeed.getNameWithDescriptor()));
                if (setExecutableAtPosition(testFactory, test, executableToSeed, test.size() - 1, 0)) {
                    GENERATION_LOGGER.write("\t\t[SUCCESS]");
                    return true;
                } else {
                    GENERATION_LOGGER.write("\t\t[FAILED]");
                    return false;
                }
            }
            GENERATION_LOGGER.write(String.format("\tAdding %s at the end", executableToSeed.getNameWithDescriptor()));
            if (addExecutableAtPosition(testFactory, test, executableToSeed, test.size(), 0)) {
                GENERATION_LOGGER.write("\t\t[SUCCESS]");
                return true;
            } else {
                GENERATION_LOGGER.write("\t\t[FAILED]");
                return false;
            }
        }
        return false;
    }

    private static int findStatementIndexWithExecutable(List<Statement> statements, GenericExecutable<?, ?> executable) {
        for (int i = 0; i < statements.size(); i++) {
            Statement statement = statements.get(i);
            String stNameWithDescriptor = getStatementNameWithDescriptor(statement);
            if (stNameWithDescriptor == null) {
                continue;
            }
            if (stNameWithDescriptor.equals(executable.getNameWithDescriptor())) {
                return i;
            }
        }
        return -1;
    }

    private static String getStatementNameWithDescriptor(Statement statement) {
        if (statement instanceof ConstructorStatement) {
            return ((ConstructorStatement) statement).getConstructor().getNameWithDescriptor();
        } else if (statement instanceof MethodStatement) {
            return ((MethodStatement) statement).getMethod().getNameWithDescriptor();
        }
        return null;
    }

    private static boolean addExecutableAtPosition(TestFactory testFactory, TestCase test, GenericExecutable<?, ?> executable, int position, int recursionDepth) {
        try {
            if (executable.isMethod()) {
                testFactory.addMethod(test, (GenericMethod) executable, position, recursionDepth);
            } else if (executable.isConstructor()) {
                testFactory.addConstructor(test, (GenericConstructor) executable, position, recursionDepth);
            }
            return true;
        } catch (ConstructionFailedException ignored) {
            return false;
        }
    }

    private static boolean setExecutableAtPosition(TestFactory testFactory, TestCase test, GenericExecutable<?, ?> executable, int position, int recursionDepth) {
        try {
            if (!testFactory.deleteStatementGracefully(test, position)) {
                return false;
            }
            return addExecutableAtPosition(testFactory, test, executable, Math.min(position, test.size()), recursionDepth);
        } catch (ConstructionFailedException ignored) {
            return false;
        }
    }
}
