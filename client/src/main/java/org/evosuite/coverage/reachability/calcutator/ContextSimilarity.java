package org.evosuite.coverage.reachability.calcutator;

import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.evosuite.setup.Call;
import org.evosuite.setup.callgraph.CallGraphEntry;

import java.util.*;

public class ContextSimilarity {
    private static final double RIGHT_METHOD_WEIGHT = 1.0;
    private static final double RIGHT_NEXT_CLASS_WEIGHT = 0.5;
    private static final double PRELIMINARY_PENALTY_WEIGHT = 0.1;
    private static final double DIVERGENCE_PENALTY_WEIGHT = 0.25;
    private final List<Call> executedCalls;
    private final List<CallGraphEntry> targetNodes;
    private List<Call> preliminaryCalls;
    private Map<CallGraphEntry, Call> mappedCalls;
    private List<CallGraphEntry> missedNodes;
    private List<Call> divergentCalls;
    private Double cachedScore;

    public ContextSimilarity(List<Call> executedCalls, List<CallGraphEntry> targetNodes) {
        this.executedCalls = executedCalls;
        this.targetNodes = targetNodes;
        initStructures();
    }

    public double getScore() {
        // If there is at least one missed node, check if the first divergent call (if any) has the same class of the first missed node
        if (cachedScore != null) {
            return cachedScore;
        }
        double matchScore;
        double onePoint = (double) 1 / targetNodes.size();
        double rightNextClassScore = 0.0;
        double preliminaryCallsPenalty = 0.0;
        double divergentCallsPenalty = 0.0;

        // TODO If all nodes are missed, we can look into the test code: if the first expected call is there, we can ADD another slight bonus -> firstCallInTestCodeScore
        // Match Score
        matchScore = RIGHT_METHOD_WEIGHT * onePoint * mappedCalls.size();
        // Right next class bonus (if any)
        if (!missedNodes.isEmpty() && !divergentCalls.isEmpty() && divergentCalls.get(0).getClassName().equals(missedNodes.get(0).getClassName())) {
            rightNextClassScore = RIGHT_NEXT_CLASS_WEIGHT * onePoint;
        }
        // Preliminary penalty (if any)
        if (!mappedCalls.isEmpty() && !preliminaryCalls.isEmpty()) {
            preliminaryCallsPenalty = PRELIMINARY_PENALTY_WEIGHT * onePoint * preliminaryCalls.size() / executedCalls.size();
        }
        // Divergent penalty (if any)
        if (!mappedCalls.isEmpty() && !divergentCalls.isEmpty()) {
            divergentCallsPenalty = DIVERGENCE_PENALTY_WEIGHT * onePoint * divergentCalls.size() / executedCalls.size();
        }
        cachedScore = matchScore + rightNextClassScore - preliminaryCallsPenalty - divergentCallsPenalty;
        return cachedScore;
    }

    public Pair<CallGraphEntry, Call> getLastMapping() {
        Pair<CallGraphEntry, Call> pair = new ImmutablePair<>(null, null);
        for (Map.Entry<CallGraphEntry, Call> entry : mappedCalls.entrySet()) {
            pair = new ImmutablePair<>(entry.getKey(), entry.getValue());
        }
        return pair;
    }

    public CallGraphEntry getLastMappedNode() {
        return getLastMapping().getLeft();
    }

    public Call getLastMappedCall() {
        return getLastMapping().getRight();
    }

    public List<Call> getExecutedCalls() {
        return Collections.unmodifiableList(executedCalls);
    }

    public List<CallGraphEntry> getTargetNodes() {
        return Collections.unmodifiableList(targetNodes);
    }

    private void initStructures() {
        preliminaryCalls = new ArrayList<>();
        mappedCalls = new LinkedHashMap<>();
        missedNodes = new ArrayList<>();
        divergentCalls = new ArrayList<>();
        for (Call call : executedCalls) {
            if (equalsCallAndNode(call, targetNodes.get(0))) {
                break;
            }
            preliminaryCalls.add(call);
        }
        // If the first target node was never executed, the preliminary calls are actually divergent calls
        if (preliminaryCalls.size() == executedCalls.size()) {
            divergentCalls.addAll(preliminaryCalls);
            preliminaryCalls.clear();
        } else {
            for (int i = 0; i < Math.min(executedCalls.size(), targetNodes.size()); i++) {
                Call call = executedCalls.get(i + preliminaryCalls.size());
                CallGraphEntry callGraphEntry = targetNodes.get(i);
                if (!equalsCallAndNode(call, callGraphEntry)) {
                    break;
                }
                mappedCalls.put(callGraphEntry, call);
            }
            if (preliminaryCalls.size() + mappedCalls.size() < executedCalls.size()) {
                divergentCalls.addAll(executedCalls.subList(preliminaryCalls.size() + mappedCalls.size(), executedCalls.size()));
            }
        }
        if (mappedCalls.size() < targetNodes.size()) {
            missedNodes.addAll(targetNodes.subList(mappedCalls.size(), targetNodes.size()));
        }
    }

    private boolean equalsCallAndNode(Call executedCall, CallGraphEntry targetNode) {
        return executedCall.getMethodName().equals(targetNode.getMethodName()) &&
                executedCall.getClassName().equals(targetNode.getClassName());
    }

}
