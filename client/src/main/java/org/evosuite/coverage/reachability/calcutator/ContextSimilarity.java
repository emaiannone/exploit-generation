package org.evosuite.coverage.reachability.calcutator;

import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.evosuite.setup.Call;
import org.evosuite.setup.callgraph.CallGraphEntry;

import java.util.*;

public class ContextSimilarity {
    private static final double RIGHT_METHOD_WEIGHT = 1.0;
    private static final double RIGHT_NEXT_CLASS_WEIGHT = 0.5;
    private static final double PRELIMINARY_PENALTY_WEIGHT = 0.1;
    private static final double DIVERGENCE_PENALTY_WEIGHT = 0.25;
    private final List<Call> executedCalls;
    private final List<CallGraphEntry> targetNodes;
    private List<Call> preliminaryCalls;
    private Map<CallGraphEntry, Call> mappedCalls;
    private List<CallGraphEntry> missedNodes;
    private List<Call> divergentCalls;
    private Double cachedScore;

    public ContextSimilarity(List<Call> executedCalls, List<CallGraphEntry> targetNodes) {
        this.executedCalls = executedCalls;
        this.targetNodes = targetNodes;
        initStructures();
    }

    public double getScore() {
        // If there is at least one missed node, check if the first divergent call (if any) has the same class of the first missed node
        if (cachedScore != null) {
            return cachedScore;
        }
        double matchScore;
        double onePoint = (double) 1 / targetNodes.size();
        double rightNextClassScore = 0.0;
        double preliminaryCallsPenalty = 0.0;
        double divergentCallsPenalty = 0.0;

        // TODO If all nodes are missed, we can look into the test code: if the first expected call is there, we can ADD another slight bonus -> firstCallInTestCodeScore
        // Match Score
        matchScore = RIGHT_METHOD_WEIGHT * onePoint * mappedCalls.size();
        // Right next class bonus (if any)
        if (!missedNodes.isEmpty() && !divergentCalls.isEmpty() && divergentCalls.get(0).getClassName().equals(missedNodes.get(0).getClassName())) {
            rightNextClassScore = RIGHT_NEXT_CLASS_WEIGHT * onePoint;
        }
        // Preliminary penalty (if any)
        if (!mappedCalls.isEmpty() && !preliminaryCalls.isEmpty()) {
            preliminaryCallsPenalty = PRELIMINARY_PENALTY_WEIGHT * onePoint * preliminaryCalls.size() / executedCalls.size();
        }
        // Divergent penalty (if any)
        if (!mappedCalls.isEmpty() && !divergentCalls.isEmpty()) {
            divergentCallsPenalty = DIVERGENCE_PENALTY_WEIGHT * onePoint * divergentCalls.size() / executedCalls.size();
        }
        cachedScore = matchScore + rightNextClassScore - preliminaryCallsPenalty - divergentCallsPenalty;
        return cachedScore;
    }

    public Pair<CallGraphEntry, Call> getLastMapping() {
        Pair<CallGraphEntry, Call> pair = new ImmutablePair<>(null, null);
        for (Map.Entry<CallGraphEntry, Call> entry : mappedCalls.entrySet()) {
            pair = new ImmutablePair<>(entry.getKey(), entry.getValue());
        }
        return pair;
    }

    public CallGraphEntry getLastMappedNode() {
        return getLastMapping().getLeft();
    }

    public Call getLastMappedCall() {
        return getLastMapping().getRight();
    }

    public List<Call> getExecutedCalls() {
        return Collections.unmodifiableList(executedCalls);
    }

    public List<CallGraphEntry> getTargetNodes() {
        return Collections.unmodifiableList(targetNodes);
    }

    private void initStructures() {
        preliminaryCalls = new ArrayList<>();
        mappedCalls = new LinkedHashMap<>();
        missedNodes = new ArrayList<>();
        divergentCalls = new ArrayList<>();

        if (executedCalls.isEmpty() && targetNodes.isEmpty()) {
            return;
        }
        if (executedCalls.isEmpty()) {
            missedNodes.addAll(targetNodes);
            return;
        }
        if (targetNodes.isEmpty()) {
            divergentCalls.addAll(executedCalls);
            return;
        }

        int i;
        for (i = 0; i < executedCalls.size(); i++) {
            Call executedCall = executedCalls.get(i);
            if (!equalsCallAndNode(executedCall, targetNodes.get(0))) {
                break;
            }
            preliminaryCalls.add(executedCall);
        }
        // If the first target node was never executed, the preliminary calls are actually divergent calls
        if (i >= executedCalls.size()) {
            divergentCalls.addAll(preliminaryCalls);
            preliminaryCalls.clear();
            missedNodes.addAll(targetNodes);
            return;
        }
        // Mapping time
        int j;
        for (j = 0; j < targetNodes.size(); j++) {
            if (i + j >= executedCalls.size()) {
                break;
            }
            Call executedCall = executedCalls.get(i + j);
            CallGraphEntry targetNode = targetNodes.get(j);
            if (!equalsCallAndNode(executedCall, targetNode)) {
                break;
            }
            mappedCalls.put(targetNode, executedCall);
        }
        // Depending on which structure terminated first, we will the other structures
        if (j < targetNodes.size()) {
            missedNodes.addAll(targetNodes.subList(j, targetNodes.size()));
        }
        if (i + j < executedCalls.size()) {
            divergentCalls.addAll(executedCalls.subList(i + j, executedCalls.size()));
        }
    }

    private boolean equalsCallAndNode(Call executedCall, CallGraphEntry targetNode) {
        return executedCall.getMethodName().equals(targetNode.getMethodName()) &&
                executedCall.getClassName().equals(targetNode.getClassName());
    }

}
