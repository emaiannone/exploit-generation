package org.evosuite.coverage.reachability;

import org.evosuite.Properties;
import org.evosuite.TestGenerationContext;
import org.evosuite.coverage.reachability.exceptions.UncalledTarget;
import org.evosuite.coverage.reachability.exceptions.UnreachableTarget;
import org.evosuite.graphs.cfg.ASMWrapper;
import org.evosuite.graphs.cfg.BytecodeInstruction;
import org.evosuite.graphs.cfg.BytecodeInstructionPool;
import org.evosuite.graphs.cfg.ControlDependency;
import org.evosuite.rmi.ClientServices;
import org.evosuite.seeding.ConstantPoolManager;
import org.evosuite.seeding.StaticConstantPool;
import org.evosuite.setup.DependencyAnalysis;
import org.evosuite.setup.callgraph.CallGraphEntry;
import org.evosuite.statistics.RuntimeVariable;
import org.evosuite.utils.GenerationLogger;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static org.evosuite.coverage.reachability.ReachabilityCoverageGoal.CallUnit;

public class ReachabilityCoverageGoalsPreparer {
    private static final GenerationLogger GENERATION_LOGGER = new GenerationLogger(Properties.GENERATION_LOG_FILE);

    public static List<ReachabilityCoverageGoal> prepare(String targetClass, String targetMethod) throws UnreachableTarget {
        String clientClass = Properties.TARGET_CLASS;
        GENERATION_LOGGER.write("Creating test goals...");
        GENERATION_LOGGER.write(String.format("\t[TARGET] %s:%s", targetClass, targetMethod));
        GENERATION_LOGGER.write(String.format("\t[CLIENT] %s", clientClass));
        //generationLogger.write("Public methods: " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCCFG(reachabilityTarget.getTargetClass()).publicMethods);
        //generationLogger.write("CDG? " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCDG(reachabilityTarget.getTargetClass(), reachabilityTarget.getTargetMethod()));

        Set<StaticPath> staticPaths = StaticPathsPool.getPathsToTarget(targetClass, targetMethod);
        // This will be needed by Siege during pre-analysis
        ClientServices.getInstance().getClientNode().trackOutputVariable(RuntimeVariable.StaticPaths, staticPaths);
        if (staticPaths.isEmpty()) {
            throw new UnreachableTarget("The target method cannot be reached from any client class. No goals can be created.");
        }

        // Logging time
        /*
        GENERATION_LOGGER.write(String.format("Static paths to target (%s):", staticPaths.size()));
        for (StaticPath path : staticPaths) {
            int idx = 0;
            for (CallGraphEntry node : path) {
                String tabs = idx > 0 ? new String(new char[idx]).replace("\0", "\t") + "\u21B3" : "";
                idx++;
                GENERATION_LOGGER.write(String.format("%s%s", tabs, node));
            }
        }
         */

        List<ReachabilityCoverageGoal> goals = createGoals(clientClass, staticPaths);
        if (goals.isEmpty()) {
            throw new UncalledTarget(String.format("The target is not called from %s.", clientClass));
        }
        GENERATION_LOGGER.write("Goals created:");
        for (ReachabilityCoverageGoal goal : goals) {
            GENERATION_LOGGER.write(String.format("\t[Goal #%s] %s", goal.getId(), goal.getCallUnits().stream().map(Object::toString).collect(Collectors.joining("\n\t\t"))));
        }

        // Store the constants found along the static paths in the coverage goal in MethodConstantPool and BranchConstantPool, to be used when generating the initial population generation or mutations
        ReachabilityMethodConstantPool.reset();
        ReachabilityBranchConstantPool.reset();
        for (ReachabilityCoverageGoal goal : goals) {
            for (CallUnit callUnit : goal.getCallUnits()) {
                CallGraphEntry call = callUnit.getMethod();
                StaticConstantPool methodPool = ConstantPoolManager.getInstance().getMethodConstantPool(call.getClassName(), call.getMethodName());
                if (methodPool != null) {
                    for (Object obj : methodPool.getObjects()) {
                        if (Properties.REACHABILITY_SEED_FROM_METHODS_IN_GOALS) {
                            ReachabilityMethodConstantPool.add(call.getClassName(), call.getMethodName(), obj);
                        }
                        if (Properties.REACHABILITY_SEED_FROM_BRANCHES_IN_GOALS) {
                            for (ControlDependency cd : callUnit.getControlDependencies()) {
                                Set<Object> values = cd.getBranch().getValues();
                                if (!values.isEmpty() && values.contains(obj)) {
                                    ReachabilityBranchConstantPool.add(cd.getBranch(), obj);
                                }
                            }
                        }
                    }
                }
            }
        }
        return goals;
    }

    private static List<ReachabilityCoverageGoal> createGoals(String clientClass, Set<StaticPath> staticPaths) {
        // Select paths containing the selected client class and make the goals from these only, ignoring the other paths
        //GENERATION_LOGGER.write(String.format("CALLED CLASSES: %s", staticPaths.stream().flatMap(a -> a.getCalledClasses().stream()).collect(Collectors.toSet())));
        List<StaticPath> pathsWithClient = staticPaths.stream()
                .filter(p -> p.getCalledClasses().contains(clientClass))
                .distinct()
                .collect(Collectors.toList());
        //pathsWithClient.stream().map(p -> String.format("\t%s", p)).forEach(GENERATION_LOGGER::write);
        List<StaticPath> croppedPaths = pathsWithClient.stream()
                .map(p -> p.removeBefore(p.getIndex(clientClass)))
                .distinct()
                .collect(Collectors.toList());
        GENERATION_LOGGER.write(String.format("%s paths could reach the target. %s paths remain after cropping the part before calling the client class.", pathsWithClient.size(), croppedPaths.size()));
        //croppedPaths.stream().map(p -> String.format("\t%s", p)).forEach(GENERATION_LOGGER::write);

        List<ReachabilityCoverageGoal> goals = new ArrayList<>();
        for (int i = 0; i < croppedPaths.size(); i++) {
            StaticPath path = croppedPaths.get(i);
            if (Properties.REACHABILITY_BRANCH_AWARENESS) {
                List<CallUnit> callUnits = new ArrayList<>();
                GENERATION_LOGGER.write(String.format("Path #%s:", i));
                for (int j = 0; j < path.length() - 1; j++) {
                    CallGraphEntry cgEntry = path.get(j);
                    BytecodeInstruction callInstruction = getCallInstruction(cgEntry, path.get(j + 1));
                    // If null, we cannot determine the CDs, so we set empty
                    Set<ControlDependency> controlDependencies;
                    // If some classes are found in the call graph but are not instrumented, we set the control dependencies needed to empty. This behavior might change in the future
                    if (callInstruction == null) {
                        GENERATION_LOGGER.write(String.format("\tCALL NOT FOUND: from %s to %s.", cgEntry, path.get(j + 1)));
                        controlDependencies = new LinkedHashSet<>();
                    } else {
                        GENERATION_LOGGER.write(String.format("\t%s at %s:%s", callInstruction, callInstruction.getClassName(), callInstruction.getMethodName()));
                        controlDependencies = getControlDependencies(callInstruction);
                    }
                    GENERATION_LOGGER.write(String.format("\t\tBranches to reach it (Control Dependencies): %s", controlDependencies));
                    callUnits.add(new CallUnit(cgEntry, new ArrayList<>(controlDependencies)));
                }
                // Last element of path has no branches to be executed, as we just need method reachability
                callUnits.add(new CallUnit(path.get(path.length() - 1), new ArrayList<>()));
                goals.add(new ReachabilityCoverageGoal(i, callUnits));
            } else {
                goals.add(new ReachabilityCoverageGoal(i, path.stream().map(p -> new CallUnit(p, new ArrayList<>())).collect(Collectors.toList())));
            }
        }
        return goals;
    }

    private static BytecodeInstruction getCallInstruction(CallGraphEntry fromMethod, CallGraphEntry toMethod) {
        List<BytecodeInstruction> fromMethodInstructions = BytecodeInstructionPool
                .getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT())
                .getInstructionsIn(fromMethod.getClassName(), fromMethod.getMethodName());
        //GENERATION_LOGGER.write(String.format("\tCaller Instructions: %s", fromMethodInstructions));
        if (fromMethodInstructions == null || fromMethodInstructions.isEmpty()) {
            return null;
        }

        List<BytecodeInstruction> callInstructions = fromMethodInstructions.stream()
                .filter(ASMWrapper::isMethodCall)
                .collect(Collectors.toList());
        Set<String> targetSubclasses = DependencyAnalysis.getInheritanceTree().getSubclasses(toMethod.getClassName());
        return callInstructions
                .stream()
                .filter(mc -> mc.getCalledMethod().equals(toMethod.getMethodName()))
                .filter(mc -> targetSubclasses.contains(mc.getCalledMethodsClass()))
                .findFirst().orElse(null);
    }

    private static Set<ControlDependency> getControlDependencies(BytecodeInstruction instruction) {
        Set<ControlDependency> allDependencies = new LinkedHashSet<>();
        Set<ControlDependency> directDependencies = instruction.getControlDependencies();
        for (ControlDependency directDependency : directDependencies) {
            Set<ControlDependency> upperDependencies = getControlDependencies(directDependency.getBranch().getInstruction());
            allDependencies.addAll(upperDependencies);
        }
        allDependencies.addAll(directDependencies);
        return allDependencies;
    }
}
