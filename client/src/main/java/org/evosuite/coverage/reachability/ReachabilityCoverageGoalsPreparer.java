package org.evosuite.coverage.reachability;

import org.evosuite.Properties;
import org.evosuite.TestGenerationContext;
import org.evosuite.coverage.reachability.exceptions.UnreachableTarget;
import org.evosuite.graphs.cfg.ASMWrapper;
import org.evosuite.graphs.cfg.BytecodeInstruction;
import org.evosuite.graphs.cfg.BytecodeInstructionPool;
import org.evosuite.graphs.cfg.ControlDependency;
import org.evosuite.rmi.ClientServices;
import org.evosuite.setup.DependencyAnalysis;
import org.evosuite.setup.callgraph.CallGraphEntry;
import org.evosuite.statistics.RuntimeVariable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class ReachabilityCoverageGoalsPreparer {
    protected static final Logger logger = LoggerFactory.getLogger(ReachabilityCoverageGoalsPreparer.class);

    public static List<ReachabilityCoverageGoal> prepare(ReachabilityTarget reachabilityTarget) throws UnreachableTarget {
        GenerationLogger generationLogger = new GenerationLogger(Properties.SIEGE_LOG_FILE);
        generationLogger.write("Creating test goals...");
        generationLogger.write(String.format("\t[TARGET] %s:%s", reachabilityTarget.getTargetClass(), reachabilityTarget.getTargetMethod()));
        generationLogger.write(String.format("\t[CLIENT] %s", Properties.TARGET_CLASS));
        //generationLogger.write("Public methods: " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCCFG(reachabilityTarget.getTargetClass()).publicMethods);
        //generationLogger.write("CDG? " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCDG(reachabilityTarget.getTargetClass(), reachabilityTarget.getTargetMethod()));

        List<ReachabilityCoverageGoal> goals = createGoals(Properties.TARGET_CLASS, reachabilityTarget.getTargetClass(), reachabilityTarget.getTargetMethod());
        generationLogger.write("Goals created:");
        for (ReachabilityCoverageGoal goal : goals) {
            generationLogger.write(String.format("\t[Goal #%s] %s", goal.getId(), goal.getCallUnits().stream().map(Object::toString).collect(Collectors.joining("\n\t\t"))));
        }
        return goals;
    }

    private static List<ReachabilityCoverageGoal> createGoals(String clientClass, String targetClass, String targetMethod) {
        Set<StaticPath> staticPaths = StaticPathExplorer.staticPathsToTarget(targetClass, targetMethod);
        if (staticPaths == null) {
            throw new UnreachableTarget("The target method cannot be reached from the client class. No goals can be created.");
        }
        // This will be needed by Siege during pre-analysis
        ClientServices.getInstance().getClientNode().trackOutputVariable(RuntimeVariable.StaticPaths, staticPaths);

        GenerationLogger generationLogger = new GenerationLogger(Properties.SIEGE_LOG_FILE);
        generationLogger.write("Static paths from all client classes:");
        for (StaticPath path : staticPaths) {
            generationLogger.write(String.format("\t%s", path.stream().map(Object::toString).collect(Collectors.joining("\n\t\t"))));
        }
        // Select paths rooted in the selected client class only
        Set<StaticPath> relevantPaths = staticPaths.stream().filter(p -> p.getRootNodeName().equals(clientClass)).collect(Collectors.toSet());

        // Make the goals from these relevant paths
        List<ReachabilityCoverageGoal> goals = new ArrayList<>();
        int id = 0;
        for (StaticPath paths : relevantPaths) {
            if (Properties.BRANCH_AWARENESS) {
                List<CallUnit> callUnits = new ArrayList<>();
                generationLogger.write("Call instructions to reach the target:");
                for (int i = 0; i < paths.length() - 1; i++) {
                    CallGraphEntry cgEntry = paths.get(i);
                    BytecodeInstruction callInstruction = getCallInstruction(cgEntry, paths.get(i + 1));
                    generationLogger.write(String.format("\t%s at %s:%s", callInstruction, callInstruction.getClassName(), callInstruction.getMethodName()));
                    Set<ControlDependency> allControlDependencies = getAllControlDependencies(callInstruction);
                    generationLogger.write(String.format("\t\tBranches to reach it (Control Dependencies): %s", allControlDependencies));
                    callUnits.add(new CallUnit(cgEntry, new ArrayList<>(allControlDependencies)));
                }
                // Last element of path has no branches to be executed, as we just need method reachability
                callUnits.add(new CallUnit(paths.get(paths.length() - 1), new ArrayList<>()));
                goals.add(new ReachabilityCoverageGoal(id, callUnits));
            } else {
                goals.add(new ReachabilityCoverageGoal(id, paths.stream().map(p -> new CallUnit(p, new ArrayList<>())).collect(Collectors.toList())));
            }
            id++;
        }
        return goals;
    }

    private static Set<ControlDependency> getAllControlDependencies(BytecodeInstruction instruction) {
        Set<ControlDependency> allDependencies = new LinkedHashSet<>();
        Set<ControlDependency> directDependencies = instruction.getControlDependencies();
        for (ControlDependency directDependency : directDependencies) {
            Set<ControlDependency> upperDependencies = getAllControlDependencies(directDependency.getBranch().getInstruction());
            allDependencies.addAll(upperDependencies);
        }
        allDependencies.addAll(directDependencies);
        return allDependencies;
    }

    private static BytecodeInstruction getCallInstruction(CallGraphEntry fromMethod, CallGraphEntry toMethod) {
        List<BytecodeInstruction> callInstructions = BytecodeInstructionPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT())
                .getInstructionsIn(fromMethod.getClassName(), fromMethod.getMethodName())
                .stream()
                .filter(ASMWrapper::isMethodCall)
                .collect(Collectors.toList());
        Set<String> targetSubclasses = DependencyAnalysis.getInheritanceTree().getSubclasses(toMethod.getClassName());
        return callInstructions
                .stream()
                .filter(mc -> mc.getCalledMethod().equals(toMethod.getMethodName()))
                .filter(mc -> targetSubclasses.contains(mc.getCalledMethodsClass()))
                .findFirst().orElse(null);
    }
}
