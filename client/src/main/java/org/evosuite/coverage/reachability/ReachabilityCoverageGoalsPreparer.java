package org.evosuite.coverage.reachability;

import org.evosuite.Properties;
import org.evosuite.TestGenerationContext;
import org.evosuite.coverage.reachability.exceptions.UnreachableTarget;
import org.evosuite.graphs.cfg.ASMWrapper;
import org.evosuite.graphs.cfg.BytecodeInstruction;
import org.evosuite.graphs.cfg.BytecodeInstructionPool;
import org.evosuite.graphs.cfg.ControlDependency;
import org.evosuite.setup.DependencyAnalysis;
import org.evosuite.setup.callgraph.CallGraph;
import org.evosuite.setup.callgraph.CallGraphEntry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class ReachabilityCoverageGoalsPreparer {
    protected static final Logger logger = LoggerFactory.getLogger(ReachabilityCoverageGoalsPreparer.class);

    public static List<ReachabilityCoverageGoal> prepare(ReachabilityTarget reachabilityTarget) throws UnreachableTarget {
        GenerationLogger generationLogger = new GenerationLogger(Properties.SIEGE_LOG_FILE);
        generationLogger.write("Creating test goals...");
        generationLogger.write(String.format("\t[TARGET] %s:%s", reachabilityTarget.getTargetClass(), reachabilityTarget.getTargetMethod()));
        generationLogger.write(String.format("\t[CLIENT] %s", Properties.TARGET_CLASS));
        //generationLogger.write("Public methods: " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCCFG(reachabilityTarget.getTargetClass()).publicMethods);
        //generationLogger.write("CDG? " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCDG(reachabilityTarget.getTargetClass(), reachabilityTarget.getTargetMethod()));

        List<ReachabilityCoverageGoal> goals = createGoals(reachabilityTarget.getTargetClass(), reachabilityTarget.getTargetMethod());
        generationLogger.write("Goals created:");
        for (ReachabilityCoverageGoal goal : goals) {
            generationLogger.write(String.format("\t[Goal #%s] %s", goal.getId(), goal.getCallUnits().stream().map(Object::toString).collect(Collectors.joining("\n\t\t"))));
        }
        return goals;
    }

    private static List<ReachabilityCoverageGoal> createGoals(String targetClass, String targetMethod) {
        Set<List<CallGraphEntry>> staticPaths = staticPathsToTarget(targetClass, targetMethod);
        if (staticPaths == null) {
            throw new UnreachableTarget("The target method cannot be reached from the client class. No goals can be created.");
        }
        GenerationLogger generationLogger = new GenerationLogger(Properties.SIEGE_LOG_FILE);
        generationLogger.write("Static paths from all client classes:");
        for (List<CallGraphEntry> path : staticPaths) {
            generationLogger.write(String.format("\t%s", path.stream().map(Object::toString).collect(Collectors.joining("\n\t\t"))));
        }
        // Select paths rooted in the selected client class only
        Set<List<CallGraphEntry>> relevantPaths = staticPaths.stream().filter(p -> p.get(0).getClassName().equals(Properties.TARGET_CLASS)).collect(Collectors.toSet());

        // Make the goals from these relevant paths
        List<ReachabilityCoverageGoal> goals = new ArrayList<>();
        int id = 0;
        for (List<CallGraphEntry> paths : relevantPaths) {
            if (Properties.BRANCH_AWARENESS) {
                List<CallUnit> callUnits = new ArrayList<>();
                generationLogger.write("Call instructions to reach the target:");
                for (int i = 0; i < paths.size() - 1; i++) {
                    CallGraphEntry cgEntry = paths.get(i);
                    BytecodeInstruction callInstruction = getCallInstruction(cgEntry, paths.get(i + 1));
                    generationLogger.write(String.format("\t%s at %s:%s", callInstruction, callInstruction.getClassName(), callInstruction.getMethodName()));
                    Set<ControlDependency> allControlDependencies = getAllControlDependencies(callInstruction);
                    generationLogger.write(String.format("\t\tBranches to reach it (Control Dependencies): %s", allControlDependencies));
                    callUnits.add(new CallUnit(cgEntry, new ArrayList<>(allControlDependencies)));
                }
                // Last element of path has no branches to be executed, as we just need method reachability
                callUnits.add(new CallUnit(paths.get(paths.size() - 1), new ArrayList<>()));
                goals.add(new ReachabilityCoverageGoal(id, callUnits));
            } else {
                goals.add(new ReachabilityCoverageGoal(id, paths.stream().map(p -> new CallUnit(p, new ArrayList<>())).collect(Collectors.toList())));
            }
            id++;
        }
        return goals;
    }

    private static Set<ControlDependency> getAllControlDependencies(BytecodeInstruction instruction) {
        Set<ControlDependency> allDependencies = new LinkedHashSet<>();
        Set<ControlDependency> directDependencies = instruction.getControlDependencies();
        for (ControlDependency directDependency : directDependencies) {
            Set<ControlDependency> upperDependencies = getAllControlDependencies(directDependency.getBranch().getInstruction());
            allDependencies.addAll(upperDependencies);
        }
        allDependencies.addAll(directDependencies);
        return allDependencies;
    }

    private static BytecodeInstruction getCallInstruction(CallGraphEntry fromMethod, CallGraphEntry toMethod) {
        List<BytecodeInstruction> callInstructions = BytecodeInstructionPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT())
                .getInstructionsIn(fromMethod.getClassName(), fromMethod.getMethodName())
                .stream()
                .filter(ASMWrapper::isMethodCall)
                .collect(Collectors.toList());
        Set<String> targetSubclasses = DependencyAnalysis.getInheritanceTree().getSubclasses(toMethod.getClassName());
        return callInstructions
                .stream()
                .filter(mc -> mc.getCalledMethod().equals(toMethod.getMethodName()))
                .filter(mc -> targetSubclasses.contains(mc.getCalledMethodsClass()))
                .findFirst().orElse(null);
    }

    private static Set<List<CallGraphEntry>> staticPathsToTarget(String targetClass, String targetMethod) {
        CallGraph clientCallGraph = DependencyAnalysis.getCallGraph();
        CallGraphEntry targetNode = clientCallGraph.getViewOfCurrentMethods()
                .stream()
                .filter(node -> node.getClassName().equals(targetClass) && node.getMethodName().equals(targetMethod))
                .findFirst().orElse(null);
        if (targetNode == null) {
            new GenerationLogger(Properties.SIEGE_LOG_FILE).write(String.format("Method %s.%s is not called via any class in the classpath.", targetClass, targetMethod));
            return null;
        }
        return staticPathsToNode(clientCallGraph, targetNode);
    }

    private static Set<List<CallGraphEntry>> staticPathsToNode(CallGraph callGraph, CallGraphEntry node) {
        Set<List<CallGraphEntry>> allPaths = new LinkedHashSet<>();
        Set<CallGraphEntry> incomingNodes = callGraph.getCallsFromMethod(node);
        if (incomingNodes.size() > 0) {
            for (CallGraphEntry incomingNode : incomingNodes) {
                Set<List<CallGraphEntry>> incomingPaths = staticPathsToNode(callGraph, incomingNode);
                allPaths.addAll(incomingPaths);
            }
            for (List<CallGraphEntry> allCallPath : allPaths) {
                allCallPath.add(allCallPath.size(), node);
            }
        } else {
            List<CallGraphEntry> incomingPath = new ArrayList<>();
            incomingPath.add(node);
            allPaths.add(incomingPath);
        }
        return allPaths;
    }
}
