package org.evosuite.coverage.reachability;

import org.evosuite.Properties;
import org.evosuite.TestGenerationContext;
import org.evosuite.coverage.reachability.exceptions.UncalledTarget;
import org.evosuite.coverage.reachability.exceptions.UnreachableTarget;
import org.evosuite.graphs.cfg.ASMWrapper;
import org.evosuite.graphs.cfg.BytecodeInstruction;
import org.evosuite.graphs.cfg.BytecodeInstructionPool;
import org.evosuite.graphs.cfg.ControlDependency;
import org.evosuite.rmi.ClientServices;
import org.evosuite.setup.DependencyAnalysis;
import org.evosuite.setup.callgraph.CallGraphEntry;
import org.evosuite.statistics.RuntimeVariable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static org.evosuite.coverage.reachability.ReachabilityCoverageGoal.CallUnit;

public class ReachabilityCoverageGoalsPreparer {
    protected static final Logger logger = LoggerFactory.getLogger(ReachabilityCoverageGoalsPreparer.class);

    public static List<ReachabilityCoverageGoal> prepare(ReachabilityTarget reachabilityTarget) throws UnreachableTarget {
        GenerationLogger generationLogger = new GenerationLogger(Properties.SIEGE_LOG_FILE);
        generationLogger.write("Creating test goals...");
        generationLogger.write(String.format("\t[TARGET] %s:%s", reachabilityTarget.getTargetClass(), reachabilityTarget.getTargetMethod()));
        generationLogger.write(String.format("\t[CLIENT] %s", Properties.TARGET_CLASS));
        //generationLogger.write("Public methods: " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCCFG(reachabilityTarget.getTargetClass()).publicMethods);
        //generationLogger.write("CDG? " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCDG(reachabilityTarget.getTargetClass(), reachabilityTarget.getTargetMethod()));

        List<ReachabilityCoverageGoal> goals = createGoals(Properties.TARGET_CLASS, reachabilityTarget.getTargetClass(), reachabilityTarget.getTargetMethod());
        if (goals.isEmpty()) {
            throw new UncalledTarget(String.format("The target is not called from %s.", Properties.TARGET_CLASS));
        }
        generationLogger.write("Goals created:");
        for (ReachabilityCoverageGoal goal : goals) {
            generationLogger.write(String.format("\t[Goal #%s] %s", goal.getId(), goal.getCallUnits().stream().map(Object::toString).collect(Collectors.joining("\n\t\t"))));
        }
        return goals;
    }

    private static List<ReachabilityCoverageGoal> createGoals(String clientClass, String targetClass, String targetMethod) {
        Set<StaticPath> staticPaths = StaticPathExplorer.staticPathsToTarget(targetClass, targetMethod);
        if (staticPaths.isEmpty()) {
            throw new UnreachableTarget("The target method cannot be reached from any client class. No goals can be created.");
        }
        // This will be needed by Siege during pre-analysis
        ClientServices.getInstance().getClientNode().trackOutputVariable(RuntimeVariable.StaticPaths, staticPaths);

        // Logging time
        GenerationLogger generationLogger = new GenerationLogger(Properties.SIEGE_LOG_FILE);
        generationLogger.write(String.format("Static paths to target (%s):", staticPaths.size()));
        for (StaticPath path : staticPaths) {
            int idx = 0;
            for (CallGraphEntry node : path) {
                String tabs = idx > 0 ? new String(new char[idx]).replace("\0", "\t") + "\u21B3" : "";
                idx++;
                generationLogger.write(String.format("%s%s", tabs, node));
            }
        }

        // TODO Look into the entire path to see if the client is present (indeed, it can also be in-between). If not, raise exception. If not in root, we can either "crop" the first part of the paths involving it or keep them as is but modify the fitness formula to take this scenario into account).
        // Select paths rooted in the selected client class only and make the goals from these only, ignoring the other paths
        Set<StaticPath> clientRootedPaths = staticPaths.stream().filter(p -> p.getRootNodeName().equals(clientClass)).collect(Collectors.toSet());
        List<ReachabilityCoverageGoal> goals = new ArrayList<>();
        int id = 0;
        for (StaticPath path : clientRootedPaths) {
            if (Properties.BRANCH_AWARENESS) {
                List<CallUnit> callUnits = new ArrayList<>();
                generationLogger.write("Call instructions to reach the target:");
                for (int i = 0; i < path.length() - 1; i++) {
                    CallGraphEntry cgEntry = path.get(i);
                    BytecodeInstruction callInstruction = getCallInstruction(cgEntry, path.get(i + 1));
                    generationLogger.write(String.format("\t%s at %s:%s", callInstruction, callInstruction.getClassName(), callInstruction.getMethodName()));
                    Set<ControlDependency> allControlDependencies = getAllControlDependencies(callInstruction);
                    generationLogger.write(String.format("\t\tBranches to reach it (Control Dependencies): %s", allControlDependencies));
                    callUnits.add(new CallUnit(cgEntry, new ArrayList<>(allControlDependencies)));
                }
                // Last element of path has no branches to be executed, as we just need method reachability
                callUnits.add(new CallUnit(path.get(path.length() - 1), new ArrayList<>()));
                goals.add(new ReachabilityCoverageGoal(id, callUnits));
            } else {
                goals.add(new ReachabilityCoverageGoal(id, path.stream().map(p -> new CallUnit(p, new ArrayList<>())).collect(Collectors.toList())));
            }
            id++;
        }
        return goals;
    }

    private static Set<ControlDependency> getAllControlDependencies(BytecodeInstruction instruction) {
        Set<ControlDependency> allDependencies = new LinkedHashSet<>();
        Set<ControlDependency> directDependencies = instruction.getControlDependencies();
        for (ControlDependency directDependency : directDependencies) {
            Set<ControlDependency> upperDependencies = getAllControlDependencies(directDependency.getBranch().getInstruction());
            allDependencies.addAll(upperDependencies);
        }
        allDependencies.addAll(directDependencies);
        return allDependencies;
    }

    private static BytecodeInstruction getCallInstruction(CallGraphEntry fromMethod, CallGraphEntry toMethod) {
        List<BytecodeInstruction> callInstructions = BytecodeInstructionPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT())
                .getInstructionsIn(fromMethod.getClassName(), fromMethod.getMethodName())
                .stream()
                .filter(ASMWrapper::isMethodCall)
                .collect(Collectors.toList());
        Set<String> targetSubclasses = DependencyAnalysis.getInheritanceTree().getSubclasses(toMethod.getClassName());
        return callInstructions
                .stream()
                .filter(mc -> mc.getCalledMethod().equals(toMethod.getMethodName()))
                .filter(mc -> targetSubclasses.contains(mc.getCalledMethodsClass()))
                .findFirst().orElse(null);
    }
}
