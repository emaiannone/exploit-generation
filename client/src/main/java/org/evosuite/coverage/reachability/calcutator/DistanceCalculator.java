package org.evosuite.coverage.reachability.calcutator;

import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.evosuite.Properties;
import org.evosuite.coverage.ControlFlowDistance;
import org.evosuite.coverage.branch.ControlFlowDistanceCalculator;
import org.evosuite.graphs.cfg.ControlDependency;
import org.evosuite.setup.Call;
import org.evosuite.setup.CallContext;
import org.evosuite.testcase.execution.ExecutionResult;
import org.evosuite.utils.GenerationLogger;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Helper class that computes the approach level and branch distances of the execution result with respect to a list of control dependencies.
 */
public class DistanceCalculator {
    /**
     * Computes the approach level of the execution result with respect to a list of control dependencies in a given class method.
     * The approach level is the number of branches that diverges from the last control dependency in the list.
     *
     * @return a non-negative integer corresponding to the approach level. If the result does not cover the targetContext the maximum inter-procedural depth (i.e., the Control Flow Graph diameter) is returned.
     */
    public static int calculateApproachLevel(ExecutionResult result, List<ControlDependency> targetControlDependencies, String className, String methodName) {
        // These distances are 0 if a control dependency was reached (even with different truth value), otherwise it is equals to its control flow distance from the root node. We do not care about this distance: the count of non-zero distances is our approach level.
        if (targetControlDependencies.isEmpty()) {
            return 0;
        }
        List<ControlFlowDistance> controlFlowDistances = targetControlDependencies.stream()
                .map(cd -> getControlFlowDistance(result, cd, className, methodName))
                .collect(Collectors.toList());
        GenerationLogger generationLogger = new GenerationLogger(Properties.GENERATION_LOG_FILE);
        generationLogger.write(String.format("\tDistances: %s", controlFlowDistances.stream().map(a -> String.format("Root distance = %s, Branch distance = %s", a.getApproachLevel(), a.getBranchDistance())).collect(Collectors.joining("; "))));
        return (int) controlFlowDistances.stream()
                .map(ControlFlowDistance::getApproachLevel)
                .filter(sd -> sd != 0)
                .count();
    }

    /**
     * Computes the branch distance of the execution result with respect to the first control dependency that was not evaluated with the expected truth value (i.e., divergence point) in a given class method.
     * The branch distance depends on "how far" is the predicate to reach the expected truth value.
     *
     * @return a double corresponding to the branch distance of the divergence point. If there is not divergence point, the branch distance is zero.
     */
    public static double calculateBranchDistanceOnDivergencePoint(ExecutionResult result, List<ControlDependency> targetControlDependencies, String className, String methodName) {
        Pair<ControlDependency, ControlFlowDistance> divergencePoint = getDivergencePoint(result, targetControlDependencies, className, methodName);
        if (divergencePoint != null) {
            return divergencePoint.getRight().getBranchDistance();
        }
        return 0.0;
    }

    public static double calculateBranchDistance(ExecutionResult result, ControlDependency controlDependency, String className, String methodName) {
        return getControlFlowDistance(result, controlDependency, className, methodName).getBranchDistance();
    }

    public static int calculateApproachLevel(ExecutionResult result, List<ControlDependency> targetControlDependencies, CallContext targetContext) {
        List<Call> calls = targetContext.getContext();
        Call leafCall = calls.get(calls.size() - 1);
        return calculateApproachLevel(result, targetControlDependencies, leafCall.getClassName(), leafCall.getMethodName());
    }

    private static Pair<ControlDependency, ControlFlowDistance> getDivergencePoint(ExecutionResult result, List<ControlDependency> targetControlDependencies, String className, String methodName) {
        if (targetControlDependencies.isEmpty()) {
            return null;
        }
        for (ControlDependency targetControlDependency : targetControlDependencies) {
            ControlFlowDistance controlFlowDistance = getControlFlowDistance(result, targetControlDependency, className, methodName);
            if (controlFlowDistance.getApproachLevel() != 0) {
                return new ImmutablePair<>(targetControlDependency, controlFlowDistance);
            }
        }
        return null;
    }

    private static ControlFlowDistance getControlFlowDistance(ExecutionResult result, ControlDependency controlDependency, String className, String methodName) {
        return ControlFlowDistanceCalculator.getDistance(result, controlDependency.getBranch(), controlDependency.getBranchExpressionValue(), className, methodName);
    }

}
