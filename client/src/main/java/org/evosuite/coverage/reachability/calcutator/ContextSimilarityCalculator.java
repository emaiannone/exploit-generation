package org.evosuite.coverage.reachability.calcutator;

import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.evosuite.setup.Call;
import org.evosuite.setup.callgraph.CallGraphEntry;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Helper class that computes the context similarity of a call context with respect to a target call context.
 */
public class ContextSimilarityCalculator {
    private static final double RIGHT_CLASS_WEIGHT = 0.25;
    private static final double DIVERGENCE_WEIGHT = 0.5;
    private static final double RIGHT_METHOD_WEIGHT = 1.0;

    public static double calculate(List<Call> executedContext, List<CallGraphEntry> targetContext) {
        Pair<Integer, CallGraphEntry> firstExecutedCall = findFirstExecutedCall(executedContext, targetContext);
        if (firstExecutedCall.getRight() == null) {
            // No method was executed at all, but at least we can check if the first expected class has been executed, even with a different method. In this case, we assign the extra score.
            double rightClassScore = computeRightClassScore(executedContext, targetContext);
            // TODO Look into the test code: if the first expected call is there, we can ADD another slight bonus (e.g, similar to rightClassScore, another quarter) -> computeFirstCallInTestCodeScore()
            return rightClassScore;
        }

        List<CallGraphEntry> workTargetContext = targetContext.subList(firstExecutedCall.getLeft(), targetContext.size());
        int numExecutedCalls = (int) IntStream
                .range(firstExecutedCall.getLeft(), Math.min(executedContext.size(), workTargetContext.size()))
                .filter(i -> compareCalls(executedContext.get(i), workTargetContext.get(i)))
                .count();
        double executedCallsScore = RIGHT_METHOD_WEIGHT * numExecutedCalls / workTargetContext.size();
        if (executedCallsScore == 1.0) {
            return 1.0;
        }

        // Compute divergence penalty: the higher the divergence, the larger the malus
        Pair<Integer, Call> firstDivergentCall = findFirstDivergentCall(executedContext, targetContext);
        double divergencePenalty = 0.0;
        if (firstDivergentCall.getRight() != null) {
            int numDivergentCalls = executedContext.size() - firstDivergentCall.getLeft();
            double divergenceRatio = (double) numDivergentCalls / executedContext.size();
            divergencePenalty = DIVERGENCE_WEIGHT * divergenceRatio / workTargetContext.size();
        }

        // Try to add an extra, i.e., if the divergence point is of the same class of the first NOT executed call
        Pair<Integer, CallGraphEntry> lastExecutedCall = findLastExecutedCall(executedContext, targetContext);
        double classNotDivergentScore = 0.0;
        if (firstDivergentCall.getRight() != null && lastExecutedCall.getLeft() + 1 < targetContext.size()) {
            String nextClassName = targetContext.get(lastExecutedCall.getLeft() + 1).getClassName();
            if (firstDivergentCall.getRight().getClassName().equals(nextClassName)) {
                classNotDivergentScore = DIVERGENCE_WEIGHT / workTargetContext.size();
            }
        }

        // TODO Another small extra (1/4 point) for calling an overloaded method?
        return executedCallsScore - divergencePenalty + classNotDivergentScore;
    }

    public static Pair<Integer, CallGraphEntry> findLastExecutedCall(List<Call> executedContext, List<CallGraphEntry> targetContext) {
        Pair<Integer, CallGraphEntry> firstExecutedCall = findFirstExecutedCall(executedContext, targetContext);
        if (firstExecutedCall.getRight() == null) {
            return new ImmutablePair<>(-1, null);
        }
        List<CallGraphEntry> workTargetContext = targetContext.subList(firstExecutedCall.getLeft(), targetContext.size());
        int minSize = Math.min(executedContext.size(), workTargetContext.size());
        int idx = -1;
        for (int i = 0; i < minSize; i++) {
            if (compareCalls(executedContext.get(i), workTargetContext.get(i))) {
                idx = i;
            }
        }
        if (idx == -1) {
            return new ImmutablePair<>(idx, null);
        }
        return new ImmutablePair<>(idx + firstExecutedCall.getLeft(), targetContext.get(idx + firstExecutedCall.getLeft()));
    }

    private static double computeRightClassScore(List<Call> executedContext, List<CallGraphEntry> targetContext) {
        Pair<Integer, CallGraphEntry> firstExecutedClass = findFirstExecutedClass(executedContext.stream().map(Call::getClassName).collect(Collectors.toList()), targetContext);
        double rightClassScore;
        if (firstExecutedClass.getRight() == null) {
            rightClassScore = 0.0;
        } else {
            // We assign "a quarter of a point", i.e., we count 0.25 instead of 1, as 1 correspond to a correct method execution.
            int remainingTargetNodes = targetContext.size() - firstExecutedClass.getLeft();
            rightClassScore = RIGHT_CLASS_WEIGHT / remainingTargetNodes;
        }
        return rightClassScore;
    }

    private static Pair<Integer, Call> findFirstDivergentCall(List<Call> executedContext, List<CallGraphEntry> targetContext) {
        Pair<Integer, CallGraphEntry> executedCall = findFirstExecutedCall(executedContext, targetContext);
        if (executedCall.getRight() == null) {
            return new ImmutablePair<>(-1, null);
        }
        List<CallGraphEntry> workTargetContext = targetContext.subList(executedCall.getLeft(), targetContext.size());
        int minSize = Math.min(executedContext.size(), workTargetContext.size());
        int idx = IntStream.range(0, minSize)
                .filter(i -> !compareCalls(executedContext.get(i), workTargetContext.get(i)))
                .findFirst().orElse(-1);
        if (idx == -1) {
            return new ImmutablePair<>(-1, null);
        }
        return new ImmutablePair<>(idx, executedContext.get(idx));
    }

    private static Pair<Integer, CallGraphEntry> findFirstExecutedCall(List<Call> executedContext, List<CallGraphEntry> targetContext) {
        return findExecutedCall(executedContext.get(0), targetContext);
    }

    private static Pair<Integer, CallGraphEntry> findExecutedCall(Call callToFind, List<CallGraphEntry> targetContext) {
        int idx = IntStream.range(0, targetContext.size())
                .filter(startIdx -> compareCalls(callToFind, targetContext.get(startIdx)))
                .findFirst().orElse(-1);
        return idx == -1 ? new ImmutablePair<>(idx, null) : new ImmutablePair<>(idx, targetContext.get(idx));
    }

    private static Pair<Integer, CallGraphEntry> findFirstExecutedClass(List<String> executedClasses, List<CallGraphEntry> targetContext) {
        return findExecutedClass(executedClasses.get(0), targetContext);
    }

    private static Pair<Integer, CallGraphEntry> findExecutedClass(String classToFind, List<CallGraphEntry> targetContext) {
        int idx = IntStream.range(0, targetContext.size())
                .filter(startIdx -> classToFind.equals(targetContext.get(startIdx).getClassName()))
                .findFirst().orElse(-1);
        return idx == -1 ? new ImmutablePair<>(idx, null) : new ImmutablePair<>(idx, targetContext.get(idx));
    }

    private static boolean compareCalls(Call executedCall, CallGraphEntry targetCall) {
        if (executedCall.getMethodName().equals(targetCall.getMethodName())) {
            return executedCall.getClassName().equals(targetCall.getClassName()); // Perfect match
        } else {
            return false; // No match
        }
    }

}
