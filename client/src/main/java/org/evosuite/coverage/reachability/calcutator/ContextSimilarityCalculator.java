package org.evosuite.coverage.reachability.calcutator;

import org.evosuite.setup.Call;
import org.evosuite.setup.callgraph.CallGraphEntry;

import java.util.ArrayList;
import java.util.List;

/**
 * Helper class that computes the context similarity of a call context with respect to a target call context.
 */
public class ContextSimilarityCalculator {
    /**
     * Computes the context similarity of an executed call context with respect to a given target call context.
     * Function: sim = rawSim - penaltyFactor * rawSim
     * rawSim = number of matches (equal calls)
     * If the last calls matches, then sqrt(sim) is returned, otherwise sim
     *
     * @param executedContext The list of method calls actually called
     * @param targetContext   The list of method calls that should be called
     * @return a value between 0 and 1. The closer to 1, the more similar the two call context are.
     */
    public static double calculate(List<Call> executedContext, List<CallGraphEntry> targetContext) {
        List<Integer> matchScores = new ArrayList<>();
        int minSize = Math.min(executedContext.size(), targetContext.size());
        for (int i = 0; i < minSize; i++) {
            matchScores.add(compareCalls(executedContext.get(i), targetContext.get(i)) ? 1 : 0);
        }
        int sum = matchScores.stream().mapToInt(Integer::intValue).sum();
        double rawSim = (double) sum / targetContext.size();
        double penaltyFactor = (double) Math.abs(executedContext.size() - targetContext.size()) / Math.max(executedContext.size(), targetContext.size());
        double contextSim = rawSim - penaltyFactor * rawSim;
        Call lastCall = executedContext.get(executedContext.size() - 1);
        CallGraphEntry lastTargetCall = targetContext.get(targetContext.size() - 1);
        if (compareCalls(lastCall, lastTargetCall)) {
            return Math.sqrt(contextSim);
        } else {
            return contextSim;
        }
    }

    public static Call getDivergentCall(List<Call> executedContext, List<CallGraphEntry> targetContext) {
        int minSize = Math.min(executedContext.size(), targetContext.size());
        for (int i = 0; i < minSize; i++) {
            Call executedCall = executedContext.get(i);
            CallGraphEntry targetCall = targetContext.get(i);
            if (!compareCalls(executedCall, targetCall)) {
                return executedCall;
            }
        }
        return null;
    }

    public static CallGraphEntry getLastExecutedCall(List<Call> executedContext, List<CallGraphEntry> targetContext) {
        int minSize = Math.min(executedContext.size(), targetContext.size());
        CallGraphEntry lastExecuted = null;
        for (int i = 0; i < minSize; i++) {
            Call executedCall = executedContext.get(i);
            CallGraphEntry targetCall = targetContext.get(i);
            if (compareCalls(executedCall, targetCall)) {
                lastExecuted = targetCall;
            }
        }
        return lastExecuted;
    }

    private static boolean compareCalls(Call executedCall, CallGraphEntry targetCall) {
        if (executedCall.getMethodName().equals(targetCall.getMethodName())) {
            return executedCall.getClassName().equals(targetCall.getClassName()); // Perfect match
        } else {
            return false; // No match
        }
    }

}
