package org.evosuite.coverage.reachability;

import org.evosuite.Properties;
import org.evosuite.setup.DependencyAnalysis;
import org.evosuite.setup.callgraph.CallGraph;
import org.evosuite.setup.callgraph.CallGraphEntry;

import java.util.LinkedHashSet;
import java.util.Set;

public class StaticPathExplorer {

    public static Set<StaticPath> staticPathsToTarget(String targetClass, String targetMethod) {
        CallGraph clientCallGraph = DependencyAnalysis.getCallGraph();
        CallGraphEntry targetNode = clientCallGraph.getViewOfCurrentMethods()
                .stream()
                .filter(node -> node.getClassName().equals(targetClass) && node.getMethodName().equals(targetMethod))
                .findFirst().orElse(null);
        if (targetNode == null) {
            new GenerationLogger(Properties.SIEGE_LOG_FILE).write(String.format("Method %s.%s is not called by any class in the classpath.", targetClass, targetMethod));
            return new LinkedHashSet<>();
        }
        return findStaticPathsToNode(clientCallGraph, targetNode, null);
    }

    private static Set<StaticPath> findStaticPathsToNode(CallGraph callGraph, CallGraphEntry newNode, StaticPath activePath) {
        //String tabs = activePath != null ? new String(new char[activePath.length()]).replace("\0", "\t") + "\u21B3" : "";
        //GenerationLogger generationLogger = new GenerationLogger(Properties.SIEGE_LOG_FILE);
        //generationLogger.write(String.format("%s%s, %s", tabs, newNode, activePath));

        if (activePath != null && activePath.contains(newNode)) {
            //generationLogger.write(String.format("%s\tAlready present in active path", tabs));
            return new LinkedHashSet<>();
        }
        Set<StaticPath> pathsFound = new LinkedHashSet<>();
        Set<CallGraphEntry> incomingNodes = callGraph.getCallsFromMethod(newNode);
        if (incomingNodes.isEmpty()) {
            StaticPath newActivePath = activePath != null ? activePath.clone() : new StaticPath();
            newActivePath.add(0, newNode);
            pathsFound.add(newActivePath);
        } else {
            for (CallGraphEntry incomingNode : incomingNodes) {
                StaticPath newActivePath = activePath != null ? activePath.clone() : new StaticPath();
                newActivePath.add(0, newNode);
                pathsFound.addAll(findStaticPathsToNode(callGraph, incomingNode, newActivePath));
            }
        }
        return pathsFound;
    }
}
