package org.evosuite.coverage.my;

import org.evosuite.testcase.ExecutableChromosome;
import org.evosuite.testcase.execution.ExecutionResult;
import org.evosuite.testsuite.AbstractTestSuiteChromosome;
import org.evosuite.testsuite.TestSuiteFitnessFunction;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class MySuiteFitness extends TestSuiteFitnessFunction {

    private final Set<MyTestFitness> myGoals = new HashSet<>();

    public MySuiteFitness() {
        myGoals.addAll(new MyFactory().getCoverageGoals());
    }

    @Override
    public double getFitness(AbstractTestSuiteChromosome<? extends ExecutableChromosome> suite) {
        double fitness;
        List<ExecutionResult> results = runTestSuite(suite);
        // TODO: calculate better suite fitness value
        Set<MyTestFitness> coveredGoals = myGoals.stream()
                .filter(goal -> results.stream()
                        .anyMatch(goal::isCovered))
                .collect(Collectors.toSet());
        if (results.stream()
                .anyMatch(result -> result.hasTimeout() || result.hasTestException())) {
            fitness = myGoals.size();
        } else {
            fitness = myGoals.size() - coveredGoals.size();
        }

        // Must be done to notify the suite the ratio of covered goals and the aggregated fitness value
        suite.setNumOfCoveredGoals(this, coveredGoals.size());
        suite.setCoverage(this, !myGoals.isEmpty() ? (double) coveredGoals.size() / (double) myGoals.size() : 1.0);
        updateIndividual(this, suite, fitness);
        return fitness;
    }
}
