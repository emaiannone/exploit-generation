package org.evosuite.coverage.my;

import org.apache.commons.text.similarity.LevenshteinDistance;
import org.evosuite.Properties;
import org.evosuite.TestGenerationContext;
import org.evosuite.graphs.GraphPool;
import org.evosuite.testcase.TestChromosome;
import org.evosuite.testcase.TestFitnessFunction;
import org.evosuite.testcase.execution.ExecutionResult;
import org.evosuite.testcase.execution.TestCaseExecutor;
import org.evosuite.testcase.statements.MethodStatement;
import org.evosuite.testcase.statements.Statement;
import org.evosuite.testcase.statements.StringPrimitiveStatement;
import org.evosuite.testcase.variable.VariableReference;

import java.util.Objects;

public class MyTestFitness extends TestFitnessFunction {
    private final String targetClass;
    private final String targetMethod;
    private final static String TARGET = "badInput123";

    public MyTestFitness(String targetClass, String targetMethod) {
        this.targetClass = targetClass;
        this.targetMethod = targetMethod;
        TestCaseExecutor executor = TestCaseExecutor.getInstance();
        executor.addObserver(new MyObserver());
    }

    /**
     * Core logic of the fitness function, called by {@link org.evosuite.testcase.TestFitnessFunction#getFitness(TestChromosome)}
     *
     * @param individual that gols holds a single TC (Default: sequence of executable (with reflection) statements, but can be another thing)
     * @param result     that holds the result of the already executed (by {@link org.evosuite.testcase.TestFitnessFunction#getFitness(TestChromosome)}) TC in the individual.
     * @return fitness   value (normalized)
     */
    @Override
    public double getFitness(TestChromosome individual, ExecutionResult result) {
        int targetHits = 0;
        float sumNormalizedDistances = 0;
        System.out.println("//////////INDIVIDUAL////////////");
        //System.out.println(result.test);
        GraphPool gp = GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT());
        System.out.println("////CCFG/////");
        System.out.println(gp.getCCFG(Properties.TARGET_CLASS).publicMethods);
        result.getTrace().getMethodCalls().forEach(methodCall -> System.out.println(methodCall.methodName));
        for (Statement statement : result.test) {
            if (statement instanceof MethodStatement) {
                MethodStatement methodCall = (MethodStatement) statement;
                String belongingClass = methodCall.getDeclaringClassName();
                String methodName = methodCall.getMethodName() + methodCall.getDescriptor();
                // TODO: Do better fitness update
                if (belongingClass.equals(targetClass)) {
                    if (methodName.equals(targetMethod)) {
                        targetHits++;
                        VariableReference parameterRef1 = methodCall.getParameterReferences().get(0);
                        // TODO: Check if is already a constant value
                        Statement parameterDef1 = result.test.getStatement(parameterRef1.getStPosition());
                        if (parameterDef1 instanceof StringPrimitiveStatement) {
                            StringPrimitiveStatement stringStmt = (StringPrimitiveStatement) parameterDef1;
                            String actual = stringStmt.getValue();
                            // TODO: It is not always edit distance with a particula string, but also some other measure
                            float editDistance = LevenshteinDistance.getDefaultInstance().apply(actual, TARGET);
                            float normalizedDistance = editDistance / Math.max(actual.length(), TARGET.length());
                            //System.out.println("Comparing " + TARGET + " with " + actual + ":" + normalizedDistance);
                            // Exploited!
                            if (normalizedDistance == 0) {
                                System.out.println("EXPLOITED!!!");
                                updateIndividual(this, individual, 0);
                                return 0;
                            }
                            sumNormalizedDistances += normalizedDistance;
                        } else {
                            // Null is bad, so increases by one
                            sumNormalizedDistances++;
                        }
                    }
                }
            }
        }

        // Mean of normalized distances of only hit targets
        double fitness = targetHits > 0 ? sumNormalizedDistances / targetHits : 1.0;

        // Must be done to notify individual of its new fitness value
        updateIndividual(this, individual, fitness);
        return fitness;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        MyTestFitness that = (MyTestFitness) o;
        return Objects.equals(targetClass, that.targetClass) &&
                Objects.equals(targetMethod, that.targetMethod);
    }

    @Override
    public int hashCode() {
        return Objects.hash(targetClass, targetMethod);
    }

    @Override
    public int compareTo(TestFitnessFunction o) {
        if (o instanceof MyTestFitness) {
            MyTestFitness that = (MyTestFitness) o;
            if (targetClass.equals(that.getTargetClass())) {
                return targetMethod.compareTo(that.getTargetMethod());
            } else {
                return targetClass.compareTo(that.getTargetClass());
            }
        }
        return compareClassName(o);
    }

    @Override
    public String getTargetClass() {
        return targetClass;
    }

    @Override
    public String getTargetMethod() {
        return targetMethod;
    }
}
