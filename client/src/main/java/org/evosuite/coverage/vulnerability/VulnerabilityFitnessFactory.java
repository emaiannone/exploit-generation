package org.evosuite.coverage.vulnerability;

import org.evosuite.Properties;
import org.evosuite.TestGenerationContext;
import org.evosuite.graphs.cfg.BytecodeInstruction;
import org.evosuite.graphs.cfg.BytecodeInstructionPool;
import org.evosuite.graphs.cfg.ControlDependency;
import org.evosuite.setup.CallContext;
import org.evosuite.setup.DependencyAnalysis;
import org.evosuite.setup.callgraph.CallGraph;
import org.evosuite.testsuite.AbstractFitnessFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class VulnerabilityFitnessFactory extends AbstractFitnessFactory<VulnerabilityTestFitness> {
    protected static final Logger logger = LoggerFactory.getLogger(VulnerabilityFitnessFactory.class);
    private String vulnerableClass;
    private String vulnerableMethod;
    private Integer vulnerableLine;

    public VulnerabilityFitnessFactory() {
        this(Properties.VULN_CLASS, Properties.VULN_METHOD, Properties.VULN_LINE);
    }

    public VulnerabilityFitnessFactory(String vulnerableClass, String vulnerableMethod, int vulnerableLine) {
        if (vulnerableClass == null || vulnerableMethod == null || vulnerableLine == 0) {
            throw new IllegalArgumentException("Invalid class, method or line.");
        }
        this.vulnerableClass = vulnerableClass;
        this.vulnerableMethod = vulnerableMethod;
        this.vulnerableLine = vulnerableLine;
    }

    /**
     * Generate coverage goals. Called by EvoSuite.
     *
     * @return the list of coverage goals.
     * @throws IllegalArgumentException if bytecode instruction of the vulnerable target cannot be not found.
     */
    @Override
    public List<VulnerabilityTestFitness> getCoverageGoals() {
        logger.debug("\n##### Starting creation of coverage goals #####");
        logger.debug("Vulnerable Target:\n\t{}::{} at line {}", vulnerableClass, vulnerableMethod, vulnerableLine);

        // Get bytecode of vulnerable class, method and line
        BytecodeInstructionPool instructionPool = BytecodeInstructionPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT());
        List<BytecodeInstruction> allInstruction = instructionPool.getInstructionsIn(vulnerableClass);
        logger.debug("Class {} Bytecode:\n\t{}", vulnerableClass, allInstruction);
        List<BytecodeInstruction> methodInstructions = instructionPool.getInstructionsIn(vulnerableClass, vulnerableMethod);
        logger.debug("Method {} Bytecode:\n\t{}", vulnerableMethod, methodInstructions);
        // A line can have multiple bytecode instructions, however, for our purposes, it does not matter which one is chosen, so we can safely pick the first one
        BytecodeInstruction instructionAtLine = instructionPool
                .getFirstInstructionAtLineNumber(vulnerableClass, vulnerableMethod, vulnerableLine);
        logger.debug("Line {} Bytecode:\n\t{}", vulnerableLine, instructionAtLine);

        if (instructionAtLine == null) {
            RuntimeException e = new IllegalArgumentException("Cannot find vulnerable bytecode instruction. Impossible to create coverage goals.");
            logger.debug("", e);
            throw e;
        }

        // TODO Will be removed soon
        //CallGraph callGraph = DependencyAnalysis.getCallGraph();
        //logger.debug("Public methods: " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCCFG(vulnerableClass).publicMethods);
        //logger.debug("CDG? " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCDG(vulnerableClass, vulnerableMethod));
        //logger.debug("Class is called? " + callGraph.isCalledClass(vulnerableClass));
        //logger.debug("Method is called? " + callGraph.isCalledMethod(vulnerableClass, vulnerableMethod));

        try {
            List<ControlDependency> controlDependencies = getAllControlDependencies(instructionAtLine);
            // Note: some predicates may get reversed when compiled into bytecode
            logger.debug("Control Dependencies:\n\t{}", Arrays.toString(controlDependencies.toArray()));

            List<VulnerabilityTestFitness> goals = prepareGoals(controlDependencies, vulnerableClass, vulnerableMethod);
            if (goals.size() == 0) {
                // TODO Is this possible? If this is not possible, avoid this. But don't think about it for now
                logger.debug("Target is never statically called!");
            } else {
                logger.debug("These are the produced goals:");
                goals.forEach(g -> logger.debug("\t{}", g));
            }
            return goals;
        } catch (IllegalArgumentException | IllegalStateException e) {
            logger.debug("", e);
            throw e;
        }
    }

    /**
     * Recursive method that collects all control dependant branches starting from argument instruction up to root of the instruction's CDG.
     * The order of collection of branches starts from the innermost one to the outermost one, but the final list has reverse order.
     * This implementation is loop-safe, so they will only be collected once.
     *
     * @param instruction starting bytecode instruction.
     * @return list of control dependencies that has an (indirect) control dependencies on the starting instruction,
     * starting from the outermost one to the innermost one.
     * @throws IllegalArgumentException if the given bytecode instruction is null.
     * @throws IllegalStateException    if the method of the given bytecode instruction is not statically called.
     */
    private static List<ControlDependency> getAllControlDependencies(BytecodeInstruction instruction) {
        if (instruction == null) {
            throw new IllegalArgumentException("A non-null bytecode instruction is required.");
        }

        // Base case: no control dependency (root)
        if (instruction.getControlDependencies().size() == 0) {
            return new ArrayList<>();
        }

        // Main part, get all direct control dependencies except itself (loop-safe)
        List<ControlDependency> directCDs = instruction.getControlDependencies()
                .stream()
                .filter(cd -> cd.getBranch().getInstruction().getInstructionId() != instruction.getInstructionId())
                .collect(Collectors.toList());

        // Recursive step
        List<ControlDependency> indirectCDs = directCDs.stream()
                .map(cd -> getAllControlDependencies(cd.getBranch().getInstruction()))
                .flatMap(Collection::stream).distinct()
                .collect(Collectors.toList());

        // Concat Direct + Indirect
        List<ControlDependency> CDs = new ArrayList<>(directCDs);
        CDs.addAll(indirectCDs);
        Collections.reverse(CDs);
        return CDs;
    }

    /**
     * Helper method that takes care of coverage goals preparation.
     *
     * @param controlDependencies list of control dependencies.
     * @return the list of coverage goals composed of target call context and the list of control dependent branches.
     * The list is empty is the target class and method are never statically called.
     * @throws IllegalArgumentException if the given list of control dependencies is null.
     */
    private static List<VulnerabilityTestFitness> prepareGoals(List<ControlDependency> controlDependencies, String vulnerableClass, String vulnerableMethod) {
        if (controlDependencies == null) {
            throw new IllegalArgumentException("A non-null list of control dependencies is required.");
        }

        // If the vulnerable method is not statically called, no goals can be provided
        CallGraph callGraph = DependencyAnalysis.getCallGraph();
        if (!callGraph.isCalledMethod(vulnerableClass, vulnerableMethod)) {
            return new ArrayList<>();
        }
        // Consider only non empty call contexts
        List<CallContext> nonEmptyContexts = callGraph
                .getAllContextsFromTargetClass(vulnerableClass, vulnerableMethod)
                .stream()
                .filter(cc -> !cc.isEmpty())
                .collect(Collectors.toList());

        // A coverage goal consists of an id, a call context and the given CDs
        return IntStream.range(0, nonEmptyContexts.size())
                .mapToObj(index -> new VulnerabilityTestFitness(index, nonEmptyContexts.get(index), controlDependencies))
                .collect(Collectors.toList());
    }
}
