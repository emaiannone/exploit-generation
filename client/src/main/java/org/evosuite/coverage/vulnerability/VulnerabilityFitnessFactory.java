package org.evosuite.coverage.vulnerability;

import org.evosuite.TestGenerationContext;
import org.evosuite.coverage.io.output.OutputCoverageTestFitness;
import org.evosuite.graphs.cfg.BytecodeInstruction;
import org.evosuite.graphs.cfg.BytecodeInstructionPool;
import org.evosuite.graphs.cfg.ControlDependency;
import org.evosuite.setup.DependencyAnalysis;
import org.evosuite.setup.callgraph.CallGraph;
import org.evosuite.testsuite.AbstractFitnessFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

public class VulnerabilityFitnessFactory extends AbstractFitnessFactory<VulnerabilityTestFitness> {
    protected static final Logger logger = LoggerFactory.getLogger(VulnerabilityFitnessFactory.class);
    private String vulnerableClass;
    private String vulnerableMethod;
    private Integer vulnerableLine;

    public VulnerabilityFitnessFactory() {
        this("com.examples.with.different.packagename.vulnerableoss.VulnerableClassOfLibrary",
                "vulnerableMethodOfLibrary(Ljava/lang/String;)V",
                23);
    }

    public VulnerabilityFitnessFactory(String vulnerableClass, String vulnerableMethod, int vulnerableLine) {
        this.vulnerableClass = vulnerableClass;
        this.vulnerableMethod = vulnerableMethod;
        this.vulnerableLine = vulnerableLine;
    }

    @Override
    public List<VulnerabilityTestFitness> getCoverageGoals() {
        System.out.println("Target Class::Method: " + vulnerableClass + "::" + vulnerableMethod);

        // Get the bytecode instruction at the vulnerable line
        BytecodeInstructionPool instructionPool = BytecodeInstructionPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT());
        BytecodeInstruction instructionAtLine = instructionPool
                .getFirstInstructionAtLineNumber(vulnerableClass, vulnerableMethod, vulnerableLine);
        if (instructionAtLine == null) {
            System.out.println("\tExpected to be impossible!");
            return new ArrayList<>();
        }

        // Instructions within the same line share the same control dependencies (the CD are of the block), so I can safely take any element
        List<ControlDependency> controlDependencies = getAllControlDependencies(instructionAtLine);
        /*
        System.out.println("\tInstruction at line " + vulnerableLine + ": ");
        instructionsAtLine.forEach(i -> System.out.println("\t\t" + i));

         */
        System.out.println("\tControl Dependencies: ");
        controlDependencies.forEach(branch -> System.out.println("\t\t" + branch));

        List<VulnerabilityTestFitness> goals = this.prepareGoals(controlDependencies);
        if (goals.size() == 0) {
            System.out.println("\tTarget is never called");
        } else {
            System.out.println("\tThese are the produced goals: ");
            goals.forEach(g -> System.out.println("\t\t" + g));
        }
        System.out.println();
        return goals;
    }

    /**
     * Recursive method that collects all control dependant branches starting from argument instruction up to root of the instruction's CDG.
     * The order of collection of branches starts from the most inner one, so from the deepest to the shallowest.
     * This implementation is loop-safe, so they will only be collected once.
     *
     * @param instruction starting bytecode instruction
     * @return list of control dependencies that has an (indirect) control dependencies on the starting instruction
     */
    private static List<ControlDependency> getAllControlDependencies(BytecodeInstruction instruction) {
        // Base case: no instruction or it has no control dependency (root)
        if (instruction == null || instruction.getControlDependencies().size() == 0) {
            return new ArrayList<>();
        }

        // Main part, get all direct control dependencies except itself (loop-safe)
        List<ControlDependency> directCDs = instruction.getControlDependencies()
                .stream()
                .filter(cd -> cd.getBranch().getInstruction().getInstructionId() != instruction.getInstructionId())
                .collect(Collectors.toList());

        // Recursive step
        List<ControlDependency> indirectCDs = directCDs.stream()
                .map(cd -> getAllControlDependencies(cd.getBranch().getInstruction()))
                .flatMap(Collection::stream).distinct()
                .collect(Collectors.toList());

        // Concat Direct + Indirect
        List<ControlDependency> CDs = new ArrayList<>(directCDs);
        CDs.addAll(indirectCDs);
        return CDs;
    }

    /**
     * Helper method to take care of fitness goals preparation.
     *
     * @param controlDependencies list of control dependencies (branch + truth value)
     * @return list of fitness goals composed of target call context and the list of control dependent branches
     */
    private List<VulnerabilityTestFitness> prepareGoals(List<ControlDependency> controlDependencies) {
        // First check if the vulnerable method is statically called
        CallGraph callGraph = DependencyAnalysis.getCallGraph();
        if (!callGraph.isCalledMethod(vulnerableClass, vulnerableMethod)) {
            return new ArrayList<>();
        }
        // Then, build the goals composed of context and CD branches on vulnerable line
        return callGraph
                .getAllContextsFromTargetClass(vulnerableClass, vulnerableMethod)
                .stream()
                .filter(cc -> !cc.isEmpty())
                .map(cc -> new VulnerabilityTestFitness(cc, controlDependencies))
                .collect(Collectors.toList());
    }
}
