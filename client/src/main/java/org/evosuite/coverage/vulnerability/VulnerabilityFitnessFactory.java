package org.evosuite.coverage.vulnerability;

import org.evosuite.TestGenerationContext;
import org.evosuite.coverage.branch.Branch;
import org.evosuite.graphs.cfg.BytecodeInstruction;
import org.evosuite.graphs.cfg.BytecodeInstructionPool;
import org.evosuite.setup.CallContext;
import org.evosuite.setup.DependencyAnalysis;
import org.evosuite.setup.callgraph.CallGraph;
import org.evosuite.testsuite.AbstractFitnessFactory;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class VulnerabilityFitnessFactory extends AbstractFitnessFactory<VulnerabilityTestFitness> {
    private static final java.util.logging.Logger logger = java.util.logging.Logger.getLogger(VulnerabilityFitnessFactory.class.getName());

    private String vulnerableClass;
    private String vulnerableMethod;
    private int vulnerableLine;
    private String targetInput;

    public VulnerabilityFitnessFactory() {
        this.vulnerableClass = "com.examples.with.different.packagename.vulnerableoss.VulnerableClassOfLibrary";
        this.vulnerableMethod = "vulnerableMethodOfLibrary(Ljava/lang/String;)V";
        this.vulnerableLine = 17;
        this.targetInput = "badInput123";
    }

    public VulnerabilityFitnessFactory(String vulnerableClass, String vulnerableMethod, int vulnerableLine, String targetInput) {
        this.vulnerableClass = vulnerableClass;
        this.vulnerableMethod = vulnerableMethod;
        this.vulnerableLine = vulnerableLine;
        this.targetInput = targetInput;
    }

    @Override
    public List<VulnerabilityTestFitness> getCoverageGoals() {
        System.out.println("Target Class::Method: " + vulnerableClass + "::" + vulnerableMethod);

        // First check if the vulnerable method is statically called
        CallGraph callGraph = DependencyAnalysis.getCallGraph();
        if (!callGraph.isCalledMethod(vulnerableClass, vulnerableMethod)) {
            System.out.println("\tTarget is never called");
            return new ArrayList<>();
        }

        // Then get all CD branches of vulnerable line
        BytecodeInstructionPool instructionPool = BytecodeInstructionPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT());
        List<BytecodeInstruction> instructionsAtLine = instructionPool
                .getInstructionsIn(vulnerableClass, vulnerableMethod).stream()
                .filter(i -> i.getBasicBlock() != null)
                .filter(i -> i.getLineNumber() == vulnerableLine)
                .collect(Collectors.toList());
        if (instructionsAtLine.size() == 0) {
            System.out.println("\tImpossible!!");
            return new ArrayList<>();
        }
        instructionsAtLine.forEach(i -> System.out.println("\tInstruction at vulnerable line: " + i));
        // Instructions within the same line share the same control dependencies (the CD are of the block), so I can safely take any element
        List<Branch> allCDBranches = getAllCDBranches(instructionsAtLine.get(0));
        allCDBranches.forEach(cd -> System.out.println("\tCD Branch: " + cd));

        // Then, build the goals composed of context and CD branches on vulnerable line
        Set<VulnerabilityTestFitness> goals = new HashSet<>();
        Set<CallContext> contextsFromTargetClass = callGraph.getAllContextsFromTargetClass(vulnerableClass, vulnerableMethod);
        // TODO Convert to Lambda
        for (CallContext context : contextsFromTargetClass) {
            if (!context.isEmpty()) {
                goals.add(new VulnerabilityTestFitness(context, allCDBranches));
            }
        }
        System.out.println("\tThese are the produced goals: ");
        goals.forEach(g -> System.out.println("\t\t" + g));
        System.out.println();
        return new ArrayList<>(goals);
    }

    private List<Branch> getAllCDBranches(BytecodeInstruction instruction) {
        List<Branch> branches = new ArrayList<>();
        if (instruction == null || instruction.getControlDependentBranch() == null) {
            return branches;
        }
        Branch cdBranch = instruction.getControlDependentBranch();
        branches.add(cdBranch);
        branches.addAll(getAllCDBranches(cdBranch.getInstruction()));
        return branches;
    }
}
