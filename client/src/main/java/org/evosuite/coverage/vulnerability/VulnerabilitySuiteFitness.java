package org.evosuite.coverage.vulnerability;

import org.evosuite.testcase.ExecutableChromosome;
import org.evosuite.testcase.TestCase;
import org.evosuite.testcase.TestChromosome;
import org.evosuite.testcase.execution.ExecutionResult;
import org.evosuite.testsuite.AbstractTestSuiteChromosome;
import org.evosuite.testsuite.TestSuiteFitnessFunction;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class VulnerabilitySuiteFitness extends TestSuiteFitnessFunction {
    private static final long serialVersionUID = 42L;
    protected static final Logger logger = LoggerFactory.getLogger(VulnerabilitySuiteFitness.class);

    private final List<VulnerabilityTestFitness> totalGoals = new ArrayList<>();

    public VulnerabilitySuiteFitness() {
        logger.debug("\n## Creation of SuiteFitness ##");
        List<VulnerabilityTestFitness> coverageGoals = new VulnerabilityFitnessFactory().getCoverageGoals();
        //TODO What if coverageGoals is empty?
        totalGoals.addAll(coverageGoals);
    }

    @Override
    public double getFitness(AbstractTestSuiteChromosome<? extends ExecutableChromosome> suite) {
        List<TestChromosome> testChromosomes = (List<TestChromosome>) suite.getTestChromosomes();
        logger.debug("\n#### Suite {} (Gen {}) ####", testChromosomes.stream().map(tc -> tc.getTestCase().getID()).collect(Collectors.toList()), suite.getAge());
        List<ExecutionResult> results = runTestSuite(suite);

        double bestFitness;
        double coverage;
        int numCovered;

        // Empty test suites can occur and should be avoided
        if (testChromosomes.size() == 0) {
            bestFitness = 2;
            coverage = 0;
            numCovered = 0;
        } else {
            // Compute fitness for each pair <goal, TC>
            totalGoals.forEach(goal ->
                    IntStream.range(0, results.size())
                            .forEach(i -> goal.getFitness(testChromosomes.get(i), results.get(i))));

            // Get best fitness for each TC
            List<Double> fitnessValues = testChromosomes.stream()
                    .map(tc -> Collections.min(tc.getFitnessValues().values()))
                    .collect(Collectors.toList());
            logger.debug("\nBest Fitness values for each TC: {}", fitnessValues);

            bestFitness = Collections.min(fitnessValues);
            coverage = bestFitness == 0.0 ? 1 : 0;
            List<TestCase> testCases = testChromosomes.stream().map(TestChromosome::getTestCase).collect(Collectors.toList());
            numCovered = Collections.max(testCases.stream()
                    .map(tc -> tc.getCoveredGoals().size())
                    .collect(Collectors.toList()));
        }
        logger.debug("Suite Best Fitness: {}", bestFitness);
        logger.debug("Suite Coverage: {}", coverage);
        logger.debug("Num Covered Goals: {}", numCovered);

        suite.setNumOfCoveredGoals(this, numCovered);
        suite.setNumOfNotCoveredGoals(this, totalGoals.size() - numCovered);
        suite.setCoverage(this, coverage);
        updateIndividual(this, suite, bestFitness);
        return bestFitness;
    }
}
