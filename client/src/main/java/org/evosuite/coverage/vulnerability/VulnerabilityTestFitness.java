package org.evosuite.coverage.vulnerability;

import org.apache.commons.text.similarity.LevenshteinDistance;
import org.evosuite.coverage.branch.BranchPool;
import org.evosuite.setup.Call;
import org.evosuite.setup.CallContext;
import org.evosuite.testcase.TestCase;
import org.evosuite.testcase.TestChromosome;
import org.evosuite.testcase.TestFitnessFunction;
import org.evosuite.testcase.execution.ExecutionResult;
import org.evosuite.testcase.statements.MethodStatement;
import org.evosuite.testcase.statements.Statement;
import org.evosuite.testcase.statements.StringPrimitiveStatement;
import org.evosuite.testcase.variable.VariableReference;

import java.util.*;
import java.util.stream.Collectors;

public class VulnerabilityTestFitness extends TestFitnessFunction {

    private CallContext targetContext;
    private int targetLine;

    public VulnerabilityTestFitness(CallContext targetContext, int targetLine) {
        this.targetContext = targetContext;
        this.targetLine = targetLine;
    }

    @Override
    public double getFitness(TestChromosome individual, ExecutionResult result) {
        System.out.println("Evaluating Individual " + individual.hashCode());
        System.out.println("\tTest code:");
        result.test.iterator().forEachRemaining(st -> System.out.println("\t\t" + st.getCode()));

        System.out.println("\tAllContextsCounts: ");
        Map<String, Map<CallContext, Integer>> allContextsCounts = result.getTrace().getMethodContextCount();
        allContextsCounts.entrySet().forEach(e -> System.out.println("\t\t" + e));

        // Number of times the target context is employed
        String targetLeafMethodName = getTargetLeafMethodName();
        if (allContextsCounts.get(targetLeafMethodName) == null) {
            System.out.println("\tTarget leaf never reached: fitness set to 1\n");
            updateIndividual(this, individual, 1);
            return 1;
        }
        Integer hits = allContextsCounts.get(targetLeafMethodName).get(targetContext);
        System.out.println("\t# Leaf Hits: " + hits);

        // TODO Is it useful?
        // Remember that rootMethodCall >= calls that employ all the target context
        List<MethodStatement> rootMethodCalls = getRootMethodCalls(result.test);
        if (rootMethodCalls.isEmpty()) {
            System.out.println("Should not happen at this point of code!!!!\n");
            updateIndividual(this, individual, 1);
            return 1;
        }
        System.out.println("\t# Root calls: " + rootMethodCalls.size());

        // TODO Idea: Get the branch of the vulnLine --> Compute approach level to that branch
        // Check BranchPool and ControlFlowDistanceCalculator
        double approachLevel = 0;
        double testFitness = approachLevel;
        updateIndividual(this, individual, testFitness);
        return testFitness;
    }

    private Call getLeafCall() {
        return targetContext.getContext().get(targetContext.getContext().size() - 1);
    }

    private String getTargetLeafMethodName() {
        Call leafCall = getLeafCall();
        return getFullMethodName(leafCall.getClassName(), leafCall.getMethodName());
    }

    private String getTargetLeafClassName() {
        return getLeafCall().getClassName();
    }

    private String getTargetRootMethodName() {
        return getFullMethodName(targetContext.getRootClassName(), targetContext.getRootMethodName());
    }

    private String getFullMethodName(String className, String methodName) {
        return className + "." + methodName;
    }

    private List<MethodStatement> getAllMethodCalls(TestCase test) {
        List<MethodStatement> methodCalls = new ArrayList<>();
        test.iterator().forEachRemaining(s -> {
            if (s instanceof MethodStatement) {
                methodCalls.add((MethodStatement) s);
            }
        });
        return methodCalls;
    }

    private List<MethodStatement> getRootMethodCalls(TestCase test) {
        String targetRootName = getTargetRootMethodName();
        List<MethodStatement> testMethodCalls = getAllMethodCalls(test);
        return testMethodCalls.stream()
                .filter(mc -> (getFullMethodName(mc.getDeclaringClassName(), mc.getMethodName() + mc.getDescriptor())).equals(targetRootName))
                .collect(Collectors.toList());
    }

    /*
    // TODO: There it depends on the specific vulnerability: let's assume it is only one and String
    private double getInputDistance(TestCase test, List<VariableReference> parameters) {
        Statement parameterDef = test.getStatement(parameters.get(0).getStPosition());
        if (parameterDef instanceof StringPrimitiveStatement) {
            StringPrimitiveStatement stringParameterDef = (StringPrimitiveStatement) parameterDef;
            String rootInput = stringParameterDef.getValue();
            System.out.println("\"" + rootInput + "\"");
            // TODO The "comparison" should be based on dataflow and not always based on edit distance
            float editDistance = LevenshteinDistance.getDefaultInstance().apply(rootInput, targetLine+"");
            return editDistance / Math.max(rootInput.length(), targetLine+"".length());
        } else {
            System.out.println("null");
            return targetLine+"" == null ? 0 : 1;
        }
    }
     */

    @Override
    public int compareTo(TestFitnessFunction other) {
        if (other instanceof VulnerabilityTestFitness) {
            VulnerabilityTestFitness that = (VulnerabilityTestFitness) other;
            if (getTargetClass().equals(that.getTargetClass())) {
                return getTargetMethod().compareTo(that.getTargetMethod());
            } else {
                return getTargetClass().compareTo(that.getTargetClass());
            }
        }
        return compareClassName(other);
    }

    @Override
    public int hashCode() {
        return Objects.hash(targetContext, targetLine);
    }

    @Override
    public boolean equals(Object other) {
        if (this == other) return true;
        if (other == null || getClass() != other.getClass()) return false;
        VulnerabilityTestFitness that = (VulnerabilityTestFitness) other;
        return Objects.equals(targetContext, that.targetContext) &&
                Objects.equals(targetLine, that.targetLine);
    }

    @Override
    public String getTargetClass() {
        return this.targetContext.getRootClassName();
    }

    @Override
    public String getTargetMethod() {
        return this.targetContext.getRootMethodName();
    }

    public int getTargetLine() {
        return this.targetLine;
    }

    @Override
    public String toString() {
        return "VulnerabilityTestFitness{" +
                "context=" + targetContext +
                ", targetInput='" + targetLine + '\'' +
                '}';
    }
}
