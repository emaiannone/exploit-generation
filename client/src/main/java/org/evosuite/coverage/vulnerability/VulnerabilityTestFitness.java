package org.evosuite.coverage.vulnerability;

import org.apache.commons.text.similarity.LevenshteinDistance;
import org.evosuite.setup.Call;
import org.evosuite.setup.CallContext;
import org.evosuite.testcase.TestCase;
import org.evosuite.testcase.TestChromosome;
import org.evosuite.testcase.TestFitnessFunction;
import org.evosuite.testcase.execution.ExecutionResult;
import org.evosuite.testcase.statements.MethodStatement;
import org.evosuite.testcase.statements.Statement;
import org.evosuite.testcase.statements.StringPrimitiveStatement;
import org.evosuite.testcase.variable.VariableReference;

import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

public class VulnerabilityTestFitness extends TestFitnessFunction {

    private CallContext targetContext;
    private String targetInput;

    public VulnerabilityTestFitness(CallContext targetContext, String targetInput) {
        this.targetContext = targetContext;
        this.targetInput = targetInput;
        System.out.println("TargetRootName: " + getTargetRootMethodName());
        System.out.println("TargetLeafName: " + getTargetLeafMethodName());
    }

    @Override
    public double getFitness(TestChromosome individual, ExecutionResult result) {
        System.out.println("////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////");
        System.out.println(result.test);

        Map<String, Map<CallContext, Integer>> allContextsCounts = result.getTrace().getMethodContextCount();
        System.out.println("AllContextsCounts: " + allContextsCounts);

        // Number of times the target context is employed
        String targetLeafName = getTargetLeafMethodName();
        if (allContextsCounts.get(targetLeafName) == null) {
            System.out.println("Leaf never reached");
            updateIndividual(this, individual, 1);
            return 1;
        }
        Integer hits = allContextsCounts.get(targetLeafName).get(targetContext);
        System.out.println("# Hits: " + hits);

        // Remember that root methodCall >= call that employ the target context
        List<MethodStatement> rootMethodCalls = getRootMethodCalls(result.test);
        if (rootMethodCalls.isEmpty()) {
            System.out.println("Should not happen at this point of code, but okay");
            updateIndividual(this, individual, 1);
            return 1;
        }
        System.out.println("# Root calls: " + rootMethodCalls.size());

        // TODO: Dataflow analysis improvement:
        // 1. rootInput that approach to employ the target context
        // 2. rootInput that approach to exploit the vulnerability (targetInput)
        double avgInputDistance = 0;
        for (MethodStatement rootMethodCall : rootMethodCalls) {
            System.out.print("RootMethodCall: " + rootMethodCall + " with input ");
            double inputDistance = getInputDistance(result.test, rootMethodCall.getParameterReferences());
            if (inputDistance == 0) {
                System.out.println("EXPLOITED!!!");
                updateIndividual(this, individual, 0);
                return 0;
            }
            avgInputDistance += inputDistance;
        }
        double testFitness = avgInputDistance / rootMethodCalls.size();
        updateIndividual(this, individual, testFitness);
        return testFitness;
    }

    private String getTargetLeafMethodName() {
        Call leafCall = targetContext.getContext().get(targetContext.getContext().size() - 1);
        return getFullMethodName(leafCall.getClassName(), leafCall.getMethodName());
    }

    private String getTargetRootMethodName() {
        return getFullMethodName(targetContext.getRootClassName(), targetContext.getRootMethodName());
    }

    private String getFullMethodName(String className, String methodName) {
        return className + "." + methodName;
    }

    private List<MethodStatement> getAllMethodCalls(TestCase test) {
        List<MethodStatement> methodCalls = new ArrayList<>();
        test.iterator().forEachRemaining(s -> {
            if (s instanceof MethodStatement) {
                methodCalls.add((MethodStatement) s);
            }
        });
        return methodCalls;
    }

    private List<MethodStatement> getRootMethodCalls(TestCase test) {
        String targetRootName = getTargetRootMethodName();
        List<MethodStatement> testMethodCalls = getAllMethodCalls(test);
        return testMethodCalls.stream()
                .filter(mc -> (getFullMethodName(mc.getDeclaringClassName(), mc.getMethodName() + mc.getDescriptor())).equals(targetRootName))
                .collect(Collectors.toList());
    }

    // TODO: There it depends on the specific vulnerability: let's assume it is only one and String
    private double getInputDistance(TestCase test, List<VariableReference> parameters) {
        Statement parameterDef = test.getStatement(parameters.get(0).getStPosition());
        if (parameterDef instanceof StringPrimitiveStatement) {
            StringPrimitiveStatement stringParameterDef = (StringPrimitiveStatement) parameterDef;
            String rootInput = stringParameterDef.getValue();
            System.out.println("\"" + rootInput + "\"");
            // TODO The "comparison" should be based on dataflow and not always based on edit distance
            float editDistance = LevenshteinDistance.getDefaultInstance().apply(rootInput, targetInput);
            return editDistance / Math.max(rootInput.length(), targetInput.length());
        } else {
            System.out.println("null");
            return targetInput == null ? 0 : 1;
        }
    }

    @Override
    public int compareTo(TestFitnessFunction other) {
        if (other instanceof VulnerabilityTestFitness) {
            VulnerabilityTestFitness that = (VulnerabilityTestFitness) other;
            if (getTargetClass().equals(that.getTargetClass())) {
                return getTargetMethod().compareTo(that.getTargetMethod());
            } else {
                return getTargetClass().compareTo(that.getTargetClass());
            }
        }
        return compareClassName(other);
    }

    @Override
    public int hashCode() {
        return Objects.hash(targetContext, targetInput);
    }

    @Override
    public boolean equals(Object other) {
        if (this == other) return true;
        if (other == null || getClass() != other.getClass()) return false;
        VulnerabilityTestFitness that = (VulnerabilityTestFitness) other;
        return Objects.equals(targetContext, that.targetContext) &&
                Objects.equals(targetInput, that.targetInput);
    }

    @Override
    public String getTargetClass() {
        return this.targetContext.getRootClassName();
    }

    @Override
    public String getTargetMethod() {
        return this.targetContext.getRootMethodName();
    }

    public String getTargetInput() {
        return this.targetInput;
    }

    @Override
    public String toString() {
        return "VulnerabilityTestFitness{" +
                "context=" + targetContext +
                ", targetInput='" + targetInput + '\'' +
                '}';
    }
}
