package org.evosuite.coverage.vulnerability;

import org.evosuite.coverage.branch.ControlFlowDistanceCalculator;
import org.evosuite.graphs.cfg.ControlDependency;
import org.evosuite.setup.Call;
import org.evosuite.setup.CallContext;
import org.evosuite.testcase.TestChromosome;
import org.evosuite.testcase.TestFitnessFunction;
import org.evosuite.testcase.execution.ExecutionResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.stream.Collectors;

// TODO 09/03/2020: Improvement idea: targetCDs for each method in target call context. So that the problem will reduced to a "deep" path coverage one, so using only the approachlevel computation
public class VulnerabilityTestFitness extends TestFitnessFunction {
    private static final long serialVersionUID = 42L;
    protected static final Logger logger = LoggerFactory.getLogger(VulnerabilityTestFitness.class);
    private final CallContext targetContext;
    // Transient to avoid RMI exception because there is a ClassLoader (inside the object structure) and it is not serializable
    // an alternative is to remove transient here and put it into ClassLoader field in ByteCodeInstruction and BasicBlock classes.
    // Other solutions might be good
    private final transient List<ControlDependency> targetControlDependencies;

    public VulnerabilityTestFitness(CallContext targetContext, List<ControlDependency> targetControlDependencies) {
        this.targetContext = targetContext;
        this.targetControlDependencies = targetControlDependencies;
    }

    @Override
    public double getFitness(TestChromosome individual, ExecutionResult result) {
        System.out.println("Evaluating Individual " + individual.hashCode());
        System.out.println("\tTest code:");
        result.test.iterator().forEachRemaining(st -> System.out.println("\t\t" + st.getCode()));

        // Check if the target context is employed is in the set of (distinct) executed contexts
        Map<String, Map<CallContext, Integer>> executedContexts = result.getTrace().getMethodContextCount();
        Set<CallContext> distinctContexts = extractDistinctContexts(executedContexts);
        System.out.println("\tExecuted contexts: ");
        executedContexts.entrySet().forEach(e -> System.out.println("\t\t" + e));
        System.out.println("\tDistinct contexts: ");
        distinctContexts.forEach(e -> System.out.println("\t\t" + e));

        // TODO: Improve the fitness function in both cases
        double fitness;
        if (!distinctContexts.contains(targetContext)) {
            System.out.println("\tTarget context NOT executed! Starts Computing Best Context Similarity");
            double bestContextSimilarity = computeBestContextSimilarity(distinctContexts, targetContext);
            System.out.println("\tBest CS: " + bestContextSimilarity);
            // The fitness rewards the best matches of the target context
            fitness = 2 - bestContextSimilarity;
        } else {
            System.out.println("\tTarget context executed! Starts Computing Approach Level");
            if (targetControlDependencies.size() == 0) {
                fitness = 0;
            } else {
                int approachLevel = computeApproachLevel(result, targetControlDependencies, targetContext);
                System.out.println("\tAL: " + approachLevel);
                // The fitness rewards the closest execution trace
                fitness = (double) approachLevel / (double) targetControlDependencies.size();
            }
        }
        System.out.println("\tFitness: " + fitness);
        updateIndividual(this, individual, fitness);
        if (fitness == 0.0) {
            System.out.println("\tGoal Covered!!");
            individual.getTestCase().addCoveredGoal(this);
        }
        return fitness;
    }

    /**
     * Helper method that converts the map of call context into a simple set, removing hit number
     *
     * @param contextsMap map of all call contexts to convert
     * @return set of call context composed only with the keys of the inner map
     */
    private static Set<CallContext> extractDistinctContexts(Map<String, Map<CallContext, Integer>> contextsMap) {
        return contextsMap
                .entrySet()
                .stream()
                .flatMap(entry -> entry.getValue().keySet().stream())
                .collect(Collectors.toSet());
    }

    /**
     * Helper method that compute the best (greatest) context similarity between a set of call contexts in respect to a target call context.
     * See {@link #computeContextSimilarity(CallContext, CallContext)} for getting a single context similarity.
     *
     * @param distinctContexts the set of list of method call to check the similarity for and get the greatest one
     * @param targetContext    the list of method calls used as a reference
     * @return a value between 0 and 1. The bigger, the greater the number of matched with 1 meaning perfect match.
     */
    private static double computeBestContextSimilarity(Set<CallContext> distinctContexts, CallContext targetContext) {
        System.out.println("\tComputing Best Context Similarity in respect to: " + targetContext);
        Set<Double> CALs = distinctContexts.stream()
                .map(callContext -> computeContextSimilarity(callContext, targetContext))
                .collect(Collectors.toSet());
        Optional<Double> bestCAL = CALs.stream().max(Comparator.naturalOrder());
        return bestCAL.orElse(0.0);
    }

    /**
     * Helper method that compute the context similarity of a call context in respect to a target call context.
     * The context similarity is the number of matched method calls divided the total number of methods in the target.
     *
     * @param callContext   the list of method calls to check the similarity for
     * @param targetContext the list of method calls used as a reference
     * @return a value between 0 and 1. The bigger, the greater the number of matched with 1 meaning perfect match.
     */
    private static double computeContextSimilarity(CallContext callContext, CallContext targetContext) {
        System.out.println("\t\tChecking: " + callContext);
        Iterator<Call> currentIter = callContext.getContext().iterator();
        Iterator<Call> targetIter = targetContext.getContext().iterator();
        int matchNum = 0;
        boolean matched = true;
        while (matched && currentIter.hasNext() && targetIter.hasNext()) {
            Call currentCall = currentIter.next();
            Call targetCall = targetIter.next();
            matched = currentCall.equals(targetCall);
            if (matched) {
                matchNum++;
            }
        }
        double contextSimilarity = (double) matchNum / targetContext.getContext().size();
        System.out.println("\t\t\tContext Similarity: " + matchNum + " / " + targetContext.getContext().size() + " = " + contextSimilarity);
        return contextSimilarity;
    }

    /**
     * Helper method that computes the approach level of the execution result in respect to a list of control dependencies and a call context.
     * The approach level is the number of control dependencies to be passed to pass on the deepest one.
     *
     * @param result                    Execution result to be checked
     * @param targetControlDependencies list of control dependencies to cover, from the deepest to the shallowest.
     * @param targetContext             belonging call context
     * @return an non negative int corresponding to the approach level. If the result does not cover the targetContext the maximum inter-procedural depth is returned (CFG diameter)
     */
    private static int computeApproachLevel(ExecutionResult result, List<ControlDependency> targetControlDependencies, CallContext targetContext) {
        List<ControlDependency> reverseCDs = new ArrayList<>(targetControlDependencies);
        Collections.reverse(reverseCDs);
        String className = getLeafCall(targetContext).getClassName();
        String methodName = getLeafCall(targetContext).getMethodName();

        System.out.println("\tComputing ApproachLevel for (from shallowest): " + reverseCDs);
        System.out.println("\t\tTrue Branch IDs (ELSE): " + result.getTrace().getCoveredTrueBranches());
        System.out.println("\t\tFalse Branch IDs (THEN): " + result.getTrace().getCoveredFalseBranches());

        List<Integer> strangeDistances = reverseCDs.stream()
                .map(cd -> ControlFlowDistanceCalculator.getDistance(result, cd.getBranch(), cd.getBranchExpressionValue(), className, methodName).getApproachLevel())
                .collect(Collectors.toList());
        List<Integer> distances = fixDistances(strangeDistances);
        int approachLevel = distances.get(distances.size() - 1);

        System.out.println("\t\tStrange Distances: " + strangeDistances);
        System.out.println("\t\tOkay Distances: " + distances);
        return approachLevel;
    }

    /**
     * Returns the last method call of the given context
     *
     * @param context The call context
     * @return the last method call of the given context
     */
    private static Call getLeafCall(CallContext context) {
        List<Call> calls = context.getContext();
        return calls.get(calls.size() - 1);
    }

    /**
     * This method fixes the list of approach levels returned by the class {@link ControlFlowDistanceCalculator}
     * because it returns the depth of the intra-procedural CFD for uncovered branches, while 0 for covered branches.
     * This method will become useless as soon as {@link ControlFlowDistanceCalculator} is fixed.
     *
     * @param brokenDistances list of "approach levels" (that are depth level actually) as returned by the class {@link ControlFlowDistanceCalculator}
     * @return list of same approach levels but respecting the definition
     */
    private static List<Integer> fixDistances(List<Integer> brokenDistances) {
        List<Integer> fixedDistances = new ArrayList<>(brokenDistances);
        int i = 0;
        while (i < fixedDistances.size() && fixedDistances.get(i) == 0) {
            i++;
        }
        for (int j = i; j < fixedDistances.size(); j++) {
            fixedDistances.set(j, fixedDistances.get(j) - i);
        }
        return fixedDistances;
    }

    @Override
    public int compareTo(TestFitnessFunction other) {
        if (other instanceof VulnerabilityTestFitness) {
            VulnerabilityTestFitness that = (VulnerabilityTestFitness) other;
            if (getTargetClass().equals(that.getTargetClass())) {
                return getTargetMethod().compareTo(that.getTargetMethod());
            } else {
                return getTargetClass().compareTo(that.getTargetClass());
            }
        }
        return compareClassName(other);
    }

    @Override
    public int hashCode() {
        return Objects.hash(targetContext, targetControlDependencies);
    }

    @Override
    public boolean equals(Object other) {
        if (this == other) return true;
        if (other == null || getClass() != other.getClass()) return false;
        VulnerabilityTestFitness that = (VulnerabilityTestFitness) other;
        return Objects.equals(targetContext, that.targetContext) &&
                Objects.equals(targetControlDependencies, that.targetControlDependencies);
    }

    @Override
    public String getTargetClass() {
        return this.targetContext.getRootClassName();
    }

    @Override
    public String getTargetMethod() {
        return this.targetContext.getRootMethodName();
    }

    public List<ControlDependency> getTargetControlDependencies() {
        return this.targetControlDependencies;
    }

    @Override
    public String toString() {
        return "VulnerabilityTestFitness{" +
                "targetContext=" + targetContext +
                ", targetCDBranches='" + targetControlDependencies + '\'' +
                '}';
    }
}
