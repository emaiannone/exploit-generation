package org.evosuite.coverage.vulnerability;

import org.evosuite.coverage.branch.Branch;
import org.evosuite.setup.Call;
import org.evosuite.setup.CallContext;
import org.evosuite.testcase.TestCase;
import org.evosuite.testcase.TestChromosome;
import org.evosuite.testcase.TestFitnessFunction;
import org.evosuite.testcase.execution.ExecutionResult;
import org.evosuite.testcase.statements.MethodStatement;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

public class VulnerabilityTestFitness extends TestFitnessFunction {

    private CallContext targetContext;
    private List<Branch> targetCDBranches;

    public VulnerabilityTestFitness(CallContext targetContext, List<Branch> targetCDBranches) {
        this.targetContext = targetContext;
        this.targetCDBranches = targetCDBranches;
    }

    @Override
    public double getFitness(TestChromosome individual, ExecutionResult result) {
        System.out.println("Evaluating Individual " + individual.hashCode());
        System.out.println("\tTest code:");
        result.test.iterator().forEachRemaining(st -> System.out.println("\t\t" + st.getCode()));

        System.out.println("\tAllContextsCounts: ");
        Map<String, Map<CallContext, Integer>> allContextsCounts = result.getTrace().getMethodContextCount();
        allContextsCounts.entrySet().forEach(e -> System.out.println("\t\t" + e));

        // Number of times the target context is employed
        double testFitness = 1;
        String targetLeafMethodName = getTargetLeafMethodName();
        if (allContextsCounts.get(targetLeafMethodName) == null) {
            System.out.println("\tTarget leaf never reached");

            // TODO Fitness according to contextApproachLevel: computeContextApproachLevel
            double contextApproachLevel = 1;
            testFitness = contextApproachLevel;
        } else {
            Integer hits = allContextsCounts.get(targetLeafMethodName).get(targetContext);
            System.out.println("\t# Leaf Hits: " + hits);

            // TODO: Fitness according to branchApproachLevel: computeBranchApproachLevel
            double branchApproachLevel = 1;
            testFitness = branchApproachLevel;
        }
        System.out.println();
        updateIndividual(this, individual, testFitness);
        return testFitness;
    }

    private Call getLeafCall() {
        return targetContext.getContext().get(targetContext.getContext().size() - 1);
    }

    private String getTargetLeafMethodName() {
        Call leafCall = getLeafCall();
        return getFullMethodName(leafCall.getClassName(), leafCall.getMethodName());
    }

    private String getTargetLeafClassName() {
        return getLeafCall().getClassName();
    }

    private String getTargetRootMethodName() {
        return getFullMethodName(targetContext.getRootClassName(), targetContext.getRootMethodName());
    }

    private String getFullMethodName(String className, String methodName) {
        return className + "." + methodName;
    }

    private List<MethodStatement> getAllMethodCalls(TestCase test) {
        List<MethodStatement> methodCalls = new ArrayList<>();
        test.iterator().forEachRemaining(s -> {
            if (s instanceof MethodStatement) {
                methodCalls.add((MethodStatement) s);
            }
        });
        return methodCalls;
    }

    private List<MethodStatement> getRootMethodCalls(TestCase test) {
        String targetRootName = getTargetRootMethodName();
        List<MethodStatement> testMethodCalls = getAllMethodCalls(test);
        return testMethodCalls.stream()
                .filter(mc -> (getFullMethodName(mc.getDeclaringClassName(), mc.getMethodName() + mc.getDescriptor())).equals(targetRootName))
                .collect(Collectors.toList());
    }

    private double computeContextApproachLevel(CallContext targetContext, CallContext actualContext) {
        return 1;
    }

    private double computeBranchApproachLevel(List<Branch> targetCDBranches, List<Branch> actualCDBranches) {
        return 1;
    }

    /*
    // TODO: There it depends on the specific vulnerability: let's assume it is only one and String
    private double getInputDistance(TestCase test, List<VariableReference> parameters) {
        Statement parameterDef = test.getStatement(parameters.get(0).getStPosition());
        if (parameterDef instanceof StringPrimitiveStatement) {
            StringPrimitiveStatement stringParameterDef = (StringPrimitiveStatement) parameterDef;
            String rootInput = stringParameterDef.getValue();
            System.out.println("\"" + rootInput + "\"");
            // TODO The "comparison" should be based on dataflow and not always based on edit distance
            float editDistance = LevenshteinDistance.getDefaultInstance().apply(rootInput, targetLine+"");
            return editDistance / Math.max(rootInput.length(), targetLine+"".length());
        } else {
            System.out.println("null");
            return targetLine+"" == null ? 0 : 1;
        }
    }
     */

    @Override
    public int compareTo(TestFitnessFunction other) {
        if (other instanceof VulnerabilityTestFitness) {
            VulnerabilityTestFitness that = (VulnerabilityTestFitness) other;
            if (getTargetClass().equals(that.getTargetClass())) {
                return getTargetMethod().compareTo(that.getTargetMethod());
            } else {
                return getTargetClass().compareTo(that.getTargetClass());
            }
        }
        return compareClassName(other);
    }

    @Override
    public int hashCode() {
        return Objects.hash(targetContext, targetCDBranches);
    }

    @Override
    public boolean equals(Object other) {
        if (this == other) return true;
        if (other == null || getClass() != other.getClass()) return false;
        VulnerabilityTestFitness that = (VulnerabilityTestFitness) other;
        return Objects.equals(targetContext, that.targetContext) &&
                Objects.equals(targetCDBranches, that.targetCDBranches);
    }

    @Override
    public String getTargetClass() {
        return this.targetContext.getRootClassName();
    }

    @Override
    public String getTargetMethod() {
        return this.targetContext.getRootMethodName();
    }

    public List<Branch> getTargetCDBranches() {
        return this.targetCDBranches;
    }

    @Override
    public String toString() {
        return "VulnerabilityTestFitness{" +
                "targetContext=" + targetContext +
                ", targetCDBranches='" + targetCDBranches + '\'' +
                '}';
    }
}
