package org.evosuite.coverage.vulnerability;

import org.evosuite.graphs.cfg.ControlDependency;
import org.evosuite.setup.Call;
import org.evosuite.setup.CallContext;
import org.evosuite.testcase.TestChromosome;
import org.evosuite.testcase.TestFitnessFunction;
import org.evosuite.testcase.execution.ExecutionResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MarkerFactory;

import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

public class VulnerabilityTestFitness extends TestFitnessFunction {
    private static final long serialVersionUID = 42L;
    protected static final Logger logger = LoggerFactory.getLogger(VulnerabilityTestFitness.class);

    private final VulnerabilityGoal vulnerabilityGoal;

    public VulnerabilityTestFitness(int id, CallContext targetContext, List<ControlDependency> targetControlNodes, int targetLine) {
        this.vulnerabilityGoal = new VulnerabilityGoal(id, targetContext, targetControlNodes, targetLine);
    }

    @Override
    public double getFitness(TestChromosome individual, ExecutionResult result) {
        logger.debug(MarkerFactory.getMarker("time"), "\n### Goal {} - TC {} (Gen {}, Eval {}) ###", vulnerabilityGoal.getId(), individual.getTestCase().getID(), individual.getAge(), individual.getNumberOfEvaluations());
        logger.debug("Test Code:");
        individual.getTestCase().iterator().forEachRemaining(st -> logger.debug("\t{}", st.getCode()));

        // Extract the distinct contexts and consider only the one rooted in target class and method (the others are useless)
        Set<CallContext> contextsRootedInTarget = result.getTrace().getMethodContextCount().entrySet()
                .stream()
                .flatMap(entry -> entry.getValue().keySet().stream())
                .filter(ctx -> ctx.getRootClassName().equals(vulnerabilityGoal.getTargetContext().getRootClassName()))
                .filter(ctx -> ctx.getRootMethodName().equals(vulnerabilityGoal.getTargetContext().getRootMethodName()))
                .collect(Collectors.toSet());

        double fitness;
        if (!contextsRootedInTarget.contains(vulnerabilityGoal.getTargetContext())) {
            logger.debug("Target context NOT executed... computing Best Context Similarity (CS) with {}", vulnerabilityGoal.getTargetContext());
            double bestContextSimilarity = contextsRootedInTarget.stream()
                    .map(callContext -> new ContextSimilarityCalculator(callContext, vulnerabilityGoal.getTargetContext()).compute())
                    .max(Comparator.naturalOrder()).orElse(0.0);
            logger.debug("\tBest CS: {}", bestContextSimilarity);
            // The fitness rewards the best matches of the target context
            fitness = 3.0 - bestContextSimilarity;
        } else {
            logger.debug("Target context IS executed... computing Approach Level (AL) with {}", vulnerabilityGoal.getTargetControlNodes());
            int approachLevel = new ApproachLevelCalculator(result, vulnerabilityGoal.getTargetControlNodes(), vulnerabilityGoal.getTargetContext()).compute();
            logger.debug("\tAL: {}", approachLevel);
            if (approachLevel != 0) {
                logger.debug("Target control nodes NOT fully covered");
                // TODO: Consider adding branch distance for a better fitness formula
                fitness = 2.0 - ((double) vulnerabilityGoal.getTargetControlNodes().size() - approachLevel) / vulnerabilityGoal.getTargetControlNodes().size();
            } else {
                if (vulnerabilityGoal.getTargetControlNodes().size() == 0) {
                    logger.debug("There are no control nodes on target line... checking if target line {} is covered", vulnerabilityGoal.getTargetLine());
                } else {
                    logger.debug("Target control nodes ARE covered... checking if target line {} is covered", vulnerabilityGoal.getTargetLine());
                }
                List<Call> calls = vulnerabilityGoal.getTargetContext().getContext();
                Call leafCall = calls.get(calls.size() - 1);
                Set<Integer> coveredLines = result.getTrace().getCoverageData()
                        .get(leafCall.getClassName())
                        .get(leafCall.getMethodName())
                        .keySet();
                logger.debug("\tCovered lines in target method: {}", coveredLines);
                if (!coveredLines.contains(vulnerabilityGoal.getTargetLine())) {
                    int closestLine = coveredLines.stream()
                            .filter(line -> line < vulnerabilityGoal.getTargetLine())
                            .max(Comparator.naturalOrder()).orElse(-1);
                    logger.debug("\tMissing {} lines", vulnerabilityGoal.getTargetLine() - closestLine);
                    logger.debug("Line NOT covered");
                    int firstLine = coveredLines.stream().min(Comparator.naturalOrder()).orElse(-1);
                    fitness = 1.0 - (float) (closestLine - firstLine + 1) / (vulnerabilityGoal.getTargetLine() - firstLine + 1);
                } else {
                    logger.debug("Line IS covered");
                    fitness = 0.0;
                }
            }
        }
        logger.debug("TC Fitness: {}", fitness);
        updateIndividual(this, individual, fitness);
        if (fitness == 0.0) {
            logger.debug("\tGoal IS covered!");
            individual.getTestCase().addCoveredGoal(this);
            individual.setCoverage(this, 1);
        }
        return fitness;
    }

    @Override
    public int compareTo(TestFitnessFunction other) {
        if (other instanceof VulnerabilityTestFitness) {
            VulnerabilityTestFitness that = (VulnerabilityTestFitness) other;
            if (getTargetClass().equals(that.getTargetClass())) {
                return getTargetMethod().compareTo(that.getTargetMethod());
            } else {
                return getTargetClass().compareTo(that.getTargetClass());
            }
        }
        return compareClassName(other);
    }

    @Override
    public int hashCode() {
        return Objects.hash(vulnerabilityGoal);
    }

    @Override
    public boolean equals(Object other) {
        if (this == other) return true;
        if (other == null || getClass() != other.getClass()) return false;
        VulnerabilityTestFitness that = (VulnerabilityTestFitness) other;
        return Objects.equals(vulnerabilityGoal, that.vulnerabilityGoal);
    }

    @Override
    public String getTargetClass() {
        return this.vulnerabilityGoal.getTargetContext().getRootClassName();
    }

    @Override
    public String getTargetMethod() {
        return this.vulnerabilityGoal.getTargetContext().getRootMethodName();
    }

    @Override
    public String toString() {
        return "VulnerabilityTestFitness{" +
                "vulnerabilityGoal=" + vulnerabilityGoal +
                '}';
    }
}
