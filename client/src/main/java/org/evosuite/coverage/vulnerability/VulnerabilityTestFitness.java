package org.evosuite.coverage.vulnerability;

import org.evosuite.TestGenerationContext;
import org.evosuite.coverage.branch.Branch;
import org.evosuite.coverage.branch.BranchPool;
import org.evosuite.coverage.branch.ControlFlowDistanceCalculator;
import org.evosuite.graphs.cfg.ControlDependency;
import org.evosuite.setup.Call;
import org.evosuite.setup.CallContext;
import org.evosuite.testcase.TestChromosome;
import org.evosuite.testcase.TestFitnessFunction;
import org.evosuite.testcase.execution.ExecutionResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MarkerFactory;

import java.util.*;
import java.util.stream.Collectors;

public class VulnerabilityTestFitness extends TestFitnessFunction {
    private static final long serialVersionUID = 42L;
    protected static final Logger logger = LoggerFactory.getLogger(VulnerabilityTestFitness.class);

    private final int id;
    private final CallContext targetContext;
    // To avoid an RMI exception (due to a ClassLoader object inside the entire structure), this field has been made transient.
    // An alternative would be put transient keyword into the ClassLoader field in ByteCodeInstruction and BasicBlock classes.
    // Other solutions are well accepted
    private final transient List<ControlDependency> targetControlDependencies;
    private final int targetLine;

    public VulnerabilityTestFitness(int id, CallContext targetContext, List<ControlDependency> targetControlDependencies, int targetLine) {
        this.id = id;
        if (targetContext == null || targetControlDependencies == null || targetLine == 0) {
            throw new IllegalArgumentException("Invalid target call context, control dependencies or line");
        }
        this.targetContext = targetContext;
        this.targetControlDependencies = targetControlDependencies;
        this.targetLine = targetLine;
    }

    @Override
    public double getFitness(TestChromosome individual, ExecutionResult result) {
        logger.debug(MarkerFactory.getMarker("time"), "\n### Goal {} - TC {} ###", this.id, individual.getTestCase().getID());
        logger.debug("Test Code:");
        individual.getTestCase().iterator().forEachRemaining(st -> logger.debug("\t{}", st.getCode()));

        //TODO inline extractDistinctContexts() with this commented code
        /*
        Set<CallContext> contextsRootedInTarget = result.getTrace().getMethodContextCount().entrySet()
                .stream()
                .flatMap(entry -> entry.getValue().keySet().stream())
                .filter(ctx -> ctx.getRootClassName().equals(targetContext.getRootClassName()))
                .filter(ctx -> ctx.getRootMethodName().equals(targetContext.getRootMethodName()))
                .collect(Collectors.toSet());
         */
        // Extract the distinct contexts and consider only the one rooted in target class and method (the others are useless)
        Set<CallContext> contextsRootedInTarget = extractDistinctContexts(result.getTrace().getMethodContextCount())
                .stream()
                .filter(ctx -> ctx.getRootClassName().equals(targetContext.getRootClassName()))
                .filter(ctx -> ctx.getRootMethodName().equals(targetContext.getRootMethodName()))
                .collect(Collectors.toSet());

        double fitness;
        if (!contextsRootedInTarget.contains(targetContext)) {
            logger.debug("Target context NOT executed... computing Best Context Similarity (CS) with {}", targetContext);
            //TODO: Inline computeBestContextSimilarity() only
            double bestContextSimilarity = computeBestContextSimilarity(contextsRootedInTarget, targetContext);
            logger.debug("\tBest CS: {}", bestContextSimilarity);
            // The fitness rewards the best matches of the target context
            fitness = 3.0 - bestContextSimilarity;
        } else {
            logger.debug("Target context IS executed... computing Approach Level (AL) with {}", targetControlDependencies);
            int approachLevel = computeApproachLevel(result, targetControlDependencies, targetContext);
            logger.debug("\tAL: {}", approachLevel);
            if (approachLevel != 0) {
                logger.debug("Target control dependencies NOT fully covered");
                // TODO: Consider adding branch distance for a better fitness formula
                fitness = 2.0 - ((double) targetControlDependencies.size() - approachLevel) / targetControlDependencies.size();
            } else {
                if (targetControlDependencies.size() == 0) {
                    logger.debug("There are no control dependencies on target line... checking if target line {} is covered", targetLine);
                } else {
                    logger.debug("Target control dependencies ARE covered... checking if target line {} is covered", targetLine);
                }
                List<Call> calls = targetContext.getContext();
                Call leafCall = calls.get(calls.size() - 1);
                Set<Integer> coveredLines = result.getTrace().getCoverageData()
                        .get(leafCall.getClassName())
                        .get(leafCall.getMethodName())
                        .keySet();
                logger.debug("\tCovered lines in target method: {}", coveredLines);
                if (!coveredLines.contains(targetLine)) {
                    Set<Integer> priorLines = coveredLines.stream()
                            .filter(line -> line < targetLine)
                            .collect(Collectors.toSet());
                    int closestLine = priorLines.stream().max(Comparator.naturalOrder()).orElse(-1);
                    logger.debug("\tMissing {} lines", targetLine - closestLine);
                    logger.debug("Line NOT covered");
                    //TODO: Too harsh?
                    int firstLine = coveredLines.stream().min(Comparator.naturalOrder()).orElse(-1);
                    fitness = 1.0 - (float) (closestLine - firstLine + 1) / (targetLine - firstLine + 1);
                } else {
                    logger.debug("Line IS covered!");
                    fitness = 0.0;
                }
            }
        }
        logger.debug("TC Fitness: {}", fitness);
        updateIndividual(this, individual, fitness);
        if (fitness == 0.0) {
            logger.debug("\tGoal IS covered!");
            individual.getTestCase().addCoveredGoal(this);
        }
        return fitness;
    }

    /**
     * Helper method that converts the map of call context into a simple set, removing hit number
     *
     * @param contextsMap map of all call contexts to convert
     * @return set of call context composed only with the keys of the inner map
     */
    private static Set<CallContext> extractDistinctContexts(Map<String, Map<CallContext, Integer>> contextsMap) {
        return contextsMap
                .entrySet()
                .stream()
                .flatMap(entry -> entry.getValue().keySet().stream())
                .collect(Collectors.toSet());
    }

    /**
     * Helper method that compute the best (greatest) context similarity between a set of call contexts in respect to a target call context.
     * See {@link #computeContextSimilarity(CallContext, CallContext)} for getting a single context similarity.
     *
     * @param distinctContexts the set of list of method call to check the similarity for and get the greatest one
     * @param targetContext    the list of method calls used as a reference
     * @return a value between 0 and 1. The bigger, the greater the number of matched with 1 meaning perfect match.
     */
    private static double computeBestContextSimilarity(Set<CallContext> distinctContexts, CallContext targetContext) {
        Set<Double> CALs = distinctContexts.stream()
                .map(callContext -> computeContextSimilarity(callContext, targetContext))
                .collect(Collectors.toSet());
        return CALs.stream().max(Comparator.naturalOrder()).orElse(0.0);
    }

    //TODO: It may go into a dedicated class: Replace Method with Method Object refactoring
    /**
     * Helper method that compute the context similarity of a call context in respect to a target call context.
     * The context similarity is the number of matched method calls divided the total number of methods in the target.
     *
     * @param callContext   the list of method calls to check the similarity for
     * @param targetContext the list of method calls used as a reference
     * @return a value between 0 and 1. The bigger, the greater the number of matched with 1 meaning perfect match.
     */
    private static double computeContextSimilarity(CallContext callContext, CallContext targetContext) {
        Iterator<Call> currentIter = callContext.getContext().iterator();
        Iterator<Call> targetIter = targetContext.getContext().iterator();
        int matchNum = 0;
        boolean matched = true;
        while (matched && currentIter.hasNext() && targetIter.hasNext()) {
            Call currentCall = currentIter.next();
            Call targetCall = targetIter.next();
            matched = currentCall.equals(targetCall);
            if (matched) {
                matchNum++;
            }
        }
        double contextSimilarity = (double) matchNum / targetContext.getContext().size();
        logger.debug("\t{} / {} = {} of {}", matchNum, targetContext.getContext().size(), contextSimilarity, callContext);
        return contextSimilarity;
    }

    //TODO: It may go into a dedicated class: Replace Method with Method Object refactoring
    /**
     * Helper method that computes the approach level of the execution result in respect to a list of control dependencies and a call context.
     * The approach level is the number of control dependencies to be passed to pass on the deepest one.
     *
     * @param result                    Execution result to be checked
     * @param targetControlDependencies list of control dependencies to cover, from the deepest to the shallowest.
     * @param targetContext             belonging call context
     * @return an non negative int corresponding to the approach level. If the result does not cover the targetContext the maximum inter-procedural depth is returned (CFG diameter)
     */
    private static int computeApproachLevel(ExecutionResult result, List<ControlDependency> targetControlDependencies, CallContext targetContext) {
        List<Call> calls = targetContext.getContext();
        Call leafCall = calls.get(calls.size() - 1);
        String className = leafCall.getClassName();
        String methodName = leafCall.getMethodName();

        List<Branch> branches = result.getTrace().getCoveredPredicates()
                .stream()
                .map(id -> BranchPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getBranch(id))
                .collect(Collectors.toList());
        // ALL branches from the target class to vulnerable one (in reverse)
        logger.debug("\tAll evaluated branches: {}", branches);
        logger.debug("\tTrue branches: {}", result.getTrace().getCoveredTrueBranches());
        logger.debug("\tFalse branches: {}", result.getTrace().getCoveredFalseBranches());

        // These values are odd, see Javadoc of fixDistances() method
        List<Integer> controlFlowDistances = targetControlDependencies.stream()
                .map(cd -> ControlFlowDistanceCalculator.getDistance(result, cd.getBranch(), cd.getBranchExpressionValue(), className, methodName).getApproachLevel())
                .collect(Collectors.toList());
        logger.debug("\tControl Flow Distances: {}", controlFlowDistances);
        return (int) controlFlowDistances.stream().filter(sd -> sd != 0).count();
    }

    @Override
    public int compareTo(TestFitnessFunction other) {
        if (other instanceof VulnerabilityTestFitness) {
            VulnerabilityTestFitness that = (VulnerabilityTestFitness) other;
            if (getTargetClass().equals(that.getTargetClass())) {
                return getTargetMethod().compareTo(that.getTargetMethod());
            } else {
                return getTargetClass().compareTo(that.getTargetClass());
            }
        }
        return compareClassName(other);
    }

    @Override
    public int hashCode() {
        return Objects.hash(targetContext, targetControlDependencies);
    }

    @Override
    public boolean equals(Object other) {
        if (this == other) return true;
        if (other == null || getClass() != other.getClass()) return false;
        VulnerabilityTestFitness that = (VulnerabilityTestFitness) other;
        return Objects.equals(targetContext, that.targetContext) &&
                Objects.equals(targetControlDependencies, that.targetControlDependencies);
    }

    @Override
    public String getTargetClass() {
        return this.targetContext.getRootClassName();
    }

    @Override
    public String getTargetMethod() {
        return this.targetContext.getRootMethodName();
    }

    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return "VulnerabilityTestFitness{" +
                "targetContext=" + targetContext +
                ", targetCDBranches='" + targetControlDependencies + '\'' +
                ", targetLine=" + targetLine +
                '}';
    }
}
