package org.evosuite.coverage.vulnerability;

import org.evosuite.TestGenerationContext;
import org.evosuite.coverage.branch.Branch;
import org.evosuite.coverage.branch.BranchPool;
import org.evosuite.coverage.branch.ControlFlowDistanceCalculator;
import org.evosuite.graphs.cfg.ControlDependency;
import org.evosuite.setup.Call;
import org.evosuite.setup.CallContext;
import org.evosuite.testcase.execution.ExecutionResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Helper class that computes the approach level of the execution result in respect to a list of control dependencies and a call context.
 * The approach level is the number of control dependencies to be passed to pass on the deepest one.
 */
class ApproachLevelCalculator {
    /**
     * Execution result to be checked
     */
    private final ExecutionResult result;
    /**
     * List of control dependencies to cover, from the deepest to the shallowest
     */
    private final List<ControlDependency> targetControlDependencies;
    /**
     * Belonging call context
     */
    private final CallContext targetContext;
    protected static final Logger logger = LoggerFactory.getLogger(ApproachLevelCalculator.class);

    ApproachLevelCalculator(ExecutionResult result, List<ControlDependency> targetControlDependencies, CallContext targetContext) {
        this.result = result;
        this.targetControlDependencies = targetControlDependencies;
        this.targetContext = targetContext;
    }

    /**
     * Computes the approach level of the execution result in respect to a list of control dependencies and a call context.
     * The approach level is the number of control dependencies to be passed to pass on the deepest one.
     *
     * @return an non negative int corresponding to the approach level. If the result does not cover the targetContext the maximum inter-procedural depth is returned (CFG diameter)
     */
    int compute() {
        List<Call> calls = targetContext.getContext();
        Call leafCall = calls.get(calls.size() - 1);
        String className = leafCall.getClassName();
        String methodName = leafCall.getMethodName();

        List<Branch> branches = result.getTrace().getCoveredPredicates()
                .stream()
                .map(id -> BranchPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getBranch(id))
                .collect(Collectors.toList());
        // ALL branches from the target class to vulnerable one (in reverse)
        logger.debug("\tAll evaluated branches: {}", branches);
        logger.debug("\tTrue branches: {}", result.getTrace().getCoveredTrueBranches());
        logger.debug("\tFalse branches: {}", result.getTrace().getCoveredFalseBranches());

        // These distances are 0 if a control dependency was covered, otherwise it is its depth.
        // We don't care about the depth: the number of non-zero distances is the approach level.
        List<Integer> controlFlowDistances = targetControlDependencies.stream()
                .map(cd -> ControlFlowDistanceCalculator.getDistance(result, cd.getBranch(), cd.getBranchExpressionValue(), className, methodName).getApproachLevel())
                .collect(Collectors.toList());
        logger.debug("\tControl Flow Distances: {}", controlFlowDistances);
        return (int) controlFlowDistances.stream()
                .filter(sd -> sd != 0)
                .count();
    }
}
