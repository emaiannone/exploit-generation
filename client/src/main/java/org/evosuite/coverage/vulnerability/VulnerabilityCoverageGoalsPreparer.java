package org.evosuite.coverage.vulnerability;

import org.evosuite.Properties;
import org.evosuite.coverage.vulnerability.exceptions.UnreachableVulnerableTarget;
import org.evosuite.setup.DependencyAnalysis;
import org.evosuite.setup.callgraph.CallGraph;
import org.evosuite.setup.callgraph.CallGraphEntry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class VulnerabilityCoverageGoalsPreparer {
    protected static final Logger logger = LoggerFactory.getLogger(VulnerabilityCoverageGoalsPreparer.class);

    public static List<VulnerabilityCoverageGoal> prepare(VulnerabilityDescription vulnerabilityDescription) throws UnreachableVulnerableTarget {
        logger.debug("### Creation of the goals ###\n");
        logger.debug("Vulnerable Target:\n-> {}:{}", vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod());
        logger.debug("Client Class:\n-> {}\n", Properties.TARGET_CLASS);
        //logger.debug("Public methods: " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCCFG(vulnerabilityDescription.getVulnerableClass()).publicMethods);
        //logger.debug("CDG? " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCDG(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod()));

        List<VulnerabilityCoverageGoal> goals = createGoals(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod());
        logger.debug("Goals created:\n-> {}\n", goals.stream().map(Object::toString).collect(Collectors.joining("\n-> ")));
        return goals;
    }

    private static List<VulnerabilityCoverageGoal> createGoals(String vulnerableClass, String vulnerableMethod) {
        Set<List<CallGraphEntry>> paths = staticPathsToTarget(vulnerableClass, vulnerableMethod);
        if (paths == null) {
            throw new UnreachableVulnerableTarget("The vulnerable target method cannot be reached by the client class. No goals can be created.");
        }
        logger.debug("Static Paths\n-> {}\n", paths.stream().map(Object::toString).collect(Collectors.joining("\n-> ")));
        // Select paths rooted in the client class only
        Set<List<CallGraphEntry>> relevantPaths = paths.stream().filter(p -> p.get(0).getClassName().equals(Properties.TARGET_CLASS)).collect(Collectors.toSet());
        //logger.debug("Static Paths rooted in {}:\n-> {}\n", Properties.TARGET_CLASS, relevantPaths.stream().map(Object::toString).collect(Collectors.joining("\n-> ")));
        // Make the new goals from these relevant paths
        List<VulnerabilityCoverageGoal> goals = new ArrayList<>();
        int id = 0;
        for (List<CallGraphEntry> p : relevantPaths) {
            goals.add(new VulnerabilityCoverageGoal(id, p));
            id++;
        }
        return goals;
    }

    private static Set<List<CallGraphEntry>> staticPathsToTarget(String targetClass, String targetMethod) {
        CallGraph clientCallGraph = DependencyAnalysis.getCallGraph();
        CallGraphEntry targetNode = clientCallGraph.getViewOfCurrentMethods()
                .stream()
                .filter(node -> node.getClassName().equals(targetClass) && node.getMethodName().equals(targetMethod))
                .findFirst().orElse(null);
        if (targetNode == null) {
            logger.debug("Method {}.{} is not called via any class in the classpath.", targetClass, targetMethod);
            return null;
        }
        return staticPathsToNode(clientCallGraph, targetNode);
    }

    private static Set<List<CallGraphEntry>> staticPathsToNode(CallGraph callGraph, CallGraphEntry node) {
        Set<List<CallGraphEntry>> allPaths = new LinkedHashSet<>();
        Set<CallGraphEntry> incomingNodes = callGraph.getCallsFromMethod(node);
        if (incomingNodes.size() > 0) {
            for (CallGraphEntry incomingNode : incomingNodes) {
                Set<List<CallGraphEntry>> incomingPaths = staticPathsToNode(callGraph, incomingNode);
                allPaths.addAll(incomingPaths);
            }
            for (List<CallGraphEntry> allCallPath : allPaths) {
                allCallPath.add(allCallPath.size(), node);
            }
        } else {
            List<CallGraphEntry> incomingPath = new ArrayList<>();
            incomingPath.add(node);
            allPaths.add(incomingPath);
        }
        return allPaths;
    }
}
