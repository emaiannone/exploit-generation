package org.evosuite.coverage.vulnerability;

import org.evosuite.Properties;
import org.evosuite.coverage.vulnerability.exceptions.UnreachableVulnerableTarget;
import org.evosuite.setup.Call;
import org.evosuite.setup.CallContext;
import org.evosuite.setup.DependencyAnalysis;
import org.evosuite.setup.callgraph.CallGraph;
import org.evosuite.setup.callgraph.CallGraphEntry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.stream.Collectors;

public class VulnerabilityCoverageGoalsPreparer {
    protected static final Logger logger = LoggerFactory.getLogger(VulnerabilityCoverageGoalsPreparer.class);

    /**
     * Method for coverage goals generation.
     *
     * @return the list of coverage goals.
     * @throws UnreachableVulnerableTarget if the vulnerable method cannot be statically reached.
     */
    public static List<VulnerabilityCoverageGoal> prepare(VulnerabilityDescription vulnerabilityDescription) throws UnreachableVulnerableTarget {
        logger.debug("### Creation of the goals ###\n");
        logger.debug("Vulnerable Target:\n-> {}:{}", vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod());
        logger.debug("Client Class:\n-> {}\n", Properties.TARGET_CLASS);
        //logger.debug("Public methods: " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCCFG(vulnerabilityDescription.getVulnerableClass()).publicMethods);
        //logger.debug("CDG? " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCDG(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod()));

        List<VulnerabilityCoverageGoal> goals = createGoals(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod());
        logger.debug("Created goals:\n-> {}", goals.stream().map(Object::toString).collect(Collectors.joining("\n-> ")));
        return goals;
    }

    private static List<VulnerabilityCoverageGoal> createGoals(String vulnerableClass, String vulnerableMethod) {
        Set<List<CallGraphEntry>> paths = staticPathsToTarget(vulnerableClass, vulnerableMethod);
        if (paths == null) {
            throw new UnreachableVulnerableTarget("The vulnerable target method cannot be reached by the client class. No goals can be created.");
        }
        logger.debug("Static Paths\n-> {}\n", paths.stream().map(Object::toString).collect(Collectors.joining("\n-> ")));
        // Select paths rooted in the client class only
        Set<List<CallGraphEntry>> relevantPaths = paths.stream().filter(p -> p.get(0).getClassName().equals(Properties.TARGET_CLASS)).collect(Collectors.toSet());
        logger.debug("Static Paths rooted in Client Class\n-> {}\n", relevantPaths.stream().map(Object::toString).collect(Collectors.joining("\n-> ")));
        // TODO Make the new goals from these relevant paths


        // TODO Old code: remove
        VulnerabilityCoverageGoal.Call callToVulnerableMethod = buildCallToMethod(vulnerableMethod);
        if (callToVulnerableMethod == null) {
            throw new UnreachableVulnerableTarget("The vulnerable method cannot be reached by client class. No goals can be created.");
        }
        //logger.debug("Built Call to vulnerable method:\n-> {}.", callToVulnerableMethod);
        List<CallContext> callContextsFromStaticCaller = DependencyAnalysis.getCallGraph()
                .getAllContextsFromTargetClass(callToVulnerableMethod.getStaticCallerClass(), vulnerableMethod)
                .stream()
                .filter(cc -> !cc.isEmpty())
                .collect(Collectors.toList());
        //logger.debug("Call contexts from the static caller of the vulnerable method:\n-> {}", callContextsFromStaticCaller);
        List<VulnerabilityCoverageGoal> goals = new ArrayList<>();
        for (int i = 0; i < callContextsFromStaticCaller.size(); i++) {
            List<Call> callContext = callContextsFromStaticCaller.get(i).getContext();
            // We don't need the last one as it is the vulnerable method, already built
            callContext.remove(callContext.size() - 1);
            // Should I build each Call using buildCallToMethod (in order to have the alternatives?). If I have issues for the methods in between, consider doing so
            List<VulnerabilityCoverageGoal.Call> calls = callContext
                    .stream()
                    .map(call -> new VulnerabilityCoverageGoal.Call(call.getMethodName(), call.getClassName(), new ArrayList<>()))
                    .collect(Collectors.toList());
            calls.add(callToVulnerableMethod);
            goals.add(new VulnerabilityCoverageGoal(i, calls));
        }
        return goals;
    }

    private static Set<List<CallGraphEntry>> staticPathsToTarget(String targetClass, String targetMethod) {
        CallGraph clientCallGraph = DependencyAnalysis.getCallGraph();
        CallGraphEntry targetNode = clientCallGraph.getViewOfCurrentMethods()
                .stream()
                .filter(node -> node.getClassName().equals(targetClass) && node.getMethodName().equals(targetMethod))
                .findFirst().orElse(null);
        if (targetNode == null) {
            logger.debug("Method {}.{} is not called via any class in the classpath.", targetClass, targetMethod);
            return null;
        }
        return staticPathsToNode(clientCallGraph, targetNode);
    }

    private static Set<List<CallGraphEntry>> staticPathsToNode(CallGraph callGraph, CallGraphEntry node) {
        Set<List<CallGraphEntry>> allPaths = new LinkedHashSet<>();
        Set<CallGraphEntry> incomingNodes = callGraph.getCallsFromMethod(node);
        if (incomingNodes.size() > 0) {
            for (CallGraphEntry incomingNode : incomingNodes) {
                Set<List<CallGraphEntry>> incomingPaths = staticPathsToNode(callGraph, incomingNode);
                allPaths.addAll(incomingPaths);
            }
            for (List<CallGraphEntry> allCallPath : allPaths) {
                allCallPath.add(allCallPath.size(), node);
            }
        } else {
            List<CallGraphEntry> incomingPath = new ArrayList<>();
            incomingPath.add(node);
            allPaths.add(incomingPath);
        }
        return allPaths;
    }

    private static VulnerabilityCoverageGoal.Call buildCallToMethod(String method) {
        CallGraph callGraph = DependencyAnalysis.getCallGraph();
        Map<String, Set<String>> calledClassesMethods = callGraphToMap(callGraph);
        //logger.debug("DEBUG Called Methods (map): {}", calledClassesMethods);
        List<String> callerClasses = calledClassesMethods.values()
                .stream()
                .flatMap(Collection::stream)
                .filter(m -> m.equals(method))
                .collect(Collectors.toList());
        if (callerClasses.size() == 0) {
            logger.debug("Method {} is not called via any class in the classpath.", method);
            return null;
        }
        logger.debug("Method {} can be called via:\n-> {}", method, String.join("\n-> ", callerClasses));
        String staticCaller = callerClasses.stream()
                .filter(cc -> callGraph.isCalledMethod(cc, method))
                .findFirst()
                .orElse(null);
        // What if there is more than one static caller?
        if (staticCaller == null) {
            logger.debug("Method {} is not statically called via the client class.", method);
            return null;
        }
        logger.debug("Method {} is statically called by via a variable of type:\n-> {}", method, staticCaller);
        List<String> superClasses = new ArrayList<>(DependencyAnalysis.getInheritanceTree().getSuperclasses(staticCaller));
        superClasses.remove(staticCaller);
        logger.debug("Which has the following superclasses:\n-> {}\n", String.join("\n-> ", superClasses));
        List<String> alternatives = new ArrayList<>();
        for (String callerClass : callerClasses) {
            if (superClasses.contains(callerClass)) {
                alternatives.add(callerClass);
            }
        }
        return new VulnerabilityCoverageGoal.Call(method, staticCaller, alternatives);
    }

    private static Map<String, Set<String>> callGraphToMap(CallGraph callGraph) {
        Map<String, Set<String>> calledClassesMethods = new HashMap<>();
        for (CallGraphEntry currentMethod : callGraph.getViewOfCurrentMethods()) {
            if (calledClassesMethods.get(currentMethod.getClassName()) == null) {
                Set<String> methods = new HashSet<>();
                methods.add(currentMethod.getMethodName());
                calledClassesMethods.put(currentMethod.getClassName(), methods);
            } else {
                calledClassesMethods.get(currentMethod.getClassName()).add(currentMethod.getMethodName());
            }
        }
        return calledClassesMethods;
    }
}
