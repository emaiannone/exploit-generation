package org.evosuite.coverage.vulnerability;

import org.apache.commons.lang3.tuple.ImmutablePair;
import org.evosuite.TestGenerationContext;
import org.evosuite.coverage.vulnerability.exceptions.UnknownVulnerableLine;
import org.evosuite.coverage.vulnerability.exceptions.UnreachableVulnerableMethod;
import org.evosuite.graphs.cfg.BytecodeInstruction;
import org.evosuite.graphs.cfg.BytecodeInstructionPool;
import org.evosuite.graphs.cfg.ControlDependency;
import org.evosuite.setup.CallContext;
import org.evosuite.setup.DependencyAnalysis;
import org.evosuite.setup.callgraph.CallGraph;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class VulnerabilityCoverageGoalsPreparer {
    protected static final Logger logger = LoggerFactory.getLogger(VulnerabilityCoverageGoalsPreparer.class);

    /**
     * Method for coverage goals generation.
     *
     * @return the list of coverage goals.
     * @throws UnknownVulnerableLine       if bytecode instruction of the vulnerable target cannot be found.
     * @throws UnreachableVulnerableMethod if the vulnerable method cannot be statically reached.
     */
    public static List<VulnerabilityCoverageGoal> prepare(VulnerabilityDescription vulnerabilityDescription) throws UnknownVulnerableLine, UnreachableVulnerableMethod {
        logger.debug("\n#### Creation of coverage goals ####");
        logger.debug("Vulnerable Target:\n\t{}::{} at line {}", vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod(), vulnerabilityDescription.getVulnerableLine());
        //logger.debug("Public methods: " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCCFG(vulnerabilityDescription.getVulnerableClass()).publicMethods);
        //logger.debug("CDG? " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCDG(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod()));

        if (!isMethodCalled(vulnerabilityDescription)) {
            throw new UnreachableVulnerableMethod("The vulnerable method is not statically reached by any other known class. No goals can be created.");
        }
        
        // TODO To be removed soon
        BytecodeInstruction bytecodeInstruction = getBytecodeInstruction(vulnerabilityDescription);
        if (bytecodeInstruction == null) {
            throw new UnknownVulnerableLine("The vulnerable line bytecode is not known. No goals can be created.");
        }
        List<ControlDependency> controlNodes = getAllControlNodes(bytecodeInstruction);
        // Note: some predicates may get reversed when compiled into bytecode
        logger.debug("Control Dependencies:\n\t{}", Arrays.toString(controlNodes.toArray()));
        List<VulnerabilityCoverageGoal> goals = createGoals(controlNodes, vulnerabilityDescription);
        // TODO Probably, due to the new addition above, goals.size() will neven be 0
        if (goals.size() == 0) {
            logger.debug("Target is never statically called!");
        } else {
            logger.debug("These are the produced goals:");
            goals.forEach(g -> logger.debug("\t{}", g));
        }
        return goals;
    }

    /**
     * Check if the vulnerable class and method are statically reachable, even via subclasses.
     *
     * @return true if and only if the vulnerable method can be statically reached via the vulnerable class or one of its subclass.
     */
    private static boolean isMethodCalled(VulnerabilityDescription vulnerabilityDescription) {
        CallGraph callGraph = DependencyAnalysis.getCallGraph();
        List<ImmutablePair<String, String>> calledMethods = callGraph.getViewOfCurrentMethods()
                .stream()
                .map(m -> new ImmutablePair<>(m.getClassName(), m.getMethodName()))
                .collect(Collectors.toList());
        logger.debug("Called classes-methods: " + calledMethods);
        if (callGraph.isCalledMethod(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod())) {
            logger.debug("Method {} is directly reachable via {}.", vulnerabilityDescription.getVulnerableMethod(), vulnerabilityDescription.getVulnerableClass());
            return true;
        }
        logger.debug("Method {} is not directly reachable via {}: going to the inspect other classes.", vulnerabilityDescription.getVulnerableMethod(), vulnerabilityDescription.getVulnerableClass());
        List<String> candidateClasses = calledMethods
                .stream()
                .filter(p -> p.getRight().equals(vulnerabilityDescription.getVulnerableMethod()))
                .map(ImmutablePair::getLeft)
                .collect(Collectors.toList());
        if (candidateClasses.size() == 0) {
            logger.debug("Method {} is not called via any other known classes.", vulnerabilityDescription.getVulnerableMethod());
            return false;
        }
        logger.debug("Method {} is also called by {}.", vulnerabilityDescription.getVulnerableMethod(), candidateClasses);
        logger.debug("Going to inspect the subclasses of {}.", vulnerabilityDescription.getVulnerableClass());
        Set<String> knownSubclasses = getAllSubclasses(vulnerabilityDescription.getVulnerableClass());
        logger.debug("Subclasses of {}: {}", vulnerabilityDescription.getVulnerableClass(), knownSubclasses);
        for (String subclass : knownSubclasses) {
            if (candidateClasses.contains(subclass)) {
                logger.debug("Method {} is called via subclass {}!", vulnerabilityDescription.getVulnerableClass(), subclass);
                return true;
            }
        }
        return false;

        //ClassNode vulnClass = DependencyAnalysis.getClassNode(vulnerabilityDescription.getVulnerableClass());
        //logger.debug("ASM Method of vulnerable:" + Arrays.toString(vulnClass.methods.stream().map(m -> m.name + m.desc).toArray()));
    }

    /**
     * Obtains the entire set of classes below the given class hierarchy
     *
     * @param clazz starting class
     * @return the set of direct and indirect subclasses of clazz
     */
    private static Set<String> getAllSubclasses(String clazz) {
        Set<String> directSubclasses = DependencyAnalysis.getInheritanceTree().getSubclasses(clazz);
        directSubclasses.remove(clazz);
        Set<String> indirectSubclasses = new LinkedHashSet<>();
        for (String directSubclass : directSubclasses) {
            indirectSubclasses.addAll(getAllSubclasses(directSubclass));
        }
        Set<String> total = new LinkedHashSet<>();
        total.addAll(directSubclasses);
        total.addAll(indirectSubclasses);
        return total;
    }

    /**
     * Method for extracting the vulnerable bytecode instruction.
     *
     * @return the bytecode instruction.
     */
    private static BytecodeInstruction getBytecodeInstruction(VulnerabilityDescription vulnerabilityDescription) {
        BytecodeInstructionPool instructionPool = BytecodeInstructionPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT());
        // A line can have multiple bytecode instructions, however, for our purposes, it does not matter which one is chosen, so we can safely pick the first one
        //logger.debug("Class {} Bytecode:\n\t{}", vulnerabilityDescription.getVulnerableClass(), instructionPool.getInstructionsIn(vulnerabilityDescription.getVulnerableClass()));
        //logger.debug("Method {} Bytecode:\n\t{}", vulnerabilityDescription.getVulnerableMethod(), instructionPool.getInstructionsIn(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod()));
        //logger.debug("Line {} Bytecode:\n\t{}", vulnerabilityDescription.getVulnerableLine(), instructionAtLine);
        return instructionPool.getFirstInstructionAtLineNumber(
                vulnerabilityDescription.getVulnerableClass(),
                vulnerabilityDescription.getVulnerableMethod(),
                vulnerabilityDescription.getVulnerableLine());
    }

    /**
     * Recursive method that collects all control dependent branches starting from argument instruction up to root of the instruction's CDG.
     * The order of collection of branches starts from the innermost one to the outermost one, but the final list has reverse order.
     * This implementation is loop-safe, so they will only be collected once.
     *
     * @param instruction starting bytecode instruction.
     * @return list of control nodes that has an (indirect) control dependencies on the starting instruction,
     * starting from the outermost one to the innermost one.
     * @throws IllegalArgumentException if the given bytecode instruction is null.
     */
    private static List<ControlDependency> getAllControlNodes(BytecodeInstruction instruction) {
        if (instruction == null) {
            throw new IllegalArgumentException("A non-null bytecode instruction is required.");
        }

        // Base case: no control dependency (root)
        logger.debug(instruction.toString());
        logger.debug(instruction.getControlDependencies().toString());
        if (instruction.getControlDependencies().size() == 0) {
            return new ArrayList<>();
        }

        // Main part, get all direct control dependencies except itself (loop-safe)
        List<ControlDependency> directNodes = instruction.getControlDependencies()
                .stream()
                .filter(cd -> cd.getBranch().getInstruction().getInstructionId() != instruction.getInstructionId())
                .collect(Collectors.toList());
        logger.debug("All Direct controlNodes: {}", directNodes);

        // We are interested in the last one only, because the other, if present, are controlNodes related to "exit" statements
        ControlDependency directNode = directNodes.get(directNodes.size() - 1);

        // Recursive step
        List<ControlDependency> indirectNodes = getAllControlNodes(directNode.getBranch().getInstruction());

        // Return the list from the outermost control node to the innermost one
        List<ControlDependency> controlNodes = new ArrayList<>(indirectNodes);
        controlNodes.add(directNode);
        logger.debug("Returning: {}", controlNodes);
        return controlNodes;
    }

    /**
     * Helper method that takes care of coverage goals creation.
     *
     * @param controlNodes list of control nodes.
     * @return the list of coverage goals composed of target call context and the list of control dependent branches.
     * The list is empty if the target class and method are never statically called.
     * @throws IllegalArgumentException if the given list of control nodes is null.
     */
    private static List<VulnerabilityCoverageGoal> createGoals(List<ControlDependency> controlNodes, VulnerabilityDescription vulnerabilityDescription) {
        if (controlNodes == null) {
            throw new IllegalArgumentException("A non-null list of control dependencies is required.");
        }

        // If the vulnerable method is not statically called, no goals can be provided
        CallGraph callGraph = DependencyAnalysis.getCallGraph();
        if (!callGraph.isCalledMethod(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod())) {
            return new ArrayList<>();
        }
        // Consider only non empty call contexts
        List<CallContext> nonEmptyContexts = callGraph
                .getAllContextsFromTargetClass(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod())
                .stream()
                .filter(cc -> !cc.isEmpty())
                .collect(Collectors.toList());

        // A coverage goal consists of an id, a call context and the given control nodes
        return IntStream.range(0, nonEmptyContexts.size())
                .mapToObj(index -> new VulnerabilityCoverageGoal(index, nonEmptyContexts.get(index), controlNodes, vulnerabilityDescription.getVulnerableLine()))
                .collect(Collectors.toList());
    }

}
