package org.evosuite.coverage.vulnerability;

import org.evosuite.TestGenerationContext;
import org.evosuite.coverage.vulnerability.exceptions.UnreachableVulnerabileMethod;
import org.evosuite.coverage.vulnerability.exceptions.UnreachableVulnerableClass;
import org.evosuite.graphs.cfg.BytecodeInstruction;
import org.evosuite.graphs.cfg.BytecodeInstructionPool;
import org.evosuite.graphs.cfg.ControlDependency;
import org.evosuite.setup.CallContext;
import org.evosuite.setup.DependencyAnalysis;
import org.evosuite.setup.callgraph.CallGraph;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class VulnerabilityCoverageGoalsPreparer {
    protected static final Logger logger = LoggerFactory.getLogger(VulnerabilityCoverageGoalsPreparer.class);

    /**
     * Method for coverage goals generation.
     *
     * @return the list of coverage goals.
     * @throws UnreachableVulnerableClass   if bytecode instruction of the vulnerable target cannot be found.
     * @throws UnreachableVulnerabileMethod if the vulnerable method cannot be statically reached.
     */
    public static List<VulnerabilityCoverageGoal> prepare(VulnerabilityDescription vulnerabilityDescription) {
        logger.debug("\n#### Creation of coverage goals ####");
        logger.debug("Vulnerable Target:\n\t{}::{} at line {}", vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod(), vulnerabilityDescription.getVulnerableLine());

        BytecodeInstructionPool instructionPool = BytecodeInstructionPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT());
        // A line can have multiple bytecode instructions, however, for our purposes, it does not matter which one is chosen, so we can safely pick the first one
        BytecodeInstruction instructionAtLine = instructionPool.getFirstInstructionAtLineNumber(
                vulnerabilityDescription.getVulnerableClass(),
                vulnerabilityDescription.getVulnerableMethod(),
                vulnerabilityDescription.getVulnerableLine());
        //logger.debug("Class {} Bytecode:\n\t{}", vulnerabilityDescription.getVulnerableClass(), instructionPool.getInstructionsIn(vulnerabilityDescription.getVulnerableClass()));
        //logger.debug("Method {} Bytecode:\n\t{}", vulnerabilityDescription.getVulnerableMethod(), instructionPool.getInstructionsIn(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod()));
        //logger.debug("Line {} Bytecode:\n\t{}", vulnerabilityDescription.getVulnerableLine(), instructionAtLine);
        if (instructionAtLine == null) {
            throw new UnreachableVulnerableClass("Vulnerable line is not statically reached. No goals can be created.");
        }

        // Check if vulnerable classes and method are statically reachable. If not, the goals cannot be prepared
        boolean isReachableMethod = DependencyAnalysis.getCallGraph().isCalledMethod(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod());
        //logger.debug("Method is reachable? " + isReachableMethod);
        //logger.debug("Public methods: " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCCFG(vulnerabilityDescription.getVulnerableClass()).publicMethods);
        //logger.debug("CDG? " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCDG(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod()));
        if (!isReachableMethod) {
            throw new UnreachableVulnerabileMethod("Vulnerable method is not statically reached. No goals can be created.");
        }

        List<ControlDependency> controlNodes = getAllControlNodes(instructionAtLine);
        // Note: some predicates may get reversed when compiled into bytecode
        logger.debug("Control Dependencies:\n\t{}", Arrays.toString(controlNodes.toArray()));

        List<VulnerabilityCoverageGoal> goals = createGoals(controlNodes, vulnerabilityDescription);
        // TODO Probably, due to the new addition above, goals.size() will neven be 0
        if (goals.size() == 0) {
            logger.debug("Target is never statically called!");
        } else {
            logger.debug("These are the produced goals:");
            goals.forEach(g -> logger.debug("\t{}", g));
        }
        return goals;
    }

    /**
     * Recursive method that collects all control dependent branches starting from argument instruction up to root of the instruction's CDG.
     * The order of collection of branches starts from the innermost one to the outermost one, but the final list has reverse order.
     * This implementation is loop-safe, so they will only be collected once.
     *
     * @param instruction starting bytecode instruction.
     * @return list of control nodes that has an (indirect) control dependencies on the starting instruction,
     * starting from the outermost one to the innermost one.
     * @throws IllegalArgumentException if the given bytecode instruction is null.
     */
    private static List<ControlDependency> getAllControlNodes(BytecodeInstruction instruction) {
        if (instruction == null) {
            throw new IllegalArgumentException("A non-null bytecode instruction is required.");
        }

        // Base case: no control dependency (root)
        if (instruction.getControlDependencies().size() == 0) {
            return new ArrayList<>();
        }

        // Main part, get all direct control dependencies except itself (loop-safe)
        List<ControlDependency> directNodes = instruction.getControlDependencies()
                .stream()
                .filter(cd -> cd.getBranch().getInstruction().getInstructionId() != instruction.getInstructionId())
                .collect(Collectors.toList());
        logger.debug("All Direct controlNodes: {}", directNodes);

        // We are interested in the last one only, because the other, if present, are controlNodes related to "exit" statements
        ControlDependency directNode = directNodes.get(directNodes.size() - 1);

        // Recursive step
        List<ControlDependency> indirectNodes = getAllControlNodes(directNode.getBranch().getInstruction());

        // Return the list from the outermost control node to the innermost one
        List<ControlDependency> controlNodes = new ArrayList<>(indirectNodes);
        controlNodes.add(directNode);
        logger.debug("Returning: {}", controlNodes);
        return controlNodes;
    }

    /**
     * Helper method that takes care of coverage goals creation.
     *
     * @param controlNodes list of control nodes.
     * @return the list of coverage goals composed of target call context and the list of control dependent branches.
     * The list is empty if the target class and method are never statically called.
     * @throws IllegalArgumentException if the given list of control nodes is null.
     */
    private static List<VulnerabilityCoverageGoal> createGoals(List<ControlDependency> controlNodes, VulnerabilityDescription vulnerabilityDescription) {
        if (controlNodes == null) {
            throw new IllegalArgumentException("A non-null list of control dependencies is required.");
        }

        // If the vulnerable method is not statically called, no goals can be provided
        CallGraph callGraph = DependencyAnalysis.getCallGraph();
        if (!callGraph.isCalledMethod(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod())) {
            return new ArrayList<>();
        }
        // Consider only non empty call contexts
        List<CallContext> nonEmptyContexts = callGraph
                .getAllContextsFromTargetClass(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod())
                .stream()
                .filter(cc -> !cc.isEmpty())
                .collect(Collectors.toList());

        // A coverage goal consists of an id, a call context and the given control nodes
        return IntStream.range(0, nonEmptyContexts.size())
                .mapToObj(index -> new VulnerabilityCoverageGoal(index, nonEmptyContexts.get(index), controlNodes, vulnerabilityDescription.getVulnerableLine()))
                .collect(Collectors.toList());
    }

}
