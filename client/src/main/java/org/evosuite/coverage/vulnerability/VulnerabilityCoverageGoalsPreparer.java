package org.evosuite.coverage.vulnerability;

import org.apache.commons.lang3.tuple.ImmutablePair;
import org.evosuite.Properties;
import org.evosuite.coverage.vulnerability.exceptions.UnreachableVulnerableMethod;
import org.evosuite.setup.Call;
import org.evosuite.setup.CallContext;
import org.evosuite.setup.DependencyAnalysis;
import org.evosuite.setup.callgraph.CallGraph;
import org.evosuite.setup.callgraph.CallGraphEntry;
import org.objectweb.asm.tree.ClassNode;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public class VulnerabilityCoverageGoalsPreparer {
    protected static final Logger logger = LoggerFactory.getLogger(VulnerabilityCoverageGoalsPreparer.class);

    /**
     * Method for coverage goals generation.
     *
     * @return the list of coverage goals.
     * @throws UnreachableVulnerableMethod if the vulnerable method cannot be statically reached.
     */
    public static List<VulnerabilityCoverageGoal> prepare(VulnerabilityDescription vulnerabilityDescription) throws UnreachableVulnerableMethod {
        logger.debug("### Creation of the goals ###\n");
        logger.debug("Vulnerable Target:\n-> {}:{}", vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod());
        logger.debug("Client Class:\n-> {}\n", Properties.TARGET_CLASS);
        //logger.debug("Public methods: " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCCFG(vulnerabilityDescription.getVulnerableClass()).publicMethods);
        //logger.debug("CDG? " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCDG(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod()));

        List<VulnerabilityCoverageGoal> goals = createGoals(vulnerabilityDescription);
        logger.debug("Created goals:\n-> {}", goals.stream().map(VulnerabilityCoverageGoal::toString).collect(Collectors.joining("\n-> ")));
        //goals.forEach(g -> logger.debug("\t- {}", g));
        return goals;
    }

    private static List<VulnerabilityCoverageGoal> createGoals(VulnerabilityDescription vulnerabilityDescription) {
        Set<List<CallGraphEntry>> paths = pathsToVulnerability(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod());
        // TODO create goals from these paths: use the subclass technique, relaxing everything in between

        // TODO Old code, not working now
        VulnerabilityCoverageGoal.Call callToVulnerableMethod = buildCallToMethod(vulnerabilityDescription.getVulnerableMethod());
        if (callToVulnerableMethod == null) {
            throw new UnreachableVulnerableMethod("The vulnerable method cannot be reached by client class. No goals can be created.");
        }
        //logger.debug("Built Call to vulnerable method:\n-> {}.", callToVulnerableMethod);
        List<CallContext> callContextsFromStaticCaller = DependencyAnalysis.getCallGraph()
                .getAllContextsFromTargetClass(callToVulnerableMethod.getStaticCallerClass(), vulnerabilityDescription.getVulnerableMethod())
                .stream()
                .filter(cc -> !cc.isEmpty())
                .collect(Collectors.toList());
        //logger.debug("Call contexts from the static caller of the vulnerable method:\n-> {}", callContextsFromStaticCaller);
        List<VulnerabilityCoverageGoal> goals = new ArrayList<>();
        for (int i = 0; i < callContextsFromStaticCaller.size(); i++) {
            List<Call> callContext = callContextsFromStaticCaller.get(i).getContext();
            // We don't need the last one as it is the vulnerable method, already built
            callContext.remove(callContext.size() - 1);
            // Should I build each Call using buildCallToMethod (in order to have the alternatives?). If I have issues for the methods in between, consider doing so
            List<VulnerabilityCoverageGoal.Call> calls = callContext
                    .stream()
                    .map(call -> new VulnerabilityCoverageGoal.Call(call.getMethodName(), call.getClassName(), new ArrayList<>()))
                    .collect(Collectors.toList());
            calls.add(callToVulnerableMethod);
            goals.add(new VulnerabilityCoverageGoal(i, calls));
        }
        return goals;
    }

    private static Set<List<CallGraphEntry>> pathsToVulnerability(String vulnerableClass, String vulnerableMethod) {
        CallGraph callGraph = DependencyAnalysis.getCallGraph();
        CallGraphEntry vulnerableNode = callGraph.getViewOfCurrentMethods()
                .stream()
                .filter(node -> node.getClassName().equals(vulnerableClass) && node.getMethodName().equals(vulnerableMethod))
                .findFirst().orElse(null);
        if (vulnerableNode == null) {
            logger.debug("Method {} is not called via any class in the classpath.", vulnerableMethod);
            return null;
        }
        Set<List<CallGraphEntry>> callPaths = callPathsToNode(callGraph, vulnerableNode);
        // FIXME When the classpath has other classes, classes with empty method still have paths... which makes no sense. How to solve?
        logger.debug("Paths {}", callPaths);
        return callPaths;
    }

    private static Set<List<CallGraphEntry>> callPathsToNode(CallGraph callGraph, CallGraphEntry node) {
        Set<List<CallGraphEntry>> allCallPaths = new HashSet<>();
        Set<CallGraphEntry> incomingNodes = callGraph.getCallsFromMethod(node);
        if (incomingNodes.size() > 0) {
            for (CallGraphEntry incomingNode : incomingNodes) {
                Set<List<CallGraphEntry>> incomingPaths = callPathsToNode(callGraph, incomingNode);
                allCallPaths.addAll(incomingPaths);
            }
            for (List<CallGraphEntry> allCallPath : allCallPaths) {
                allCallPath.add(allCallPath.size(), node);
            }
        } else {
            List<CallGraphEntry> incomingPath = new ArrayList<>();
            incomingPath.add(node);
            allCallPaths.add(incomingPath);
        }
        return allCallPaths;
    }

    private static VulnerabilityCoverageGoal.Call buildCallToMethod(String method) {
        CallGraph callGraph = DependencyAnalysis.getCallGraph();
        Map<String, Set<String>> calledClassesMethods = callGraphToMap(callGraph);
        //logger.debug("DEBUG Called Methods (map): {}", calledClassesMethods);
        List<String> callerClasses = calledClassesMethods.values()
                .stream()
                .flatMap(Collection::stream)
                .filter(m -> m.equals(method))
                .collect(Collectors.toList());
        if (callerClasses.size() == 0) {
            logger.debug("Method {} is not called via any class in the classpath.", method);
            return null;
        }
        logger.debug("Method {} can be called via:\n-> {}", method, String.join("\n-> ", callerClasses));
        String staticCaller = callerClasses.stream()
                .filter(cc -> callGraph.isCalledMethod(cc, method))
                .findFirst()
                .orElse(null);
        // What if there is more than one static caller?
        if (staticCaller == null) {
            logger.debug("Method {} is not statically called via the client class.", method);
            return null;
        }
        logger.debug("Method {} is statically called by via a variable of type:\n-> {}", method, staticCaller);
        List<String> superClasses = new ArrayList<>(DependencyAnalysis.getInheritanceTree().getSuperclasses(staticCaller));
        superClasses.remove(staticCaller);
        logger.debug("Which has the following superclasses:\n-> {}\n", String.join("\n-> ", superClasses));
        List<String> alternatives = new ArrayList<>();
        for (String callerClass : callerClasses) {
            if (superClasses.contains(callerClass)) {
                alternatives.add(callerClass);
            }
        }
        return new VulnerabilityCoverageGoal.Call(method, staticCaller, alternatives);
    }

    private static Map<String, Set<String>> callGraphToMap(CallGraph callGraph) {
        Map<String, Set<String>> calledClassesMethods = new HashMap<>();
        for (CallGraphEntry currentMethod : callGraph.getViewOfCurrentMethods()) {
            if (calledClassesMethods.get(currentMethod.getClassName()) == null) {
                Set<String> methods = new HashSet<>();
                methods.add(currentMethod.getMethodName());
                calledClassesMethods.put(currentMethod.getClassName(), methods);
            } else {
                calledClassesMethods.get(currentMethod.getClassName()).add(currentMethod.getMethodName());
            }
        }
        return calledClassesMethods;
    }
}
