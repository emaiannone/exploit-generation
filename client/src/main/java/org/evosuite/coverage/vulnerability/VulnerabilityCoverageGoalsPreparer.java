package org.evosuite.coverage.vulnerability;

import org.apache.commons.lang3.tuple.ImmutablePair;
import org.evosuite.Properties;
import org.evosuite.coverage.vulnerability.exceptions.UnreachableVulnerableMethod;
import org.evosuite.setup.Call;
import org.evosuite.setup.CallContext;
import org.evosuite.setup.DependencyAnalysis;
import org.evosuite.setup.callgraph.CallGraph;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class VulnerabilityCoverageGoalsPreparer {
    protected static final Logger logger = LoggerFactory.getLogger(VulnerabilityCoverageGoalsPreparer.class);

    /**
     * Method for coverage goals generation.
     *
     * @return the list of coverage goals.
     * @throws UnreachableVulnerableMethod if the vulnerable method cannot be statically reached.
     */
    public static List<VulnerabilityCoverageGoal> prepare(VulnerabilityDescription vulnerabilityDescription) throws UnreachableVulnerableMethod {
        logger.debug("\n#### Creation of coverage goals ####");
        logger.debug("Vulnerable Target:\n\t{}:{}", vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod());
        logger.debug("Client Class:\n\t{}\n", Properties.TARGET_CLASS);
        //logger.debug("Public methods: " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCCFG(vulnerabilityDescription.getVulnerableClass()).publicMethods);
        //logger.debug("CDG? " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCDG(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod()));

        List<VulnerabilityCoverageGoal> goals = createGoals(vulnerabilityDescription);
        logger.debug("\nThese are the produced goals:");
        goals.forEach(g -> logger.debug("\t- {}", g));
        return goals;
    }

    private static List<VulnerabilityCoverageGoal> createGoals(VulnerabilityDescription vulnerabilityDescription) {
        VulnerabilityCoverageGoal.Call callToVulnerableMethod = buildCallToMethod(vulnerabilityDescription.getVulnerableMethod());
        if (callToVulnerableMethod == null) {
            throw new UnreachableVulnerableMethod("The vulnerable method cannot be reached by any known class. No goals can be created.");
        }
        logger.debug("Built Call to vulnerable method:\n\t{}.", callToVulnerableMethod);
        List<CallContext> callContextsFromStaticCaller = DependencyAnalysis.getCallGraph()
                .getAllContextsFromTargetClass(callToVulnerableMethod.getStaticCallerClass(), vulnerabilityDescription.getVulnerableMethod())
                .stream()
                .filter(cc -> !cc.isEmpty())
                .collect(Collectors.toList());
        logger.debug("Call contexts from the static caller of the vulnerable method:\n\t{}", callContextsFromStaticCaller);
        List<VulnerabilityCoverageGoal> goals = new ArrayList<>();
        for (int i = 0; i < callContextsFromStaticCaller.size(); i++) {
            List<Call> callContext = callContextsFromStaticCaller.get(i).getContext();
            // We don't need the last one as it is the vulnerable method, already built
            callContext.remove(callContext.size() - 1);
            //TODO Should I build each Call using buildCallToMethod (in order to have the alternatives?). If I have issues for the methods in between, consider doing so
            List<VulnerabilityCoverageGoal.Call> calls = callContext
                    .stream()
                    .map(call -> new VulnerabilityCoverageGoal.Call(call.getMethodName(), call.getClassName(), new ArrayList<>()))
                    .collect(Collectors.toList());
            calls.add(callToVulnerableMethod);
            goals.add(new VulnerabilityCoverageGoal(i, calls));
        }
        return goals;
    }

    private static VulnerabilityCoverageGoal.Call buildCallToMethod(String method) {
        CallGraph callGraph = DependencyAnalysis.getCallGraph();
        List<ImmutablePair<String, String>> calledMethods = callGraph.getViewOfCurrentMethods()
                .stream()
                .map(m -> new ImmutablePair<>(m.getClassName(), m.getMethodName()))
                .collect(Collectors.toList());
        List<String> callerClasses = calledMethods
                .stream()
                .filter(p -> p.getRight().equals(method))
                .map(ImmutablePair::getLeft)
                .collect(Collectors.toList());
        if (callerClasses.size() == 0) {
            logger.debug("Method {} is not called via any other known classes.", method);
            return null;
        }
        logger.debug("Method {} can be called via:\n\t{}.", method, callerClasses);
        String staticCaller = callerClasses.stream()
                .filter(cc -> callGraph.isCalledMethod(cc, method))
                .findFirst()
                .orElse(null);
        // TODO What if there is more than one static caller?
        if (staticCaller == null) {
            logger.debug("Method {} is not statically called via any other known classes.", method);
            return null;
        }
        logger.debug("Method {} is statically called via a variable of type:\n\t{}.", method, staticCaller);
        List<String> superClasses = new ArrayList<>(DependencyAnalysis.getInheritanceTree().getSuperclasses(staticCaller));
        superClasses.remove(staticCaller);
        logger.debug("Class {} has the following superclasses:\n\t{}.", staticCaller, superClasses);
        List<String> alternatives = new ArrayList<>();
        for (String callerClass : callerClasses) {
            if (superClasses.contains(callerClass)) {
                alternatives.add(callerClass);
            }
        }
        return new VulnerabilityCoverageGoal.Call(method, staticCaller, alternatives);
    }
}
