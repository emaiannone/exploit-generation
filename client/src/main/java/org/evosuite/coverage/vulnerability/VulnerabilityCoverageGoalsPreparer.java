package org.evosuite.coverage.vulnerability;

import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.evosuite.Properties;
import org.evosuite.coverage.vulnerability.exceptions.UnreachableVulnerableMethod;
import org.evosuite.setup.CallContext;
import org.evosuite.setup.DependencyAnalysis;
import org.evosuite.setup.callgraph.CallGraph;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class VulnerabilityCoverageGoalsPreparer {
    protected static final Logger logger = LoggerFactory.getLogger(VulnerabilityCoverageGoalsPreparer.class);

    /**
     * Method for coverage goals generation.
     *
     * @return the list of coverage goals.
     * @throws UnreachableVulnerableMethod if the vulnerable method cannot be statically reached.
     */
    public static List<VulnerabilityCoverageGoal> prepare(VulnerabilityDescription vulnerabilityDescription) throws UnreachableVulnerableMethod {
        logger.debug("\n#### Creation of coverage goals ####");
        logger.debug("Vulnerable Target:\n\t{}::{}", vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod());
        logger.debug("Client Class:\n\t{}\n", Properties.TARGET_CLASS);
        //logger.debug("Public methods: " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCCFG(vulnerabilityDescription.getVulnerableClass()).publicMethods);
        //logger.debug("CDG? " + GraphPool.getInstance(TestGenerationContext.getInstance().getClassLoaderForSUT()).getCDG(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod()));

        List<VulnerabilityCoverageGoal> goals = createGoals(vulnerabilityDescription);
        logger.debug("These are the produced goals:");
        goals.forEach(g -> logger.debug("\t{}", g));
        return goals;
    }

    private static List<VulnerabilityCoverageGoal> createGoals(VulnerabilityDescription vulnerabilityDescription) {
        String actualCallingClass = getActualCallingClass(vulnerabilityDescription);
        if (actualCallingClass == null) {
            throw new UnreachableVulnerableMethod("The vulnerable method is not statically reached by any other known class. No goals can be created.");
        }

        CallGraph callGraph = DependencyAnalysis.getCallGraph();
        logger.debug("From vuln class: {}", callGraph.getAllContextsFromTargetClass(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod()));
        logger.debug("From actual: {}", callGraph.getAllContextsFromTargetClass(actualCallingClass, vulnerabilityDescription.getVulnerableMethod()));

        // Consider only non empty call contexts
        List<Pair<String, CallContext>> nonEmptyContexts = callGraph
                .getAllContextsFromTargetClass(actualCallingClass, vulnerabilityDescription.getVulnerableMethod())
                .stream()
                .filter(cc -> !cc.isEmpty())
                .map(cc -> new ImmutablePair<>(actualCallingClass, cc))
                .collect(Collectors.toList());

        // A coverage goal consists of an id, the actual calling class, and the call context from it
        return IntStream.range(0, nonEmptyContexts.size())
                .mapToObj(index -> new VulnerabilityCoverageGoal(index, nonEmptyContexts.get(index).getLeft(), nonEmptyContexts.get(index).getRight()))
                .collect(Collectors.toList());
    }

    /**
     * Returns the name of the actual class that calls the vulnerable method.
     *
     * @return true if and only if the vulnerable method can be statically reached via the vulnerable class or one of its subclass.
     */
    private static String getActualCallingClass(VulnerabilityDescription vulnerabilityDescription) {
        CallGraph callGraph = DependencyAnalysis.getCallGraph();
        List<ImmutablePair<String, String>> calledMethods = callGraph.getViewOfCurrentMethods()
                .stream()
                .map(m -> new ImmutablePair<>(m.getClassName(), m.getMethodName()))
                .collect(Collectors.toList());
        //logger.debug("Called classes-methods: " + calledMethods);
        if (callGraph.isCalledMethod(vulnerabilityDescription.getVulnerableClass(), vulnerabilityDescription.getVulnerableMethod())) {
            logger.debug("Method {} is accessed via a variable of type {}.", vulnerabilityDescription.getVulnerableMethod(), vulnerabilityDescription.getVulnerableClass());
            return vulnerabilityDescription.getVulnerableClass();
        }
        logger.debug("Method {} is not accessed via a variable of type {}: going to the inspect other classes.", vulnerabilityDescription.getVulnerableMethod(), vulnerabilityDescription.getVulnerableClass());
        List<String> candidateClasses = calledMethods
                .stream()
                .filter(p -> p.getRight().equals(vulnerabilityDescription.getVulnerableMethod()))
                .map(ImmutablePair::getLeft)
                .collect(Collectors.toList());
        if (candidateClasses.size() == 0) {
            logger.debug("Method {} is not accessed via any other known classes.", vulnerabilityDescription.getVulnerableMethod());
            return null;
        }
        logger.debug("Method {} is callable from {}.", vulnerabilityDescription.getVulnerableMethod(), candidateClasses);
        logger.debug("Going to inspect the subclasses of {}.", vulnerabilityDescription.getVulnerableClass());
        Set<String> knownSubclasses = getAllSubclasses(vulnerabilityDescription.getVulnerableClass());
        logger.debug("Subclasses of {}: {}", vulnerabilityDescription.getVulnerableClass(), knownSubclasses);
        for (String subclass : knownSubclasses) {
            if (candidateClasses.contains(subclass)) {
                logger.debug("Method {} is accessed via a variable of subtype {}!", vulnerabilityDescription.getVulnerableClass(), subclass);
                return subclass;
            }
        }
        return null;
    }

    /**
     * Obtains the entire set of classes below the given class hierarchy
     *
     * @param clazz starting class
     * @return the set of direct and indirect subclasses of clazz
     */
    private static Set<String> getAllSubclasses(String clazz) {
        Set<String> directSubclasses = DependencyAnalysis.getInheritanceTree().getSubclasses(clazz);
        directSubclasses.remove(clazz);
        Set<String> indirectSubclasses = new LinkedHashSet<>();
        for (String directSubclass : directSubclasses) {
            indirectSubclasses.addAll(getAllSubclasses(directSubclass));
        }
        Set<String> total = new LinkedHashSet<>();
        total.addAll(directSubclasses);
        total.addAll(indirectSubclasses);
        return total;
    }

}
