package org.evosuite.ga.operators.crossover;

import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.commons.math3.distribution.GeometricDistribution;
import org.evosuite.Properties;
import org.evosuite.ga.ConstructionFailedException;
import org.evosuite.testcase.AbstractTestChromosome;
import org.evosuite.testcase.statements.NullStatement;
import org.evosuite.testcase.statements.PrimitiveStatement;
import org.evosuite.testcase.statements.Statement;
import org.evosuite.utils.GenerationLogger;
import org.evosuite.utils.Randomness;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Implement crossover for reachability coverage goal. This works at the primitive values level, not at the statement level.
 *
 * @author Emanuele Iannone
 */
public class ReachabilityEntryMethodCrossOver<T extends AbstractTestChromosome<T>> extends CrossOverFunction<T> {
    private static final GenerationLogger GENERATION_LOGGER = new GenerationLogger(Properties.GENERATION_LOG_FILE);

    @Override
    public void crossOver(T parent1, T parent2) throws ConstructionFailedException {
        if (parent1.size() < 2 || parent2.size() < 2) {
            return;
        }
        //GENERATION_LOGGER.write(String.format("PARENT 1 crashed at: %s", parent1ExceptionPos));
        //GENERATION_LOGGER.write(String.format("PARENT 2 crashed at: %s", parent2ExceptionPos));
        Map<String, Pair<List<Integer>, List<Integer>>> matchMap = matchPrimitiveStatements(parent1, parent2);
        for (Map.Entry<String, Pair<List<Integer>, List<Integer>>> e : matchMap.entrySet()) {
            List<Integer> parent1Positions = e.getValue().getLeft();
            List<Integer> parent2Positions = e.getValue().getRight();
            if (!parent1Positions.isEmpty() && !parent2Positions.isEmpty()) {
                Integer parent1Pos = Properties.EXCEPTION_POINT_SAMPLING ? samplePosition(parent1Positions, parent1.getFirstExceptionPosition()) : Randomness.choice(parent1Positions);
                Integer parent2Pos = Properties.EXCEPTION_POINT_SAMPLING ? samplePosition(parent2Positions, parent2.getFirstExceptionPosition()) : Randomness.choice(parent2Positions);
                if (parent1Pos == null || parent2Pos == null) {
                    continue;
                }
                PrimitiveStatement<?> parent1Stmt = (PrimitiveStatement<?>) parent1.getTestCase().getStatement(parent1Pos);
                PrimitiveStatement<?> parent2Stmt = (PrimitiveStatement<?>) parent2.getTestCase().getStatement(parent2Pos);
                Object parent1Value = parent1Stmt.getValue();
                Object parent2Value = parent2Stmt.getValue();
                if (!parent1Value.equals(parent2Value)) {
                    GENERATION_LOGGER.write(String.format("Crossover: TestCase n.%s (from n.%s), Value (%s) from Stmt.%s <-> TestCase n.%s (from n.%s), Value (%s) from Stmt.%s", parent1.getTestCase().getID(), parent1.getTestCase().getOriginatingID(), parent1Value, parent1Pos + 1, parent1.getTestCase().getID(), parent2.getTestCase().getOriginatingID(), parent2Value, parent2Pos + 1));
                    parent1Stmt.setValueObject(parent2Value);
                    parent2Stmt.setValueObject(parent1Value);
                }
                parent1Positions.remove(parent1Pos);
                parent2Positions.remove(parent2Pos);
            }
        }
    }

    private Map<String, Pair<List<Integer>, List<Integer>>> matchPrimitiveStatements(T parent1, T parent2) {
        Map<String, Pair<List<Integer>, List<Integer>>> matchMap = new LinkedHashMap<>();
        addPrimitiveStatements(parent1, matchMap, true);
        addPrimitiveStatements(parent2, matchMap, false);
        return matchMap.entrySet()
                .stream()
                .filter(e -> !e.getValue().getLeft().isEmpty() && !e.getValue().getRight().isEmpty())
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    private Integer samplePosition(List<Integer> positionToSample, Integer exceptionPosition) {
        if (exceptionPosition == null) {
            return Randomness.choice(positionToSample);
        }
        int numStmtBeforeException = (int) positionToSample.stream().filter(a -> a <= exceptionPosition).count();
        if (numStmtBeforeException == 0) {
            return Randomness.choice(positionToSample);
        }
        double p = 1 - ((double) numStmtBeforeException / (positionToSample.size() + 1));
        int sampled = new GeometricDistribution(p).sample();
        if (sampled >= positionToSample.size()) {
            sampled = positionToSample.size() - 1;
        }
        return positionToSample.get(sampled);
    }

    private void addPrimitiveStatements(T chromosome, Map<String, Pair<List<Integer>, List<Integer>>> map, boolean left) {
        List<Statement> statements = chromosome.getTestCase().getStatements();
        for (int i = 0; i < statements.size(); i++) {
            Statement st = statements.get(i);
            if (st instanceof PrimitiveStatement<?>) {
                if (st instanceof NullStatement) {
                    continue;
                }
                String name = st.getClass().getName();
                Pair<List<Integer>, List<Integer>> matchedStatements = map.get(name);
                if (matchedStatements == null) {
                    map.put(name, new ImmutablePair<>(new ArrayList<>(), new ArrayList<>()));
                    matchedStatements = map.get(name);
                }
                if (left) {
                    matchedStatements.getLeft().add(i);
                } else {
                    matchedStatements.getRight().add(i);
                }
            }
        }
    }
}
