package org.evosuite.ga.operators.crossover;

import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.evosuite.Properties;
import org.evosuite.ga.ConstructionFailedException;
import org.evosuite.testcase.AbstractTestChromosome;
import org.evosuite.testcase.statements.NullStatement;
import org.evosuite.testcase.statements.PrimitiveStatement;
import org.evosuite.testcase.statements.Statement;
import org.evosuite.utils.GenerationLogger;
import org.evosuite.utils.Randomness;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Implement crossover for reachability coverage goal. This works at the primitive values level, not at the statement level.
 *
 * @author Emanuele Iannone
 */
public class ReachabilityEntryMethodCrossOver<T extends AbstractTestChromosome<T>> extends CrossOverFunction<T> {
    private static final GenerationLogger GENERATION_LOGGER = new GenerationLogger(Properties.GENERATION_LOG_FILE);

    @Override
    public void crossOver(T parent1, T parent2) throws ConstructionFailedException {
        if (parent1.size() < 2 || parent2.size() < 2) {
            return;
        }
        Integer parent1ExceptionPos = parent1.getFirstExceptionPosition();
        Integer parent2ExceptionPos = parent2.getFirstExceptionPosition();
        //GENERATION_LOGGER.write(String.format("PARENT 1 crashed at: %s", parent1ExceptionPos));
        //GENERATION_LOGGER.write(String.format("PARENT 2 crashed at: %s", parent2ExceptionPos));

        Map<String, Pair<List<Integer>, List<Integer>>> matchMap = matchPrimitiveStatements(parent1, parent2);
        for (Map.Entry<String, Pair<List<Integer>, List<Integer>>> e : matchMap.entrySet()) {
            List<Integer> parent2Positions = e.getValue().getRight();
            List<Integer> parent1Positions = e.getValue().getLeft();
            if (!parent1Positions.isEmpty() && !parent2Positions.isEmpty()) {
                // TODO If the exception point analysis is enabled, then give priority to swapping the statements BEFORE those statement (if exists), otherwise go full random. Maybe geometric distribution?
                Integer parent1Pos = Randomness.choice(parent1Positions);
                Integer parent2Pos = Randomness.choice(parent2Positions);
                if (parent1Pos == null || parent2Pos == null) {
                    continue;
                }
                PrimitiveStatement<?> parent1Stmt = (PrimitiveStatement<?>) parent1.getTestCase().getStatement(parent1Pos);
                PrimitiveStatement<?> parent2Stmt = (PrimitiveStatement<?>) parent2.getTestCase().getStatement(parent2Pos);
                Object parent1Value = parent1Stmt.getValue();
                Object parent2Value = parent2Stmt.getValue();
                if (!parent1Value.equals(parent2Value)) {
                    GENERATION_LOGGER.write(String.format("Crossover: TestCase n.%s (from n.%s), Value (%s) from Stmt.%s <-> TestCase n.%s (from n.%s), Value (%s) from Stmt.%s", parent1.getTestCase().getID(), parent1.getTestCase().getOriginatingID(), parent1Value, parent1Pos + 1, parent1.getTestCase().getID(), parent2.getTestCase().getOriginatingID(), parent2Value, parent2Pos + 1));
                    parent1Stmt.setValueObject(parent2Value);
                    parent2Stmt.setValueObject(parent1Value);
                }
                parent1Positions.remove(parent1Pos);
                parent2Positions.remove(parent2Pos);
            }
        }

        /*
        //GENERATION_LOGGER.write(String.format("PARENT 1 Code:\n%s", GenerationLoggerHelper.testCaseToString(parent1.getTestCase(), 15)));
        //GENERATION_LOGGER.write(String.format("PARENT 2 Code:\n%s", GenerationLoggerHelper.testCaseToString(parent2.getTestCase(), 15)));
        int parent1Point = parent1ExceptionPos != null ? parent1ExceptionPos : Randomness.nextInt(parent1.size() - 1) + 1;
        int parent2Point = parent2ExceptionPos != null ? parent2ExceptionPos : Randomness.nextInt(parent2.size() - 1) + 1;
        T p1 = parent1.clone();
        // TODO These crossover functions work at statement level: we want to work at the values level, so we do call these...
        parent1.crossOver(parent2.clone(), parent1Point, parent2Point);
        parent2.crossOver(p1, parent2Point, parent1Point);
        //GENERATION_LOGGER.write(String.format("PARENT 1 New Code:\n%s", GenerationLoggerHelper.testCaseToString(parent1.getTestCase(), 15)));
        //GENERATION_LOGGER.write(String.format("PARENT 2 New Code:\n%s", GenerationLoggerHelper.testCaseToString(parent2.getTestCase(), 15)));
         */
    }

    private Map<String, Pair<List<Integer>, List<Integer>>> matchPrimitiveStatements(T parent1, T parent2) {
        Map<String, Pair<List<Integer>, List<Integer>>> matchMap = new LinkedHashMap<>();
        addPrimitiveStatements(parent1, matchMap, true);
        addPrimitiveStatements(parent2, matchMap, false);
        return matchMap.entrySet()
                .stream()
                .filter(e -> !e.getValue().getLeft().isEmpty() && !e.getValue().getRight().isEmpty())
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    private void addPrimitiveStatements(T chromosome, Map<String, Pair<List<Integer>, List<Integer>>> map, boolean left) {
        List<Statement> statements = chromosome.getTestCase().getStatements();
        for (int i = 0; i < statements.size(); i++) {
            Statement st = statements.get(i);
            if (st instanceof PrimitiveStatement<?>) {
                if (st instanceof NullStatement) {
                    continue;
                }
                String name = st.getClass().getName();
                Pair<List<Integer>, List<Integer>> matchedStatements = map.get(name);
                if (matchedStatements == null) {
                    map.put(name, new ImmutablePair<>(new ArrayList<>(), new ArrayList<>()));
                    matchedStatements = map.get(name);
                }
                if (left) {
                    matchedStatements.getLeft().add(i);
                } else {
                    matchedStatements.getRight().add(i);
                }
            }
        }
    }
}
