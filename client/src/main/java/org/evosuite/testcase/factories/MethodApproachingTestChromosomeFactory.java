package org.evosuite.testcase.factories;

import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.evosuite.Properties;
import org.evosuite.coverage.reachability.StaticPath;
import org.evosuite.coverage.reachability.StaticPathsPool;
import org.evosuite.ga.ChromosomeFactory;
import org.evosuite.ga.ConstructionFailedException;
import org.evosuite.setup.TestCluster;
import org.evosuite.testcase.DefaultTestCase;
import org.evosuite.testcase.TestCase;
import org.evosuite.testcase.TestChromosome;
import org.evosuite.testcase.TestFactory;
import org.evosuite.testcase.execution.ExecutionTracer;
import org.evosuite.testcase.statements.ConstructorStatement;
import org.evosuite.testcase.statements.MethodStatement;
import org.evosuite.testcase.statements.Statement;
import org.evosuite.utils.GenerationLogger;
import org.evosuite.utils.GenerationLoggerHelper;
import org.evosuite.utils.Randomness;
import org.evosuite.utils.generic.GenericConstructor;
import org.evosuite.utils.generic.GenericExecutable;
import org.evosuite.utils.generic.GenericMethod;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class MethodApproachingTestChromosomeFactory implements ChromosomeFactory<TestChromosome> {
    private static final GenerationLogger GENERATION_LOGGER = new GenerationLogger(Properties.SIEGE_LOG_FILE);
    private static final long serialVersionUID = -420224349882780857L;

    private static final List<GenericExecutable<?, ?>> possibleCalls = new ArrayList<>();
    private static final List<GenericExecutable<?, ?>> desiredCalls = new ArrayList<>();
    private final ChromosomeFactory<TestChromosome> defaultFactory;

    public MethodApproachingTestChromosomeFactory(ChromosomeFactory<TestChromosome> defaultFactory) {
        // This contains methods accessible from tests, i.e., protected and public ones
        possibleCalls.addAll(
                TestCluster.getInstance().getTestCalls().stream()
                        .filter(c -> c.isMethod() || c.isConstructor())
                        .map(c -> (GenericExecutable<?, ?>) c)
                        .collect(Collectors.toList())
        );
        Set<StaticPath> staticPaths = StaticPathsPool.getPathsToTarget(Properties.REACHABILITY_TARGET_CLASS, Properties.REACHABILITY_TARGET_METHOD);
        Set<String> methodsInPaths = staticPaths.stream()
                .flatMap(a -> a.getCalledMethods(Properties.TARGET_CLASS).stream())
                .collect(Collectors.toCollection(LinkedHashSet::new));
        /*
        GENERATION_LOGGER.write("CALLABLES:");
        for (GenericExecutable<?, ?> m : callableMethods) {
            GENERATION_LOGGER.write(String.format("\t- %s", m));
        }
        GENERATION_LOGGER.write("METHODS IN PATHS:");
        for (String m : methodsInPaths) {
            GENERATION_LOGGER.write(String.format("\t- %s", m));
        }
         */
        if (!methodsInPaths.isEmpty()) {
            desiredCalls.addAll(possibleCalls.stream()
                    .filter(c -> methodsInPaths.contains(c.getNameWithDescriptor()))
                    .collect(Collectors.toList()));
        }
        if (desiredCalls.isEmpty()) {
            GENERATION_LOGGER.write("There is no candidate method that could reach the target. The initial tests will be generated randomly.");
        } else {
            GENERATION_LOGGER.write("Trying to make the initial tests call one of the following:");
            for (GenericExecutable<?, ?> desiredCall : desiredCalls) {
                GENERATION_LOGGER.write(String.format("\t- %s", desiredCall.getNameWithDescriptor()));
            }
        }
        this.defaultFactory = defaultFactory;
    }

    @Override
    public TestChromosome getChromosome() {
        if (desiredCalls.isEmpty()) {
            return defaultFactory.getChromosome();
        }
        TestChromosome chromosome = new TestChromosome();
        chromosome.setTestCase(getRandomTestCase(Properties.CHROMOSOME_LENGTH, Properties.MAX_ATTEMPTS));
        return chromosome;
    }

    private TestCase getRandomTestCase(int chromosomeLength, int maxAttempts) {
        boolean tracerEnabled = ExecutionTracer.isEnabled();
        if (tracerEnabled) {
            ExecutionTracer.disable();
        }

        TestCase test;
        boolean shouldUseEmptyTest = Randomness.nextDouble() < 0.2;
        if (shouldUseEmptyTest) {
            test = new DefaultTestCase();
            GENERATION_LOGGER.write(String.format("Generated empty TestCase n.%s", test.getID()));
            tryToAddDesiredCall(test, Properties.MAX_ATTEMPTS / 100, false);
        } else {
            test = defaultFactory.getChromosome().getTestCase();
            GENERATION_LOGGER.write(String.format("Generated a random TestCase n.%s", test.getID()));
            GENERATION_LOGGER.write(String.format("Code (%s statements):", test.size()));
            GENERATION_LOGGER.write(GenerationLoggerHelper.testCaseToString(test, 4));
            for (int attempts = 0; attempts < maxAttempts; attempts++) {
                if (test.size() >= chromosomeLength) {
                    GENERATION_LOGGER.write(String.format("\tRe-generating TestCase %s with %s statements", test.getID(), test.size()));
                    test = defaultFactory.getChromosome().getTestCase();
                    break;
                }
            }
            boolean shouldTryToSeedCall = Randomness.nextDouble() < 0.8;
            if (shouldTryToSeedCall) {
                tryToAddDesiredCall(test, Properties.MAX_ATTEMPTS / 100, true);
            }
        }

        if (tracerEnabled) {
            ExecutionTracer.enable();
        }
        return test;
    }

    private boolean tryToAddDesiredCall(TestCase test, int maxAttempts, boolean tryToReplace) {
        for (int attempts = 0; attempts < maxAttempts; attempts++) {
            List<Statement> statements = test.getStatements();
            List<Pair<Integer, ? extends GenericExecutable<?, ?>>> statementsWithExecutable = desiredCalls.stream()
                    .map(m -> new ImmutablePair<>(findStatementWithExecutable(statements, m), m))
                    .filter(m -> m.getLeft() > -1)
                    .collect(Collectors.toList());
            if (!statementsWithExecutable.isEmpty()) {
                GENERATION_LOGGER.write("\tThe test contains one desired call!");
                return true;
            }
            GenericExecutable<?, ?> callToSeed = Randomness.choice(desiredCalls);
            if (callToSeed == null) {
                continue;
            }
            // Randomly select one desired call and add it at the end
            TestFactory testFactory = TestFactory.getInstance();
            if (tryToReplace) {
                GENERATION_LOGGER.write(String.format("\tSetting %s at the end", callToSeed.getNameWithDescriptor()));
                if (setCallAtPosition(testFactory, test, callToSeed, test.size() - 1, 0)) {
                    GENERATION_LOGGER.write("\t\t[SUCCESS]");
                    return true;
                } else {
                    GENERATION_LOGGER.write("\t\t[FAILED]");
                    return false;
                }
            }
            GENERATION_LOGGER.write(String.format("\tAdding %s at the end", callToSeed.getNameWithDescriptor()));
            if (addCallAtPosition(testFactory, test, callToSeed, test.size(), 0)) {
                GENERATION_LOGGER.write("\t\t[SUCCESS]");
                return true;
            } else {
                GENERATION_LOGGER.write("\t\t[FAILED]");
                return false;
            }
        }
        return false;
    }

    /*
    private boolean tryToAddCallOLD(TestCase test, int maxAttempts) {
        for (int attempts = 0; attempts < maxAttempts; attempts++) {
            List<Statement> statements = test.getStatements();
            List<Pair<Integer, ? extends GenericExecutable<?, ?>>> statementsWithExecutable = desiredCalls.stream()
                    .map(m -> new ImmutablePair<>(findStatementWithExecutable(statements, m), m))
                    .filter(m -> m.getLeft() > -1)
                    .collect(Collectors.toList());
            if (statementsWithExecutable.isEmpty()) {
                GenericExecutable<?, ?> callToSeed = Randomness.choice(desiredCalls);
                if (callToSeed == null) {
                    continue;
                }
                // Randomly select one desired call and add it at the end
                TestFactory testFactory = TestFactory.getInstance();
                boolean shouldAdd = Randomness.nextDouble() < 0.5;
                int position = Randomness.nextInt(test.size());
                // At a random position, 50% add the statement, 50% replace an existing statement
                if (shouldAdd) {
                    GENERATION_LOGGER.write(String.format("\tAdding, at position %s, %s", position, callToSeed.getNameWithDescriptor()));
                    if (!addCallAtPosition(testFactory, test, callToSeed, position, 0)) {
                        GENERATION_LOGGER.write("\t\t[FAILED]");
                        continue;
                    }
                } else {
                    Statement statementToReplace = statements.get(position);
                    GENERATION_LOGGER.write(String.format("\tReplacing, at position %s, %s with %s", position, statementToReplace, callToSeed.getNameWithDescriptor()));
                    // If the statement to replace is a constructor, then we make sure it is not building an instance of the class of the call to seed
                    if (statementToReplace instanceof ConstructorStatement && ((ConstructorStatement) statementToReplace).getConstructor().getOwnerClass().equals(callToSeed.getOwnerClass())) {
                        GENERATION_LOGGER.write(String.format("\t\tMatched a constructor, adding %s next to it instead", callToSeed.getNameWithDescriptor()));
                        if (!addCallAtPosition(testFactory, test, callToSeed, position + 1, 0)) {
                            GENERATION_LOGGER.write("\t\t[FAILED]");
                            continue;
                        }
                    } else {
                        if (!setCallAtPosition(testFactory, test, callToSeed, position)) {
                            GENERATION_LOGGER.write("\t\t[FAILED]");
                            continue;
                        }
                    }
                }
                GENERATION_LOGGER.write("\t\t[SUCCESS]");
            }
            return true;
        }
        return false;
    }
     */

    private int findStatementWithExecutable(List<Statement> statements, GenericExecutable<?, ?> cm) {
        for (int i = 0; i < statements.size(); i++) {
            Statement st = statements.get(i);
            String stNameWithDescriptor;
            if (st instanceof ConstructorStatement) {
                stNameWithDescriptor = ((ConstructorStatement) st).getConstructor().getNameWithDescriptor();
            } else if (st instanceof MethodStatement) {
                stNameWithDescriptor = ((MethodStatement) st).getMethod().getNameWithDescriptor();
            } else {
                continue;
            }
            if (stNameWithDescriptor.equals(cm.getNameWithDescriptor())) {
                return i;
            }
        }
        return -1;
    }

    private boolean addCallAtPosition(TestFactory testFactory, TestCase test, GenericExecutable<?, ?> call, int position, int recursionDepth) {
        try {
            if (call.isMethod()) {
                testFactory.addMethod(test, (GenericMethod) call, position, recursionDepth);
            } else if (call.isConstructor()) {
                testFactory.addConstructor(test, (GenericConstructor) call, position, recursionDepth);
            }
            return true;
        } catch (ConstructionFailedException ignored) {
            return false;
        }
    }

    private boolean setCallAtPosition(TestFactory testFactory, TestCase test, GenericExecutable<?, ?> call, int position, int recursionDepth) {
        try {
            if (!testFactory.deleteStatementGracefully(test, position)) {
                return false;
            }
            return addCallAtPosition(testFactory, test, call, Math.min(position, test.size()), recursionDepth);
        } catch (ConstructionFailedException ignored) {
            return false;
        }
    }
}
