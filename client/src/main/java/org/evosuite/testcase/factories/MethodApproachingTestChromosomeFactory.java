package org.evosuite.testcase.factories;

import org.evosuite.Properties;
import org.evosuite.coverage.reachability.GenerationLogger;
import org.evosuite.coverage.reachability.StaticPath;
import org.evosuite.coverage.reachability.StaticPathsPool;
import org.evosuite.ga.ChromosomeFactory;
import org.evosuite.ga.ConstructionFailedException;
import org.evosuite.setup.TestCluster;
import org.evosuite.testcase.TestCase;
import org.evosuite.testcase.TestChromosome;
import org.evosuite.testcase.TestFactory;
import org.evosuite.testcase.execution.ExecutionTracer;
import org.evosuite.testcase.statements.ConstructorStatement;
import org.evosuite.testcase.statements.MethodStatement;
import org.evosuite.testcase.statements.Statement;
import org.evosuite.utils.Randomness;
import org.evosuite.utils.generic.GenericAccessibleObject;
import org.evosuite.utils.generic.GenericConstructor;
import org.evosuite.utils.generic.GenericExecutable;
import org.evosuite.utils.generic.GenericMethod;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class MethodApproachingTestChromosomeFactory implements ChromosomeFactory<TestChromosome> {
    private static final GenerationLogger GENERATION_LOGGER = new GenerationLogger(Properties.SIEGE_LOG_FILE);
    private static final long serialVersionUID = -420224349882780857L;

    private static final List<GenericAccessibleObject<?>> callableMethods = new ArrayList<>();
    private static final List<GenericAccessibleObject<?>> desiredMethods = new ArrayList<>();
    private final ChromosomeFactory<TestChromosome> defaultFactory;

    public MethodApproachingTestChromosomeFactory(ChromosomeFactory<TestChromosome> defaultFactory) {
        // This contains methods accessible from tests, i.e., protected and public ones
        callableMethods.addAll(TestCluster.getInstance().getTestCalls());
        Set<StaticPath> staticPaths = StaticPathsPool.getPathsToTarget(Properties.REACHABILITY_TARGET_CLASS, Properties.REACHABILITY_TARGET_METHOD);
        Set<String> methodsInPaths = staticPaths.stream()
                .flatMap(a -> a.getCalledMethods(Properties.TARGET_CLASS).stream())
                .collect(Collectors.toCollection(LinkedHashSet::new));
        /*
        GENERATION_LOGGER.write("CALLABLES:");
        for (GenericAccessibleObject<?> m : callableMethods) {
            GENERATION_LOGGER.write(String.format("\t- %s", m));
        }
        GENERATION_LOGGER.write("METHODS IN PATHS:");
        for (String m : methodsInPaths) {
            GENERATION_LOGGER.write(String.format("\t- %s", m));
        }
         */
        if (!methodsInPaths.isEmpty()) {
            desiredMethods.addAll(callableMethods.stream()
                    .filter(c -> c.isMethod() || c.isConstructor())
                    .filter(c -> methodsInPaths.contains(((GenericExecutable<?, ?>) c).getNameWithDescriptor()))
                    .collect(Collectors.toList()));
        }
        if (desiredMethods.isEmpty()) {
            GENERATION_LOGGER.write("There is no candidate method that could reach the target. The initial population of tests will be generated randomly.");
        } else {
            GENERATION_LOGGER.write("Trying to make the initial population of tests call one of the following:");
            for (GenericAccessibleObject<?> desiredMethod : desiredMethods) {
                GENERATION_LOGGER.write(String.format("\t- %s", desiredMethod));
            }
        }
        this.defaultFactory = defaultFactory;
    }

    @Override
    public TestChromosome getChromosome() {
        if (desiredMethods.isEmpty()) {
            return defaultFactory.getChromosome();
        }
        TestChromosome chromosome = new TestChromosome();
        chromosome.setTestCase(getRandomTestCase(Properties.CHROMOSOME_LENGTH, Properties.MAX_ATTEMPTS));
        return chromosome;
    }

    private TestCase getRandomTestCase(int chromosomeLength, int maxAttempts) {
        boolean tracerEnabled = ExecutionTracer.isEnabled();
        if (tracerEnabled) {
            ExecutionTracer.disable();
        }

        int attempts;
        // TODO Randomly decide if start from a random test or an empty one
        TestCase test = defaultFactory.getChromosome().getTestCase();
        for (attempts = 0; attempts < maxAttempts; attempts++) {
            List<Statement> statements = test.getStatements();
            Set<String> constructorsInTest = statements.stream()
                    .filter(s -> s instanceof ConstructorStatement)
                    .map(s -> ((ConstructorStatement) s).getConstructor().getNameWithDescriptor())
                    .collect(Collectors.toCollection(LinkedHashSet::new));
            Set<String> methodsInTest = statements.stream()
                    .filter(s -> s instanceof MethodStatement)
                    .map(s -> ((MethodStatement) s).getMethod().getNameWithDescriptor())
                    .collect(Collectors.toCollection(LinkedHashSet::new));
            Set<String> constructorsMethodsInTest = Stream.concat(constructorsInTest.stream(), methodsInTest.stream())
                    .collect(Collectors.toCollection(LinkedHashSet::new));

            boolean oneMethodIsContained = desiredMethods.stream()
                    .map(cm -> ((GenericExecutable<?, ?>) cm).getNameWithDescriptor())
                    .anyMatch(constructorsMethodsInTest::contains);
            if (oneMethodIsContained) {
                // Do nothing, the test case should be fine
                // TODO We might remove the other "noisy" methods before the right call, randomly
            } else {
                // Randomly select one desired method and add it at the end, ensuring we are not going beyond the allowed length. If so, replace the last one.
                GenericAccessibleObject<?> call = Randomness.choice(desiredMethods);
                if (call != null) {
                    // TODO We might also randomly select the place where to put the method (possibly, without replacing an existing constructor)
                    if (test.size() >= chromosomeLength) {
                        break;
                    }
                    TestFactory testFactory = TestFactory.getInstance();
                    try {
                        if (call.isMethod()) {
                            testFactory.addMethod(test, (GenericMethod) call, test.size(), 0);
                        } else if (call.isConstructor()) {
                            testFactory.addConstructor(test, (GenericConstructor) call, test.size(), 0);
                        }
                        GENERATION_LOGGER.write(String.format("One test in the initial population was seeded with: %s", call));
                    } catch (ConstructionFailedException ignored) {
                        continue;
                    }
                }
            }
            break;
        }

        if (tracerEnabled) {
            ExecutionTracer.enable();
        }
        return test;
    }
}
