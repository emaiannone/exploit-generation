package org.evosuite.utils;

import org.apache.commons.math3.distribution.PoissonDistribution;
import org.evosuite.Properties;
import org.evosuite.ga.ConstructionFailedException;
import org.evosuite.testcase.TestCase;
import org.evosuite.testcase.TestFactory;
import org.evosuite.testcase.statements.Statement;
import org.evosuite.utils.generic.GenericConstructor;
import org.evosuite.utils.generic.GenericExecutable;
import org.evosuite.utils.generic.GenericMethod;

import java.util.ArrayList;
import java.util.Collection;

public class ReachabilityTestCaseModifier {
    private static final GenerationLogger GENERATION_LOGGER = new GenerationLogger(Properties.GENERATION_LOG_FILE);

    public static boolean tryToAppendExecutable(GenericExecutable<?, ?> executableToAppend, TestCase test, int maxAttempts) {
        for (int attempts = 0; attempts < maxAttempts; attempts++) {
            boolean outcome = appendExecutable(executableToAppend, test);
            if (outcome) {
                return true;
            }
        }
        return false;
    }

    public static Collection<? extends GenericMethod> tryToAddCallsBeforeEntryCall(TestCase test, int maxTestLength, int maxAttempts) {
        Statement entryMethodStatement = test.getStatement(test.size() - 1);
        if (entryMethodStatement == null) {
            return null;
        }
        GenericExecutable<?, ?> entryMethodExecutable = ExecutablesHelper.getExecutableFromStatement(entryMethodStatement);
        if (entryMethodExecutable == null) {
            return null;
        }
        Collection<? extends GenericMethod> callableMethodsOfClass = ExecutablesHelper.getClassCallableMethods(entryMethodExecutable.getOwnerClass());
        // Randomly select one of the entry class methods (ignoring constructors and the entry method), and add some calls before calling the entry method (in hope of setting some instance variables to value that will pass branches).
        if (callableMethodsOfClass.isEmpty()) {
            return null;
        }
        // Do not consider the entry method for this phase
        if (entryMethodExecutable.isMethod()) {
            callableMethodsOfClass.remove((GenericMethod) entryMethodExecutable);
        }
        if (callableMethodsOfClass.isEmpty()) {
            return null;
        }
        // Determine the number of methods to call using a Poisson sampling with lambda=1, i.e., 0 and 1 have maximum probability, then decreasing with larger values
        int howManyMethodsToAdd = new PoissonDistribution(1).sample();
        Collection<GenericMethod> addedCalls = new ArrayList<>();
        for (int i = 0; i < howManyMethodsToAdd; i++) {
            // TODO Reduce probability of sampling the same methods
            GenericMethod methodToAdd = Randomness.choice(callableMethodsOfClass);
            if (methodToAdd == null) {
                continue;
            }
            GENERATION_LOGGER.write(String.format("Trying to add %s before calling the entry method", methodToAdd.getNameWithDescriptor()));
            boolean added = tryToAddBefore(methodToAdd, test, maxAttempts, test.size() - 1);
            if (!added) {
                GENERATION_LOGGER.write("\t[FAILED]");
                continue;
            }
            addedCalls.add(methodToAdd);
            GENERATION_LOGGER.write("\t[SUCCESS]");
            if (test.size() >= maxTestLength) {
                break;
            }
        }
        return addedCalls;
    }

    public static boolean tryToAddAnExecutableIntoTest(Collection<? extends GenericExecutable<?, ?>> executablesToSample, TestCase test, int maxAttempts, boolean tryToReplace) {
        for (int attempts = 0; attempts < maxAttempts; attempts++) {
            if (executablesToSample.stream().anyMatch(a -> ExecutablesHelper.hasExecutable(a, test.getStatements()))) {
                GENERATION_LOGGER.write("\tThe test contains one desired executable!");
                return true;
            }
            GenericExecutable<?, ?> executableToSeed = Randomness.choice(executablesToSample);
            if (executableToSeed == null) {
                continue;
            }
            // Randomly select one desired executable and add it at the end
            TestFactory testFactory = TestFactory.getInstance();
            if (tryToReplace && test.size() > 0) {
                GENERATION_LOGGER.write(String.format("\tSetting %s at the end", executableToSeed.getNameWithDescriptor()));
                if (setExecutableAtPosition(testFactory, test, executableToSeed, test.size() - 1, 0)) {
                    GENERATION_LOGGER.write("\t\t[SUCCESS]");
                    return true;
                } else {
                    GENERATION_LOGGER.write("\t\t[FAILED]");
                    return false;
                }
            }
            GENERATION_LOGGER.write(String.format("\tAdding %s at the end", executableToSeed.getNameWithDescriptor()));
            if (addExecutableAtPosition(testFactory, test, executableToSeed, test.size(), 0)) {
                GENERATION_LOGGER.write("\t\t[SUCCESS]");
                return true;
            } else {
                GENERATION_LOGGER.write("\t\t[FAILED]");
                return false;
            }
        }
        return false;
    }

    private static boolean tryToAddBefore(GenericExecutable<?, ?> executableToAdd, TestCase test, int maxAttempts, int position) {
        for (int attempts = 0; attempts < maxAttempts; attempts++) {
            boolean outcome = addExecutableAtPosition(executableToAdd, test, position);
            if (outcome) {
                return true;
            }
        }
        return false;
    }

    private static boolean appendExecutable(GenericExecutable<?, ?> executable, TestCase test) {
        return addExecutableAtPosition(TestFactory.getInstance(), test, executable, test.size(), 0);
    }

    private static boolean addExecutableAtPosition(GenericExecutable<?, ?> executable, TestCase test, int position) {
        return addExecutableAtPosition(TestFactory.getInstance(), test, executable, position, 0);
    }

    private static boolean addExecutableAtPosition(TestFactory testFactory, TestCase test, GenericExecutable<?, ?> executable, int position, int recursionDepth) {
        try {
            if (executable.isMethod()) {
                testFactory.addMethod(test, (GenericMethod) executable, position, recursionDepth);
            } else if (executable.isConstructor()) {
                testFactory.addConstructor(test, (GenericConstructor) executable, position, recursionDepth);
            }
            return true;
        } catch (ConstructionFailedException ignored) {
            return false;
        }
    }

    private static boolean setExecutableAtPosition(TestFactory testFactory, TestCase test, GenericExecutable<?, ?> executable, int position, int recursionDepth) {
        try {
            if (!testFactory.deleteStatementGracefully(test, position)) {
                return false;
            }
            return addExecutableAtPosition(testFactory, test, executable, Math.min(position, test.size()), recursionDepth);
        } catch (ConstructionFailedException ignored) {
            return false;
        }
    }
}
