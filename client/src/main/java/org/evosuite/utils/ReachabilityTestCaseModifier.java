package org.evosuite.utils;

import org.apache.commons.math3.distribution.PoissonDistribution;
import org.evosuite.Properties;
import org.evosuite.testcase.TestCase;
import org.evosuite.testcase.statements.Statement;
import org.evosuite.utils.generic.GenericExecutable;
import org.evosuite.utils.generic.GenericMethod;

import java.util.ArrayList;
import java.util.Collection;

public class ReachabilityTestCaseModifier {
    private static final GenerationLogger GENERATION_LOGGER = new GenerationLogger(Properties.GENERATION_LOG_FILE);

    public static boolean tryToAppendExecutable(GenericExecutable<?, ?> executableToAppend, TestCase test, int maxAttempts) {
        for (int attempts = 0; attempts < maxAttempts; attempts++) {
            boolean outcome = ExecutablesHelper.appendExecutable(executableToAppend, test);
            if (outcome) {
                return true;
            }
        }
        return false;
    }

    public static Collection<? extends GenericMethod> tryToAddCallsBeforeEntryCall(TestCase test, int maxTestLength, int maxAttempts) {
        Statement entryMethodStatement = test.getStatement(test.size() - 1);
        if (entryMethodStatement == null) {
            return null;
        }
        GenericExecutable<?, ?> entryMethodExecutable = ExecutablesHelper.getExecutableFromStatement(entryMethodStatement);
        if (entryMethodExecutable == null) {
            return null;
        }
        Collection<? extends GenericMethod> callableMethodsOfClass = ExecutablesHelper.getClassCallableMethods(entryMethodExecutable.getOwnerClass());
        // Randomly select one of the entry class methods (ignoring constructors and the entry method), and add some calls before calling the entry method (in hope of setting some instance variables to value that will pass branches).
        if (callableMethodsOfClass.isEmpty()) {
            return null;
        }
        // Do not consider the entry method for this phase
        if (entryMethodExecutable.isMethod()) {
            callableMethodsOfClass.remove((GenericMethod) entryMethodExecutable);
        }
        if (callableMethodsOfClass.isEmpty()) {
            return null;
        }
        // Determine the number of methods to call using a Poisson sampling with lambda=1, i.e., 0 and 1 have maximum probability, then decreasing with larger values
        int howManyMethodsToAdd = new PoissonDistribution(1).sample();
        Collection<GenericMethod> addedCalls = new ArrayList<>();
        for (int i = 0; i < howManyMethodsToAdd; i++) {
            // TODO Reduce probability of sampling the same methods
            GenericMethod methodToAdd = Randomness.choice(callableMethodsOfClass);
            if (methodToAdd == null) {
                continue;
            }
            GENERATION_LOGGER.write(String.format("Trying to add %s before calling the entry method", methodToAdd.getNameWithDescriptor()));
            boolean added = tryToAddBefore(methodToAdd, test, maxAttempts, test.size() - 1);
            if (!added) {
                GENERATION_LOGGER.write("\t[FAILED]");
                continue;
            }
            addedCalls.add(methodToAdd);
            GENERATION_LOGGER.write("\t[SUCCESS]");
            if (test.size() >= maxTestLength) {
                break;
            }
        }
        return addedCalls;
    }

    private static boolean tryToAddBefore(GenericExecutable<?, ?> executableToAdd, TestCase test, int maxAttempts, int position) {
        for (int attempts = 0; attempts < maxAttempts; attempts++) {
            boolean outcome = ExecutablesHelper.addExecutableAtPosition(executableToAdd, test, position);
            if (outcome) {
                return true;
            }
        }
        return false;
    }
}
