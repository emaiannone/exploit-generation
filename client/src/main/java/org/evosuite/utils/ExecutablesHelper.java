package org.evosuite.utils;

import org.evosuite.setup.TestCluster;
import org.evosuite.testcase.statements.ConstructorStatement;
import org.evosuite.testcase.statements.MethodStatement;
import org.evosuite.testcase.statements.Statement;
import org.evosuite.utils.generic.*;

import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class ExecutablesHelper {
    /**
     * Returns the list of all methods (as GenericExecutable) that can be potentially called from any test case, i.e., protected and public ones
     *
     * @return A list of all GenericExecutable callable from test cases
     */
    public static Collection<? extends GenericExecutable<?, ?>> getCallableExecutables() {
        return TestCluster.getInstance()
                .getTestCalls()
                .stream()
                .filter(c -> c.isMethod() || c.isConstructor())
                .map(c -> (GenericExecutable<?, ?>) c)
                .collect(Collectors.toList());
    }

    public static Collection<? extends GenericExecutable<?, ?>> getClassCallableExecutables(GenericClass<?> clazz) {
        return getCallableExecutables()
                .stream()
                .filter(a -> a.getOwnerClass().equals(clazz))
                .collect(Collectors.toList());
    }

    public static Collection<? extends GenericMethod> getCallableMethods() {
        return getCallableExecutables()
                .stream()
                .filter(GenericAccessibleObject::isMethod)
                .map(c -> (GenericMethod) c)
                .collect(Collectors.toList());
    }

    public static Collection<? extends GenericMethod> getClassCallableMethods(GenericClass<?> clazz) {
        return getCallableMethods()
                .stream()
                .filter(a -> a.getOwnerClass().equals(clazz))
                .collect(Collectors.toList());
    }

    public static Collection<? extends GenericConstructor> getCallableConstructors() {
        return getCallableExecutables()
                .stream()
                .filter(GenericAccessibleObject::isConstructor)
                .map(c -> (GenericConstructor) c)
                .collect(Collectors.toList());
    }

    public static Collection<? extends GenericConstructor> getClassCallableConstructors(GenericClass<?> clazz) {
        return getCallableConstructors()
                .stream()
                .filter(a -> a.getOwnerClass().equals(clazz))
                .collect(Collectors.toList());
    }

    public static Collection<? extends GenericExecutable<?, ?>> getExecutablesInStatements(List<Statement> statements) {
        Collection<? extends GenericExecutable<?, ?>> executablesToSearch = getCallableExecutables();
        Set<GenericExecutable<?, ?>> executablesFound = new LinkedHashSet<>();
        for (Statement statement : statements) {
            String stNameWithDescriptor = getStatementNameWithDescriptor(statement);
            if (stNameWithDescriptor == null) {
                continue;
            }
            executablesToSearch.stream()
                    .filter(ex -> stNameWithDescriptor.equals(ex.getNameWithDescriptor()))
                    .findFirst()
                    .ifPresent(executablesFound::add);
        }
        return executablesFound;
    }

    public static GenericExecutable<?, ?> getExecutableFromStatement(Statement statement) {
        Collection<? extends GenericExecutable<?, ?>> executablesToSearch = getCallableExecutables();
        String stNameWithDescriptor = getStatementNameWithDescriptor(statement);
        if (stNameWithDescriptor == null) {
            return null;
        }
        return executablesToSearch.stream()
                .filter(ex -> stNameWithDescriptor.equals(ex.getNameWithDescriptor()))
                .findFirst().orElse(null);
    }

    /**
     * Select the list of methods (as GenericExecutable) whose names (with descriptors) match with those in wantedNames.
     *
     * @param executables List of GenericExecutable to filter
     * @param wantedNames Method names with descriptors to select
     * @return The filtered list of GenericExecutable
     */
    public static Collection<? extends GenericExecutable<?, ?>> selectExecutablesByNames(Collection<? extends GenericExecutable<?, ?>> executables, Set<String> wantedNames) {
        return executables.stream()
                .filter(c -> wantedNames.contains(c.getNameWithDescriptor()))
                .collect(Collectors.toList());
    }

    public static boolean hasExecutable(GenericExecutable<?, ?> executable, List<Statement> statements) {
        return findStatementIndexWithExecutable(statements, executable) > -1;
    }

    private static int findStatementIndexWithExecutable(List<Statement> statements, GenericExecutable<?, ?> executable) {
        for (int i = 0; i < statements.size(); i++) {
            Statement statement = statements.get(i);
            String stNameWithDescriptor = getStatementNameWithDescriptor(statement);
            if (stNameWithDescriptor == null) {
                continue;
            }
            if (stNameWithDescriptor.equals(executable.getNameWithDescriptor())) {
                return i;
            }
        }
        return -1;
    }

    private static String getStatementNameWithDescriptor(Statement statement) {
        if (statement instanceof ConstructorStatement) {
            return ((ConstructorStatement) statement).getConstructor().getNameWithDescriptor();
        } else if (statement instanceof MethodStatement) {
            return ((MethodStatement) statement).getMethod().getNameWithDescriptor();
        }
        return null;
    }
}
