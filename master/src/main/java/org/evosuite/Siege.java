package org.evosuite;

import com.opencsv.CSVReader;
import com.opencsv.CSVReaderBuilder;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.lang3.tuple.ImmutableTriple;
import org.evosuite.ga.metaheuristics.GeneticAlgorithm;
import org.evosuite.result.TestGenerationResult;
import org.evosuite.testcase.TestChromosome;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Siege {
    protected static Logger logger = LoggerFactory.getLogger(Siege.class);

    public static void main(String[] args) {
        EvoSuite evoSuite = new EvoSuite();

        Options options = new Options();
        options.addOption(new Option("clientCP", true, "Client project classpath. A root directory containing all compiled Java classes needs to be provided, e.g. target/classes"));
        options.addOption(new Option("vulnerabilities", true, "CSV File containing descriptions of a set of known vulnerabilities. A CSV file needs to be provided."));
        options.addOption(new Option("vulnClass", true, "Vulnerable class to be targeted by an exploit. A fully qualifying needs to be provided, e.g. org.foo.SomeClass"));
        options.addOption(new Option("vulnMethod", true, "Vulnerable method to be targeted by an exploit. A name and descriptor needs to be provided, e.g. someMethod([B[B)Z"));
        options.addOption(new Option("vulnLine", true, "Vulnerable line to be targeted by an exploit. A non negative number needs to be provided, e.g. 12"));
        options.addOption(new Option("client", true, "Client class where an exploit will start from. A fully qualifying needs to be provided, e.g. org.foo.SomeClass"));

        String clientCP = null;
        String vulnerabilities = null;
        String vulnClass = null;
        String vulnMethod = null;
        String vulnLine = null;
        String client = null;
        String budget = null;
        CommandLineParser parser = new DefaultParser();
        try {
            CommandLine line = parser.parse(options, args);
            clientCP = line.getOptionValue("clientCP");
            if (clientCP == null) {
                System.err.println("clientCP option needs to be specified. Exiting.");
                System.exit(1);
            }
            vulnerabilities = line.getOptionValue("vulnerabilities");
            vulnClass = line.getOptionValue("vulnClass");
            vulnMethod = line.getOptionValue("vulnMethod");
            vulnLine = line.getOptionValue("vulnLine");
            client = line.getOptionValue("client");
            budget = line.getOptionValue("budget");
        } catch (ParseException e) {
            System.err.println("Malformed arguments. Exiting.");
            System.exit(1);
        }

        List<ImmutableTriple<String, String, String>> vulnerabilityList = new ArrayList<>();
        if (vulnerabilities != null) {
            try {
                vulnerabilityList.addAll(parseFile(vulnerabilities));
            } catch (IOException e) {
                System.err.println("Vulnerabilities file not found. Exiting.");
                System.exit(1);
            }
        } else {
            if (vulnClass == null && vulnMethod == null && vulnLine == null) {
                System.err.println("Either vulnerabilities or vulnClass, vulnMethod and vulnLine needs to be specified.");
                System.exit(1);
            }
            if (vulnClass == null || vulnMethod == null || vulnLine == null) {
                System.err.println("All vulnClass, vulnMethod and vulnLine needs to be specified togeher.");
                System.exit(1);
            }
            vulnerabilityList.add(new ImmutableTriple<>(vulnClass, vulnMethod, vulnLine));
        }

        // Default search budget for tests is 60 (the meaning depends on stopping condition).
        if (budget != null) {
            try {
                Properties.SEARCH_BUDGET = Long.parseLong(budget);
            } catch (NumberFormatException e) {
                logger.error("Invalid search budget: using default value.");
            }
        }

        // TODO Bound population?
        // TODO Is there a way not to stop the generation when all the TC have the same fitness? Which MH is the best?
        List<String> baseCommands = new ArrayList<>(Arrays.asList("-generateTests",
                "-criterion", Properties.Criterion.VULNERABILITY.name(),
                "-Dstrategy=" + Properties.Strategy.ONEBRANCH.name(),
                "-Dinstrument_context=true",
                "-Dinstrument_method_calls=true",
                "-Dinstrument_libraries=true",
                "-Dassertions=false",
                "-Dminimize=true",
                "-Dstopping_condition=" + Properties.StoppingCondition.MAXTIME,
                "-Dpopulation=" + 100,
                "-Djunit_suffix=SiegeTest",
                "-projectCP", clientCP
        ));
        if (client != null) {
            baseCommands.add("-class");
            baseCommands.add(client);
        } else {
            baseCommands.add("-target");
            baseCommands.add(clientCP);
        }

        String clientAbsolutePath = System.getProperty("user.dir");
        // TODO Convert sout to proper logging
        System.out.println("* Generating Exploits through " + clientAbsolutePath);
        System.out.println();
        for (ImmutableTriple<String, String, String> vulnerabilityTriple : vulnerabilityList) {
            System.out.println("* Target Vulnerability: " + vulnerabilityTriple);
            List<String> evoSuiteCommands = new ArrayList<>(baseCommands);
            evoSuiteCommands.add("-DvulnClass=" + vulnerabilityTriple.left);
            evoSuiteCommands.add("-DvulnMethod=" + vulnerabilityTriple.middle);
            evoSuiteCommands.add("-DvulnLine=" + vulnerabilityTriple.right);
            try {
                List<List<TestGenerationResult>> fullResults = (List<List<TestGenerationResult>>) evoSuite.parseCommandLine(evoSuiteCommands.toArray(new String[0]));
                System.out.println("\n* Printing Results for " + vulnerabilityTriple);
                for (List<TestGenerationResult> testResults : fullResults) {
                    for (TestGenerationResult testResult : testResults) {
                        GeneticAlgorithm<?> ga = testResult.getGeneticAlgorithm();
                        TestChromosome best = (TestChromosome) ga.getBestIndividual();
                        System.out.printf("* Terminated (with %d seconds budget)! Age: %d, Population Size: %d%n", Properties.SEARCH_BUDGET, ga.getAge(), ga.getPopulationSize());
                        System.out.printf("* Best Individual %d (Gen %d, Eval %d):%n", best.getTestCase().getID(), best.getAge(), best.getNumberOfEvaluations());
                        System.out.println(best.getTestCase().toCode());
                        System.out.printf("* Best Individual after Minimization:%n");
                        System.out.println(testResult.getTestCase("test0").toCode());
                    }
                }
            } catch (Exception e) {
                // Print but go ahead
                e.printStackTrace();
            }
            System.out.println();
        }
        System.exit(0);
    }

    private static List<ImmutableTriple<String, String, String>> parseFile(String file) throws IOException {
        List<ImmutableTriple<String, String, String>> vulnerabilityList = new ArrayList<>();
        try (CSVReader reader = new CSVReaderBuilder(new FileReader(file)).withSkipLines(1).build()) {
            String[] values;
            while ((values = reader.readNext()) != null) {
                vulnerabilityList.add(new ImmutableTriple<>(values[2], values[3], values[4]));
            }
        }
        return vulnerabilityList;
    }
}
