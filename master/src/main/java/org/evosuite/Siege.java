package org.evosuite;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.evosuite.ga.metaheuristics.GeneticAlgorithm;
import org.evosuite.result.TestGenerationResult;
import org.evosuite.testcase.TestChromosome;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Siege {
    protected static Logger logger = LoggerFactory.getLogger(Siege.class);

    public static void main(String[] args) {
        EvoSuite evoSuite = new EvoSuite();

        // TODO Accept and parse a CSV containing vulnerability descriptions. Should use ; as separator
        Options options = new Options();
        options.addOption(new Option("clientCP", true, "Client project classpath. A fully qualifying needs to be provided, e.g. org.foo.SomeClass"));
        options.addOption(new Option("client", true, "Client class where an exploit will start from. A fully qualifying needs to be provided, e.g. org.foo.SomeClass"));
        options.addOption(new Option("vulnClass", true, "Vulnerable class to be targeted by an exploit. A fully qualifying needs to be provided, e.g. org.foo.SomeClass"));
        options.addOption(new Option("vulnMethod", true, "Vulnerable method to be targeted by an exploit. A name and descriptor needs to be provided, e.g. someMethod([B[B)Z"));
        options.addOption(new Option("vulnLine", true, "Vulnerable line to be targeted by an exploit. A non negative number needs to be provided, e.g. 12"));

        String clientCP = "";
        String vulnClass = "";
        String vulnMethod = "";
        String vulnLine = "";
        String client = "";
        String budget = "";
        CommandLineParser parser = new DefaultParser();
        try {
            CommandLine line = parser.parse(options, args);
            if (!line.hasOption("clientCP")) {
                throw new IllegalArgumentException("clientCP option needs to be specified");
            }
            if (!line.hasOption("vulnClass")) {
                throw new IllegalArgumentException("vulnClass option needs to be specified");
            }
            if (!line.hasOption("vulnMethod")) {
                throw new IllegalArgumentException("vulnMethod option needs to be specified");
            }
            if (!line.hasOption("vulnLine")) {
                throw new IllegalArgumentException("vulnLine option needs to be specified");
            }
            clientCP = line.getOptionValue("clientCP");
            vulnClass = line.getOptionValue("vulnClass");
            vulnMethod = line.getOptionValue("vulnMethod");
            vulnLine = line.getOptionValue("vulnLine");
            if (line.hasOption("client")) {
                client = line.getOptionValue("client");
            }
            if (line.hasOption("budget")) {
                budget = line.getOptionValue("budget");
            }
        } catch (ParseException e) {
            e.printStackTrace();
        }

        // Default search budget for tests is 60 (the meaning depends on stopping condition).
        if (!budget.equals("")) {
            try {
                Properties.SEARCH_BUDGET = Long.parseLong(budget);
            } catch (NumberFormatException e) {
                logger.error("Invalid search budget: using default value.");
            }
        }

        // TODO Bound population?
        // TODO Is there a way not to stop the generation when all the TC have the same fitness? Which MH is the best?
        List<String> evoSuiteCommands = new ArrayList<>(Arrays.asList("-generateTests",
                "-criterion", Properties.Criterion.VULNERABILITY.name(),
                "-Dstrategy=" + Properties.Strategy.ONEBRANCH.name(),
                "-Dinstrument_context=true",
                "-Dinstrument_method_calls=true",
                "-Dinstrument_libraries=true",
                "-Dassertions=false",
                "-Dminimize=true",
                "-Dstopping_condition=" + Properties.StoppingCondition.MAXTIME,
                "-Dpopulation=" + 100,
                "-Djunit_suffix=SiegeTest",
                "-DvulnClass=" + vulnClass,
                "-DvulnMethod=" + vulnMethod,
                "-DvulnLine=" + vulnLine,
                "-projectCP", clientCP
        ));
        if (client.equals("")) {
            evoSuiteCommands.add("-class");
            evoSuiteCommands.add(client);
        } else {
            evoSuiteCommands.add("-target");
            evoSuiteCommands.add(clientCP);
        }
        try {
            List<List<TestGenerationResult>> fullResults = (List<List<TestGenerationResult>>) evoSuite.parseCommandLine(evoSuiteCommands.toArray(new String[0]));
            System.out.println("\n* Printing Results");
            for (List<TestGenerationResult> testResults : fullResults) {
                for (TestGenerationResult testResult: testResults) {
                    GeneticAlgorithm<?> ga = testResult.getGeneticAlgorithm();
                    TestChromosome best = (TestChromosome) ga.getBestIndividual();
                    System.out.printf("* Terminated (with %d seconds budget)! Age: %d, Population Size: %d%n", Properties.SEARCH_BUDGET, ga.getAge(), ga.getPopulationSize());
                    System.out.printf("* Best Individual %d (Gen %d, Eval %d):%n", best.getTestCase().getID(), best.getAge(), best.getNumberOfEvaluations());
                    System.out.println(best.getTestCase().toCode());
                    System.out.printf("* Best Individual after Minimization:%n");
                    System.out.println(testResult.getTestCase("test0").toCode());
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.exit(0);
    }
}
