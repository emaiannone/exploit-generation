package org.evosuite;

import com.opencsv.CSVReader;
import com.opencsv.CSVReaderBuilder;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.lang3.tuple.ImmutableTriple;
import org.evosuite.ga.metaheuristics.GeneticAlgorithm;
import org.evosuite.result.TestGenerationResult;
import org.evosuite.testcase.TestChromosome;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Siege {
    private static final Logger logger = LoggerFactory.getLogger(Siege.class);
    public static final String PROJECT = "project";
    public static final String CP = "cp";
    public static final String CLASS = "class";
    public static final String VULNERABILITIES = "vulnerabilities";
    public static final String VULN_CLASS = "vulnClass";
    public static final String VULN_METHOD = "vulnMethod";
    public static final String VULN_LINE = "vulnLine";
    public static final String BUDGET = "budget";

    public static final String DEFAULT_CP = "target/classes";

    public static void main(String[] args) {
        EvoSuite evoSuite = new EvoSuite();

        Options options = new Options();
        options.addOption(new Option(PROJECT, true, "Client project root directory. A directory containing all the assests of a Java project needs to be provided."));
        options.addOption(new Option(CP, true, "Client project classpath. A directory containing all compiled Java classes needs to be provided, e.g. target/classes"));
        options.addOption(new Option(CLASS, true, "Client class where an exploit will start from. A fully qualifying needs to be provided, e.g. org.foo.SomeClass"));
        options.addOption(new Option(VULNERABILITIES, true, "CSV File containing descriptions of a set of known vulnerabilities. A CSV file needs to be provided."));
        options.addOption(new Option(VULN_CLASS, true, "Vulnerable class to be targeted by an exploit. A fully qualifying needs to be provided, e.g. org.foo.SomeClass"));
        options.addOption(new Option(VULN_METHOD, true, "Vulnerable method to be targeted by an exploit. A name and descriptor needs to be provided, e.g. someMethod([B[B)Z"));
        options.addOption(new Option(VULN_LINE, true, "Vulnerable line to be targeted by an exploit. A non negative number needs to be provided, e.g. 12"));
        options.addOption(new Option(BUDGET, true, "Allotted search budget. A non negative number needs to be provided, e.g. 50"));

        String project = null;
        String classpath = null;
        String clientClass = null;
        String vulnerabilities = null;
        String vulnClass = null;
        String vulnMethod = null;
        String vulnLine = null;
        String budget = null;
        CommandLineParser parser = new DefaultParser();
        try {
            CommandLine line = parser.parse(options, args);
            project = line.getOptionValue(PROJECT);
            if (project == null) {
                System.err.println("-project option needs to be specified. Exiting.");
                System.exit(1);
            }
            classpath = line.getOptionValue(CP);
            clientClass = line.getOptionValue(CLASS);
            vulnerabilities = line.getOptionValue(VULNERABILITIES);
            vulnClass = line.getOptionValue(VULN_CLASS);
            vulnMethod = line.getOptionValue(VULN_METHOD);
            vulnLine = line.getOptionValue(VULN_LINE);
            budget = line.getOptionValue(BUDGET);
        } catch (ParseException e) {
            System.err.println("Invalid options. Exiting.");
            System.exit(1);
        }

        // Set target/classes as default classpath
        if (classpath == null) {
            classpath = DEFAULT_CP;
        }
        String absoluteClasspath = project + "/" + classpath;

        // Get target vulnerability(ies)
        List<ImmutableTriple<String, String, String>> vulnerabilityList = new ArrayList<>();
        if (vulnerabilities != null) {
            try {
                vulnerabilityList.addAll(parseFile(vulnerabilities));
            } catch (IOException e) {
                System.err.println("Vulnerabilities file not found. Exiting.");
                System.exit(1);
            }
        } else {
            if (vulnClass == null && vulnMethod == null && vulnLine == null) {
                System.err.println("Either vulnerabilities or vulnClass, vulnMethod and vulnLine needs to be specified.");
                System.exit(1);
            }
            if (vulnClass == null || vulnMethod == null || vulnLine == null) {
                System.err.println("All vulnClass, vulnMethod and vulnLine needs to be specified togeher.");
                System.exit(1);
            }
            vulnerabilityList.add(new ImmutableTriple<>(vulnClass, vulnMethod, vulnLine));
        }

        // TODO Bound population?
        // TODO Is there a way not to stop the generation when all the TC have the same fitness? Which MH is the best?
        List<String> baseCommands = new ArrayList<>(Arrays.asList(
                "-projectCP", absoluteClasspath,
                "-generateTests",
                "-criterion", Properties.Criterion.VULNERABILITY.name(),
                "-Dstrategy=" + Properties.Strategy.ONEBRANCH.name(),
                "-Dinstrument_context=true",
                "-Dinstrument_method_calls=true",
                "-Dinstrument_libraries=true",
                "-Dassertions=false",
                "-Dminimize=true",
                "-Dstopping_condition=" + Properties.StoppingCondition.MAXTIME,
                "-Dpopulation=" + 100,
                "-Djunit_suffix=SiegeTest"
        ));

        // -class option overrides making SIEGE run on the specified class only, instead on the entire classpath
        if (clientClass != null) {
            baseCommands.add("-class");
            baseCommands.add(clientClass);
        } else {
            baseCommands.add("-target");
            baseCommands.add(classpath);
        }

        // Default budget is 60 (set by EvoSuite if -Dsearch_budget is not specified)
        if (budget != null) {
            baseCommands.add("-Dsearch_budget" + budget);
        }

        // TODO Convert sout to proper logging
        System.out.println("* Generating Exploits through " + project);
        System.out.println();
        for (ImmutableTriple<String, String, String> vulnerabilityTriple : vulnerabilityList) {
            System.out.println("* Target Vulnerability: " + vulnerabilityTriple);
            List<String> evoSuiteCommands = new ArrayList<>(baseCommands);
            evoSuiteCommands.add("-DvulnClass=" + vulnerabilityTriple.left);
            evoSuiteCommands.add("-DvulnMethod=" + vulnerabilityTriple.middle);
            evoSuiteCommands.add("-DvulnLine=" + vulnerabilityTriple.right);
            try {
                List<List<TestGenerationResult>> fullResults = (List<List<TestGenerationResult>>) evoSuite.parseCommandLine(evoSuiteCommands.toArray(new String[0]));
                System.out.println("\n* Printing Results for " + vulnerabilityTriple);
                for (List<TestGenerationResult> testResults : fullResults) {
                    for (TestGenerationResult testResult : testResults) {
                        GeneticAlgorithm<?> ga = testResult.getGeneticAlgorithm();
                        TestChromosome best = (TestChromosome) ga.getBestIndividual();
                        System.out.printf("* Terminated (with %d seconds budget)! Age: %d, Population Size: %d%n", Properties.SEARCH_BUDGET, ga.getAge(), ga.getPopulationSize());
                        System.out.printf("* Best Individual %d (Gen %d, Eval %d):%n", best.getTestCase().getID(), best.getAge(), best.getNumberOfEvaluations());
                        System.out.println(best.getTestCase().toCode());
                        System.out.printf("* Best Individual after Minimization:%n");
                        System.out.println(testResult.getTestCase("test0").toCode());
                    }
                }
            } catch (Exception e) {
                // Print but go ahead
                e.printStackTrace();
            }
            System.out.println();
        }
        System.exit(0);
    }

    private static List<ImmutableTriple<String, String, String>> parseFile(String file) throws IOException {
        List<ImmutableTriple<String, String, String>> vulnerabilityList = new ArrayList<>();
        try (CSVReader reader = new CSVReaderBuilder(new FileReader(file)).withSkipLines(1).build()) {
            String[] values;
            while ((values = reader.readNext()) != null) {
                vulnerabilityList.add(new ImmutableTriple<>(values[2], values[3], values[4]));
            }
        }
        return vulnerabilityList;
    }
}
